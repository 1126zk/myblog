{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to ZK's Website \u5f53\u524d\u6b63\u5728\u66f4\u65b0rcore\u7cfb\u5217 \u200b - \u7b2c\u4e09\u7ae0 \u5df2\u66f4\u65b0 2022 .2.10","title":"Home"},{"location":"#welcome-to-zks-website","text":"","title":"Welcome to ZK's Website"},{"location":"#rcore","text":"\u200b - \u7b2c\u4e09\u7ae0 \u5df2\u66f4\u65b0 2022 .2.10","title":"\u5f53\u524d\u6b63\u5728\u66f4\u65b0rcore\u7cfb\u5217"},{"location":"ch1%E5%86%85%E6%A0%B8%E7%AC%AC%E4%B8%80%E6%9D%A1%E6%8C%87%E4%BB%A4/","text":"\u5185\u6838\u7b2c\u4e00\u6761\u6307\u4ee4 \u7b2c\u4e00\u7ae0\u4ee3\u7801\u6811 ./os/src Rust 4 Files 119 Lines Assembly 1 Files 11 Lines \u251c\u2500\u2500 bootloader(\u5185\u6838\u4f9d\u8d56\u7684\u8fd0\u884c\u5728 M \u7279\u6743\u7ea7\u7684 SBI \u5b9e\u73b0\uff0c\u672c\u9879\u76ee\u4e2d\u6211\u4eec\u4f7f\u7528 RustSBI) \u2502 \u251c\u2500\u2500 rustsbi-k210.bin(\u53ef\u8fd0\u884c\u5728 k210 \u771f\u5b9e\u786c\u4ef6\u5e73\u53f0\u4e0a\u7684\u9884\u7f16\u8bd1\u4e8c\u8fdb\u5236\u7248\u672c) \u2502 \u2514\u2500\u2500 rustsbi-qemu.bin(\u53ef\u8fd0\u884c\u5728 qemu \u865a\u62df\u673a\u4e0a\u7684\u9884\u7f16\u8bd1\u4e8c\u8fdb\u5236\u7248\u672c) \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 os(\u6211\u4eec\u7684\u5185\u6838\u5b9e\u73b0\u653e\u5728 os \u76ee\u5f55\u4e0b) \u2502 \u251c\u2500\u2500 Cargo.toml(\u5185\u6838\u5b9e\u73b0\u7684\u4e00\u4e9b\u914d\u7f6e\u6587\u4ef6) \u2502 \u251c\u2500\u2500 Makefile \u2502 \u2514\u2500\u2500 src(\u6240\u6709\u5185\u6838\u7684\u6e90\u4ee3\u7801\u653e\u5728 os/src \u76ee\u5f55\u4e0b) \u2502 \u251c\u2500\u2500 console.rs(\u5c06\u6253\u5370\u5b57\u7b26\u7684 SBI \u63a5\u53e3\u8fdb\u4e00\u6b65\u5c01\u88c5\u5b9e\u73b0\u66f4\u52a0\u5f3a\u5927\u7684\u683c\u5f0f\u5316\u8f93\u51fa) \u2502 \u251c\u2500\u2500 entry.asm(\u8bbe\u7f6e\u5185\u6838\u6267\u884c\u73af\u5883\u7684\u7684\u4e00\u6bb5\u6c47\u7f16\u4ee3\u7801) \u2502 \u251c\u2500\u2500 lang_items.rs(\u9700\u8981\u6211\u4eec\u63d0\u4f9b\u7ed9 Rust \u7f16\u8bd1\u5668\u7684\u4e00\u4e9b\u8bed\u4e49\u9879\uff0c\u76ee\u524d\u5305\u542b\u5185\u6838 panic \u65f6\u7684\u5904\u7406\u903b\u8f91) \u2502 \u251c\u2500\u2500 linker-k210.ld(\u63a7\u5236\u5185\u6838\u5185\u5b58\u5e03\u5c40\u7684\u94fe\u63a5\u811a\u672c\u4ee5\u4f7f\u5185\u6838\u8fd0\u884c\u5728 k210 \u771f\u5b9e\u786c\u4ef6\u5e73\u53f0\u4e0a) \u2502 \u251c\u2500\u2500 linker-qemu.ld(\u63a7\u5236\u5185\u6838\u5185\u5b58\u5e03\u5c40\u7684\u94fe\u63a5\u811a\u672c\u4ee5\u4f7f\u5185\u6838\u8fd0\u884c\u5728 qemu \u865a\u62df\u673a\u4e0a) \u2502 \u251c\u2500\u2500 main.rs(\u5185\u6838\u4e3b\u51fd\u6570) \u2502 \u2514\u2500\u2500 sbi.rs(\u8c03\u7528\u5e95\u5c42 SBI \u5b9e\u73b0\u63d0\u4f9b\u7684 SBI \u63a5\u53e3) \u251c\u2500\u2500 README.md \u251c\u2500\u2500 rust-toolchain(\u63a7\u5236\u6574\u4e2a\u9879\u76ee\u7684\u5de5\u5177\u94fe\u7248\u672c) \u2514\u2500\u2500 tools(\u81ea\u52a8\u4e0b\u8f7d\u7684\u5c06\u5185\u6838\u70e7\u5199\u5230 k210 \u5f00\u53d1\u677f\u4e0a\u7684\u5de5\u5177) \u251c\u2500\u2500 kflash.py \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 package.json \u251c\u2500\u2500 README.rst \u2514\u2500\u2500 setup.py \u672c\u8282\u6587\u4ef6\u89e3\u6790 bootloader \u6587\u4ef6\u5939\u4e0b rustsbi-qemu.bin os \u6587\u4ef6\u5939\u4e0b ./cargo/config # \u914d\u7f6e\u6587\u4ef6\u6ca1\u6709\u6ce8\u91ca\uff0c \u9ed8\u8ba4 # \u540e\u9762\u63a5\u6ce8\u91ca [build] target = \"riscv64gc-unknown-none-elf\" # \u6307\u5b9a\u76ee\u6807\u5e73\u53f0\uff0c\u4e0d\u7136\u7f16\u8bd1\u65f6\u8981\u5e26\u4e0a\u53c2\u6570 # cargo run --target riscv64gc-unknown-none-elf [target.riscv64gc-unknown-none-elf] rustflags = [ \"-Clink-arg=-Tsrc/linker.ld\", \"-Cforce-frame-pointers=yes\" ] # \u7528\u4e8e\u6307\u5b9a\u94fe\u63a5\u6587\u4ef6\u7684\u5730\u5740 # -T\u540e\u9762\u63a5\u6587\u4ef6\u8def\u5f84 # -Cforce-frame-pointers=yes \u4f30\u8ba1\u662fllvm\u4e2d\u5bf9\u6307\u9488\u7684\u4f18\u5316\u6216\u5176\u4ed6\u5e95\u5c42\u64cd\u4f5c os/Cargo.toml [package] name = \"os\" version = \"0.1.0\" edition = \"2021\" # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html [dependencies] # \u6b64\u65f6\u8fd8\u4e0d\u9700\u8981\u914d\u7f6e\u4ec0\u4e48 os/src/entry.asm .section .text.entry .globl _start _start: li x1, 100 # \u8fd9\u5c31\u662f\u672c\u8282\u6240\u8bf4\u7684 \u5185\u6838\u7b2c\u4e00\u6761\u6307\u4ee4 # \u5c31\u662f\u4e00\u6761\u5355\u7eaf\u7684 riscv \u7684\u6c47\u7f16\u4ee3\u7801 os/src/linker.ld # \u94fe\u63a5\u811a\u672c OUTPUT_ARCH(riscv) # \u6307\u5b9a\u76ee\u6807\u6587\u4ef6\u6240\u5728\u7684\u5e73\u53f0 ENTRY(_start) # \u6307\u5b9a\u5165\u53e3\u5730\u5740 # \u5728\u7a0b\u5e8f\u4e2d\u6267\u884c\u7684\u7b2c\u4e00\u6761\u6307\u4ee4\u79f0\u4e3a\u5165\u53e3\u70b9\u3002 \u60a8\u53ef\u4ee5\u4f7f\u7528 ENTRY \u94fe\u63a5\u5668\u811a\u672c\u547d\u4ee4\u6765\u8bbe\u7f6e\u5165\u53e3\u70b9\u3002 \u53c2\u6570\u662f\u7b26\u53f7\u540d\u79f0 BASE_ADDRESS = 0x80200000; # \u7c7b\u4f3c\u4e00\u4e2a\u5168\u5c40\u53d8\u91cf # \u6307\u4ee4\u5185\u6838\u4ece 0x80200000 \u5904\u5f00\u59cb\u5b58\u653e SECTIONS { . = BASE_ADDRESS; skernel = .; stext = .; .text : { *(.text.entry) *(.text .text.*) } # \u5185\u6838\u4ece 0x80200000 \u5f00\u59cb\uff0c # \u6700\u5f00\u65f6\u5b58\u653e\u7684\u662f \u4ee3\u7801\u6bb5\uff0c # \u800c\u4e14\u662f\u6307\u5b9a\u7684 .text.entry \u6bb5 # \u5373 entry.asm \u7684 \u7b2c\u4e00\u4e2a\u4ee3\u7801\u6bb5 # \u5176\u4ed6\u7684\u4ee3\u7801\u6bb5\u4e5f\u5b58\u653e\u5728\u6b64\u5904 . = ALIGN(4K); etext = .; srodata = .; .rodata : { *(.rodata .rodata.*) *(.srodata .srodata.*) } # \u6b64\u5904\u5b58\u653e\u6240\u6709\u7684 rodata \u6bb5 . = ALIGN(4K); erodata = .; sdata = .; .data : { *(.data .data.*) *(.sdata .sdata.*) } # \u6b64\u5904\u5b58\u653e\u6240\u6709 data \u6bb5 . = ALIGN(4K); edata = .; .bss : { *(.bss.stack) sbss = .; *(.bss .bss.*) *(.sbss .sbss.*) } # \u6b64\u5904\u5b58\u653e\u6240\u6709 bss \u6bb5 # \u6ce8\u610f\uff0c\u6709\u4e2a \u7279\u6b8a\u7684\u6808\u6bb5\u4e5f\u5b58\u653e\u5728\u6b64\u5904 # \u5373 .bss.stack \u6bb5 . = ALIGN(4K); ebss = .; ekernel = .; /DISCARD/ : { *(.eh_frame) } } os/src/lang_items.rs use core::panic::PanicInfo; #[panic_handler] fn panic(_info: &PanicInfo) -> ! { loop {} } //\u6b64\u65f6\u53ea\u662f\u91cd\u5199\u4e86 panic //\u4f46\u672a\u505a\u4efb\u4f55\u5904\u7406 \u5f85\u89e3\u51b3\u7684\u95ee\u9898 \u6211\u4eec\u5c1d\u8bd5\u76f4\u63a5\u8c03\u7528\u5b83\uff0c\u770b\u4f1a\u51fa\u73b0\u4ec0\u4e48\u60c5\u51b5 \u5b83\u80fd\u5426\u88ab\u8c03\u7528\uff0c\u662f\u5426\u88ab\u8c03\u7528 \u5355\u5f53\u6267\u884c\u5b8c 0x8020000 \u7684 li ra, 100 \u540e\u518d\u6b21\u6267\u884c si\uff0c\u540e\u9762\u90fd\u662funimp\uff0c\u4f46\u4e3a\u4ec0\u4e48\u8fd8\u53ef\u4ee5\u6267\u884c \u8df3\u8f6c\u540e\u7684\u4ee3\u7801\u662f\u5426\u4e3a panic\u7684\uff0c\u4e3a\u4ec0\u4e48\u4e00\u76f4si\u6267\u884c\u5230 0x800007956\u540e\u6267\u884c\uff0c\u4f1a\u8c03\u52300x80200000 \u518d\u6b21\u57280x80007956\u5904\u8bbe\u65ad\u70b9\u540e\u6267\u884c\u4e00\u5708\uff0c\u5c31\u8df3\u52300x00000000\u5904\u4e86\uff0c\u5e76\u4e14\u4e0d\u80fd\u6267\u884c\u4e86 ------------------------------------------------------------------------ ==== ------------------------------------------------------------------------ os/src/main.rs #![no_std] #![no_main] mod lang_items; use core::arch::global_asm; global_asm!(include_str!(\"entry.asm\")); // \u7531\u4e8e\u8fd9\u662f\u4e2arust\u9879\u76ee\uff0c\u6211\u4eec\u5e76\u6ca1\u6709\u76f4\u63a5\u7528\u6c47\u7f16\u5668\u7f16\u8bd1 \u6c47\u7f16\u4ee3\u7801 // \u6240\u4ee5 \u6211\u4eec\u662f\u4ee5\u5185\u8054\u6c47\u7f16\u7684\u5f62\u5f0f\u5c06\u6c47\u7f16\u4ee3\u7801\u5bfc\u5165\u5230rust\u6587\u4ef6\u4e2d\uff0c\u518d\u7f16\u8bd1 // \u6240\u4ee5\u9879\u76ee\u7684\u5165\u53e3\u8fd8\u662f main.rs // \u53ea\u4e0d\u8fc7\u4ee3\u7801\u7684\u6267\u884c\u5982\u4f55\u4e0d\u662fmain\u51fd\u6570\u4e86 // \u800c\u662f\u6307\u5b9a\u7684_start //fn main() { // println!(\"Hello, world!\"); //} \u6267\u884c\u6d41\u7a0b main.rs \u4e2d\u5185\u8054\u7684 entry.esm \u7684\u4e00\u6761riscv\u7684\u6c47\u7f16\u6307\u4ee4","title":"\u5185\u6838\u7b2c\u4e00\u6761\u6307\u4ee4"},{"location":"ch1%E5%86%85%E6%A0%B8%E7%AC%AC%E4%B8%80%E6%9D%A1%E6%8C%87%E4%BB%A4/#_1","text":"","title":"\u5185\u6838\u7b2c\u4e00\u6761\u6307\u4ee4"},{"location":"ch1%E5%86%85%E6%A0%B8%E7%AC%AC%E4%B8%80%E6%9D%A1%E6%8C%87%E4%BB%A4/#_2","text":"./os/src Rust 4 Files 119 Lines Assembly 1 Files 11 Lines \u251c\u2500\u2500 bootloader(\u5185\u6838\u4f9d\u8d56\u7684\u8fd0\u884c\u5728 M \u7279\u6743\u7ea7\u7684 SBI \u5b9e\u73b0\uff0c\u672c\u9879\u76ee\u4e2d\u6211\u4eec\u4f7f\u7528 RustSBI) \u2502 \u251c\u2500\u2500 rustsbi-k210.bin(\u53ef\u8fd0\u884c\u5728 k210 \u771f\u5b9e\u786c\u4ef6\u5e73\u53f0\u4e0a\u7684\u9884\u7f16\u8bd1\u4e8c\u8fdb\u5236\u7248\u672c) \u2502 \u2514\u2500\u2500 rustsbi-qemu.bin(\u53ef\u8fd0\u884c\u5728 qemu \u865a\u62df\u673a\u4e0a\u7684\u9884\u7f16\u8bd1\u4e8c\u8fdb\u5236\u7248\u672c) \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 os(\u6211\u4eec\u7684\u5185\u6838\u5b9e\u73b0\u653e\u5728 os \u76ee\u5f55\u4e0b) \u2502 \u251c\u2500\u2500 Cargo.toml(\u5185\u6838\u5b9e\u73b0\u7684\u4e00\u4e9b\u914d\u7f6e\u6587\u4ef6) \u2502 \u251c\u2500\u2500 Makefile \u2502 \u2514\u2500\u2500 src(\u6240\u6709\u5185\u6838\u7684\u6e90\u4ee3\u7801\u653e\u5728 os/src \u76ee\u5f55\u4e0b) \u2502 \u251c\u2500\u2500 console.rs(\u5c06\u6253\u5370\u5b57\u7b26\u7684 SBI \u63a5\u53e3\u8fdb\u4e00\u6b65\u5c01\u88c5\u5b9e\u73b0\u66f4\u52a0\u5f3a\u5927\u7684\u683c\u5f0f\u5316\u8f93\u51fa) \u2502 \u251c\u2500\u2500 entry.asm(\u8bbe\u7f6e\u5185\u6838\u6267\u884c\u73af\u5883\u7684\u7684\u4e00\u6bb5\u6c47\u7f16\u4ee3\u7801) \u2502 \u251c\u2500\u2500 lang_items.rs(\u9700\u8981\u6211\u4eec\u63d0\u4f9b\u7ed9 Rust \u7f16\u8bd1\u5668\u7684\u4e00\u4e9b\u8bed\u4e49\u9879\uff0c\u76ee\u524d\u5305\u542b\u5185\u6838 panic \u65f6\u7684\u5904\u7406\u903b\u8f91) \u2502 \u251c\u2500\u2500 linker-k210.ld(\u63a7\u5236\u5185\u6838\u5185\u5b58\u5e03\u5c40\u7684\u94fe\u63a5\u811a\u672c\u4ee5\u4f7f\u5185\u6838\u8fd0\u884c\u5728 k210 \u771f\u5b9e\u786c\u4ef6\u5e73\u53f0\u4e0a) \u2502 \u251c\u2500\u2500 linker-qemu.ld(\u63a7\u5236\u5185\u6838\u5185\u5b58\u5e03\u5c40\u7684\u94fe\u63a5\u811a\u672c\u4ee5\u4f7f\u5185\u6838\u8fd0\u884c\u5728 qemu \u865a\u62df\u673a\u4e0a) \u2502 \u251c\u2500\u2500 main.rs(\u5185\u6838\u4e3b\u51fd\u6570) \u2502 \u2514\u2500\u2500 sbi.rs(\u8c03\u7528\u5e95\u5c42 SBI \u5b9e\u73b0\u63d0\u4f9b\u7684 SBI \u63a5\u53e3) \u251c\u2500\u2500 README.md \u251c\u2500\u2500 rust-toolchain(\u63a7\u5236\u6574\u4e2a\u9879\u76ee\u7684\u5de5\u5177\u94fe\u7248\u672c) \u2514\u2500\u2500 tools(\u81ea\u52a8\u4e0b\u8f7d\u7684\u5c06\u5185\u6838\u70e7\u5199\u5230 k210 \u5f00\u53d1\u677f\u4e0a\u7684\u5de5\u5177) \u251c\u2500\u2500 kflash.py \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 package.json \u251c\u2500\u2500 README.rst \u2514\u2500\u2500 setup.py","title":"\u7b2c\u4e00\u7ae0\u4ee3\u7801\u6811"},{"location":"ch1%E5%86%85%E6%A0%B8%E7%AC%AC%E4%B8%80%E6%9D%A1%E6%8C%87%E4%BB%A4/#_3","text":"","title":"\u672c\u8282\u6587\u4ef6\u89e3\u6790"},{"location":"ch1%E5%86%85%E6%A0%B8%E7%AC%AC%E4%B8%80%E6%9D%A1%E6%8C%87%E4%BB%A4/#bootloader","text":"rustsbi-qemu.bin","title":"bootloader \u6587\u4ef6\u5939\u4e0b"},{"location":"ch1%E5%86%85%E6%A0%B8%E7%AC%AC%E4%B8%80%E6%9D%A1%E6%8C%87%E4%BB%A4/#os","text":"","title":"os \u6587\u4ef6\u5939\u4e0b"},{"location":"ch1%E5%86%85%E6%A0%B8%E7%AC%AC%E4%B8%80%E6%9D%A1%E6%8C%87%E4%BB%A4/#cargoconfig","text":"# \u914d\u7f6e\u6587\u4ef6\u6ca1\u6709\u6ce8\u91ca\uff0c \u9ed8\u8ba4 # \u540e\u9762\u63a5\u6ce8\u91ca [build] target = \"riscv64gc-unknown-none-elf\" # \u6307\u5b9a\u76ee\u6807\u5e73\u53f0\uff0c\u4e0d\u7136\u7f16\u8bd1\u65f6\u8981\u5e26\u4e0a\u53c2\u6570 # cargo run --target riscv64gc-unknown-none-elf [target.riscv64gc-unknown-none-elf] rustflags = [ \"-Clink-arg=-Tsrc/linker.ld\", \"-Cforce-frame-pointers=yes\" ] # \u7528\u4e8e\u6307\u5b9a\u94fe\u63a5\u6587\u4ef6\u7684\u5730\u5740 # -T\u540e\u9762\u63a5\u6587\u4ef6\u8def\u5f84 # -Cforce-frame-pointers=yes \u4f30\u8ba1\u662fllvm\u4e2d\u5bf9\u6307\u9488\u7684\u4f18\u5316\u6216\u5176\u4ed6\u5e95\u5c42\u64cd\u4f5c","title":"./cargo/config"},{"location":"ch1%E5%86%85%E6%A0%B8%E7%AC%AC%E4%B8%80%E6%9D%A1%E6%8C%87%E4%BB%A4/#oscargotoml","text":"[package] name = \"os\" version = \"0.1.0\" edition = \"2021\" # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html [dependencies] # \u6b64\u65f6\u8fd8\u4e0d\u9700\u8981\u914d\u7f6e\u4ec0\u4e48","title":"os/Cargo.toml"},{"location":"ch1%E5%86%85%E6%A0%B8%E7%AC%AC%E4%B8%80%E6%9D%A1%E6%8C%87%E4%BB%A4/#ossrcentryasm","text":".section .text.entry .globl _start _start: li x1, 100 # \u8fd9\u5c31\u662f\u672c\u8282\u6240\u8bf4\u7684 \u5185\u6838\u7b2c\u4e00\u6761\u6307\u4ee4 # \u5c31\u662f\u4e00\u6761\u5355\u7eaf\u7684 riscv \u7684\u6c47\u7f16\u4ee3\u7801","title":"os/src/entry.asm"},{"location":"ch1%E5%86%85%E6%A0%B8%E7%AC%AC%E4%B8%80%E6%9D%A1%E6%8C%87%E4%BB%A4/#ossrclinkerld","text":"# \u94fe\u63a5\u811a\u672c OUTPUT_ARCH(riscv) # \u6307\u5b9a\u76ee\u6807\u6587\u4ef6\u6240\u5728\u7684\u5e73\u53f0 ENTRY(_start) # \u6307\u5b9a\u5165\u53e3\u5730\u5740 # \u5728\u7a0b\u5e8f\u4e2d\u6267\u884c\u7684\u7b2c\u4e00\u6761\u6307\u4ee4\u79f0\u4e3a\u5165\u53e3\u70b9\u3002 \u60a8\u53ef\u4ee5\u4f7f\u7528 ENTRY \u94fe\u63a5\u5668\u811a\u672c\u547d\u4ee4\u6765\u8bbe\u7f6e\u5165\u53e3\u70b9\u3002 \u53c2\u6570\u662f\u7b26\u53f7\u540d\u79f0 BASE_ADDRESS = 0x80200000; # \u7c7b\u4f3c\u4e00\u4e2a\u5168\u5c40\u53d8\u91cf # \u6307\u4ee4\u5185\u6838\u4ece 0x80200000 \u5904\u5f00\u59cb\u5b58\u653e SECTIONS { . = BASE_ADDRESS; skernel = .; stext = .; .text : { *(.text.entry) *(.text .text.*) } # \u5185\u6838\u4ece 0x80200000 \u5f00\u59cb\uff0c # \u6700\u5f00\u65f6\u5b58\u653e\u7684\u662f \u4ee3\u7801\u6bb5\uff0c # \u800c\u4e14\u662f\u6307\u5b9a\u7684 .text.entry \u6bb5 # \u5373 entry.asm \u7684 \u7b2c\u4e00\u4e2a\u4ee3\u7801\u6bb5 # \u5176\u4ed6\u7684\u4ee3\u7801\u6bb5\u4e5f\u5b58\u653e\u5728\u6b64\u5904 . = ALIGN(4K); etext = .; srodata = .; .rodata : { *(.rodata .rodata.*) *(.srodata .srodata.*) } # \u6b64\u5904\u5b58\u653e\u6240\u6709\u7684 rodata \u6bb5 . = ALIGN(4K); erodata = .; sdata = .; .data : { *(.data .data.*) *(.sdata .sdata.*) } # \u6b64\u5904\u5b58\u653e\u6240\u6709 data \u6bb5 . = ALIGN(4K); edata = .; .bss : { *(.bss.stack) sbss = .; *(.bss .bss.*) *(.sbss .sbss.*) } # \u6b64\u5904\u5b58\u653e\u6240\u6709 bss \u6bb5 # \u6ce8\u610f\uff0c\u6709\u4e2a \u7279\u6b8a\u7684\u6808\u6bb5\u4e5f\u5b58\u653e\u5728\u6b64\u5904 # \u5373 .bss.stack \u6bb5 . = ALIGN(4K); ebss = .; ekernel = .; /DISCARD/ : { *(.eh_frame) } }","title":"os/src/linker.ld"},{"location":"ch1%E5%86%85%E6%A0%B8%E7%AC%AC%E4%B8%80%E6%9D%A1%E6%8C%87%E4%BB%A4/#ossrclang_itemsrs","text":"use core::panic::PanicInfo; #[panic_handler] fn panic(_info: &PanicInfo) -> ! { loop {} } //\u6b64\u65f6\u53ea\u662f\u91cd\u5199\u4e86 panic //\u4f46\u672a\u505a\u4efb\u4f55\u5904\u7406 \u5f85\u89e3\u51b3\u7684\u95ee\u9898 \u6211\u4eec\u5c1d\u8bd5\u76f4\u63a5\u8c03\u7528\u5b83\uff0c\u770b\u4f1a\u51fa\u73b0\u4ec0\u4e48\u60c5\u51b5 \u5b83\u80fd\u5426\u88ab\u8c03\u7528\uff0c\u662f\u5426\u88ab\u8c03\u7528 \u5355\u5f53\u6267\u884c\u5b8c 0x8020000 \u7684 li ra, 100 \u540e\u518d\u6b21\u6267\u884c si\uff0c\u540e\u9762\u90fd\u662funimp\uff0c\u4f46\u4e3a\u4ec0\u4e48\u8fd8\u53ef\u4ee5\u6267\u884c \u8df3\u8f6c\u540e\u7684\u4ee3\u7801\u662f\u5426\u4e3a panic\u7684\uff0c\u4e3a\u4ec0\u4e48\u4e00\u76f4si\u6267\u884c\u5230 0x800007956\u540e\u6267\u884c\uff0c\u4f1a\u8c03\u52300x80200000 \u518d\u6b21\u57280x80007956\u5904\u8bbe\u65ad\u70b9\u540e\u6267\u884c\u4e00\u5708\uff0c\u5c31\u8df3\u52300x00000000\u5904\u4e86\uff0c\u5e76\u4e14\u4e0d\u80fd\u6267\u884c\u4e86 ------------------------------------------------------------------------ ==== ------------------------------------------------------------------------","title":"os/src/lang_items.rs"},{"location":"ch1%E5%86%85%E6%A0%B8%E7%AC%AC%E4%B8%80%E6%9D%A1%E6%8C%87%E4%BB%A4/#ossrcmainrs","text":"#![no_std] #![no_main] mod lang_items; use core::arch::global_asm; global_asm!(include_str!(\"entry.asm\")); // \u7531\u4e8e\u8fd9\u662f\u4e2arust\u9879\u76ee\uff0c\u6211\u4eec\u5e76\u6ca1\u6709\u76f4\u63a5\u7528\u6c47\u7f16\u5668\u7f16\u8bd1 \u6c47\u7f16\u4ee3\u7801 // \u6240\u4ee5 \u6211\u4eec\u662f\u4ee5\u5185\u8054\u6c47\u7f16\u7684\u5f62\u5f0f\u5c06\u6c47\u7f16\u4ee3\u7801\u5bfc\u5165\u5230rust\u6587\u4ef6\u4e2d\uff0c\u518d\u7f16\u8bd1 // \u6240\u4ee5\u9879\u76ee\u7684\u5165\u53e3\u8fd8\u662f main.rs // \u53ea\u4e0d\u8fc7\u4ee3\u7801\u7684\u6267\u884c\u5982\u4f55\u4e0d\u662fmain\u51fd\u6570\u4e86 // \u800c\u662f\u6307\u5b9a\u7684_start //fn main() { // println!(\"Hello, world!\"); //}","title":"os/src/main.rs"},{"location":"ch1%E5%86%85%E6%A0%B8%E7%AC%AC%E4%B8%80%E6%9D%A1%E6%8C%87%E4%BB%A4/#_4","text":"main.rs \u4e2d\u5185\u8054\u7684 entry.esm \u7684\u4e00\u6761riscv\u7684\u6c47\u7f16\u6307\u4ee4","title":"\u6267\u884c\u6d41\u7a0b"},{"location":"ch1%E8%BE%93%E5%87%BAhello_world/","text":"\u8f93\u51fahello world \u5185\u6838\u7b2c\u4e00\u6761\u6307\u4ee4 \u7b2c\u4e00\u7ae0\u4ee3\u7801\u6811 ./os/src Rust 4 Files 119 Lines Assembly 1 Files 11 Lines \u251c\u2500\u2500 bootloader(\u5185\u6838\u4f9d\u8d56\u7684\u8fd0\u884c\u5728 M \u7279\u6743\u7ea7\u7684 SBI \u5b9e\u73b0\uff0c\u672c\u9879\u76ee\u4e2d\u6211\u4eec\u4f7f\u7528 RustSBI) \u2502 \u251c\u2500\u2500 rustsbi-k210.bin(\u53ef\u8fd0\u884c\u5728 k210 \u771f\u5b9e\u786c\u4ef6\u5e73\u53f0\u4e0a\u7684\u9884\u7f16\u8bd1\u4e8c\u8fdb\u5236\u7248\u672c) \u2502 \u2514\u2500\u2500 rustsbi-qemu.bin(\u53ef\u8fd0\u884c\u5728 qemu \u865a\u62df\u673a\u4e0a\u7684\u9884\u7f16\u8bd1\u4e8c\u8fdb\u5236\u7248\u672c) \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 os(\u6211\u4eec\u7684\u5185\u6838\u5b9e\u73b0\u653e\u5728 os \u76ee\u5f55\u4e0b) \u2502 \u251c\u2500\u2500 Cargo.toml(\u5185\u6838\u5b9e\u73b0\u7684\u4e00\u4e9b\u914d\u7f6e\u6587\u4ef6) \u2502 \u251c\u2500\u2500 Makefile \u2502 \u2514\u2500\u2500 src(\u6240\u6709\u5185\u6838\u7684\u6e90\u4ee3\u7801\u653e\u5728 os/src \u76ee\u5f55\u4e0b) \u2502 \u251c\u2500\u2500 console.rs(\u5c06\u6253\u5370\u5b57\u7b26\u7684 SBI \u63a5\u53e3\u8fdb\u4e00\u6b65\u5c01\u88c5\u5b9e\u73b0\u66f4\u52a0\u5f3a\u5927\u7684\u683c\u5f0f\u5316\u8f93\u51fa) \u2502 \u251c\u2500\u2500 entry.asm(\u8bbe\u7f6e\u5185\u6838\u6267\u884c\u73af\u5883\u7684\u7684\u4e00\u6bb5\u6c47\u7f16\u4ee3\u7801) \u2502 \u251c\u2500\u2500 lang_items.rs(\u9700\u8981\u6211\u4eec\u63d0\u4f9b\u7ed9 Rust \u7f16\u8bd1\u5668\u7684\u4e00\u4e9b\u8bed\u4e49\u9879\uff0c\u76ee\u524d\u5305\u542b\u5185\u6838 panic \u65f6\u7684\u5904\u7406\u903b\u8f91) \u2502 \u251c\u2500\u2500 linker-k210.ld(\u63a7\u5236\u5185\u6838\u5185\u5b58\u5e03\u5c40\u7684\u94fe\u63a5\u811a\u672c\u4ee5\u4f7f\u5185\u6838\u8fd0\u884c\u5728 k210 \u771f\u5b9e\u786c\u4ef6\u5e73\u53f0\u4e0a) \u2502 \u251c\u2500\u2500 linker-qemu.ld(\u63a7\u5236\u5185\u6838\u5185\u5b58\u5e03\u5c40\u7684\u94fe\u63a5\u811a\u672c\u4ee5\u4f7f\u5185\u6838\u8fd0\u884c\u5728 qemu \u865a\u62df\u673a\u4e0a) \u2502 \u251c\u2500\u2500 main.rs(\u5185\u6838\u4e3b\u51fd\u6570) \u2502 \u2514\u2500\u2500 sbi.rs(\u8c03\u7528\u5e95\u5c42 SBI \u5b9e\u73b0\u63d0\u4f9b\u7684 SBI \u63a5\u53e3) \u251c\u2500\u2500 README.md \u251c\u2500\u2500 rust-toolchain(\u63a7\u5236\u6574\u4e2a\u9879\u76ee\u7684\u5de5\u5177\u94fe\u7248\u672c) \u2514\u2500\u2500 tools(\u81ea\u52a8\u4e0b\u8f7d\u7684\u5c06\u5185\u6838\u70e7\u5199\u5230 k210 \u5f00\u53d1\u677f\u4e0a\u7684\u5de5\u5177) \u251c\u2500\u2500 kflash.py \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 package.json \u251c\u2500\u2500 README.rst \u2514\u2500\u2500 setup.py \u672c\u8282\u6587\u4ef6\u89e3\u6790 bootloader \u6587\u4ef6\u5939\u4e0b rustsbi-qemu.bin os \u6587\u4ef6\u5939\u4e0b ./cargo/config # \u914d\u7f6e\u6587\u4ef6\u6ca1\u6709\u6ce8\u91ca\uff0c \u9ed8\u8ba4 # \u540e\u9762\u63a5\u6ce8\u91ca [build] target = \"riscv64gc-unknown-none-elf\" # \u6307\u5b9a\u76ee\u6807\u5e73\u53f0\uff0c\u4e0d\u7136\u7f16\u8bd1\u65f6\u8981\u5e26\u4e0a\u53c2\u6570 # cargo run --target riscv64gc-unknown-none-elf [target.riscv64gc-unknown-none-elf] rustflags = [ \"-Clink-arg=-Tsrc/linker.ld\", \"-Cforce-frame-pointers=yes\" ] # \u7528\u4e8e\u6307\u5b9a\u94fe\u63a5\u6587\u4ef6\u7684\u5730\u5740 # -T\u540e\u9762\u63a5\u6587\u4ef6\u8def\u5f84 # -Cforce-frame-pointers=yes \u4f30\u8ba1\u662fllvm\u4e2d\u5bf9\u6307\u9488\u7684\u4f18\u5316\u6216\u5176\u4ed6\u5e95\u5c42\u64cd\u4f5c os/Cargo.toml [package] name = \"os\" version = \"0.1.0\" edition = \"2021\" # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html [dependencies] # \u6b64\u65f6\u8fd8\u4e0d\u9700\u8981\u914d\u7f6e\u4ec0\u4e48 os/src \u6587\u4ef6\u5939\u4e0b os/src/entry.asm .section .text.entry .global _start _start: la sp, boot_stack_top call rust_main # \u8bbe\u7f6e\u6808\u9876\u4f4d\u7f6e\u540e\u5c06 \u63a7\u5236\u6743\u8f6c\u4ea4\u5230 Rust\u5165\u53e3 .section .bss.stack # \u5173\u4e8e .bss.stack #\u524d\u9762\u6211\u4eec\u63d0\u5230\u8fc7 .bss \u6bb5\u4e00\u822c\u653e\u7f6e\u9700\u8981\u88ab\u521d\u59cb\u5316\u4e3a\u96f6\u7684\u6570\u636e\u3002 #\u7136\u800c\u6808\u5e76\u4e0d\u9700\u8981\u5728\u4f7f\u7528\u524d\u88ab\u521d\u59cb\u5316\u4e3a\u96f6\uff0c\u56e0\u4e3a\u5728\u51fd\u6570\u8c03\u7528\u7684\u65f6\u5019\u6211\u4eec\u4f1a\u63d2\u5165\u6808\u5e27\u8986\u76d6\u5df2\u6709\u7684\u6570\u636e\u3002 #\u6211\u4eec\u5c1d\u8bd5\u5c06\u5176\u653e\u7f6e\u5230\u5168\u5c40\u6570\u636e .data \u6bb5\u4e2d\u4f46\u6700\u540e\u672a\u80fd\u6210\u529f\uff0c\u56e0\u6b64\u624d\u51b3\u5b9a\u5c06\u5176\u653e\u7f6e\u5230 .bss \u6bb5\u4e2d\u3002 #\u5168\u5c40\u7b26\u53f7 sbss \u548c ebss \u5206\u522b\u6307\u5411 .bss \u6bb5\u9664 .bss.stack \u4ee5\u5916\u7684\u8d77\u59cb\u548c\u7ec8\u6b62\u5730\u5740\uff0c #\u6211\u4eec\u5728\u4f7f\u7528\u8fd9\u90e8\u5206\u6570\u636e\u4e4b\u524d\u9700\u8981\u5c06\u5b83\u4eec\u521d\u59cb\u5316\u4e3a\u96f6 .global boot_stack boot_stack: .space 4096 * 16 #\u9884\u7559\u4e86\u4e00\u5757\u5927\u5c0f\u4e3a 4096 * 16 \u5b57\u8282\u4e5f\u5c31\u662f64KB\u7684\u7a7a\u95f4\u7528\u4f5c\u63a5\u4e0b\u6765\u8981\u8fd0\u884c\u7684\u7a0b\u5e8f\u7684\u6808\u7a7a\u95f4 .global boot_stack_top boot_stack_top: ## \u6ce8\u610f\uff1a # \u6211\u4eec\u57fa\u672c\u4e0a\u8bf4\u660e\u4e86\u51fd\u6570\u8c03\u7528\u662f\u5982\u4f55\u57fa\u4e8e\u6808\u6765\u5b9e\u73b0\u7684\u3002 #\u4e0d\u8fc7\u6211\u4eec\u53ef\u4ee5\u6682\u65f6\u5148\u5ffd\u7565\u6389\u8fd9\u4e9b\u7ec6\u8282\uff0c\u56e0\u4e3a\u6211\u4eec\u73b0\u5728\u53ea\u662f\u9700\u8981\u5728\u521d\u59cb\u5316\u9636\u6bb5\u5b8c\u6210\u6808\u7684\u8bbe\u7f6e\uff0c #\u4e5f\u5c31\u662f\u8bbe\u7f6e\u597d\u6808\u6307\u9488 sp \u5bc4\u5b58\u5668\uff0c\u7f16\u8bd1\u5668\u4f1a\u5e2e\u6211\u4eec\u81ea\u52a8\u5b8c\u6210\u540e\u9762\u7684\u51fd\u6570\u8c03\u7528\u76f8\u5173\u673a\u5236\u7684\u4ee3\u7801\u751f\u6210\u3002 #\u9ebb\u70e6\u7684\u662f\uff0c sp \u7684\u503c\u4e5f\u4e0d\u80fd\u968f\u4fbf\u8bbe\u7f6e\uff0c\u81f3\u5c11\u6211\u4eec\u9700\u8981\u4fdd\u8bc1\u5b83\u6307\u5411\u5408\u6cd5\u7684\u7269\u7406\u5185\u5b58\uff0c #\u800c\u4e14\u4e0d\u80fd\u4e0e\u7a0b\u5e8f\u7684\u5176\u4ed6\u4ee3\u7801\u3001\u6570\u636e\u6bb5\u76f8\u4ea4\uff0c\u56e0\u4e3a\u5728\u51fd\u6570\u8c03\u7528\u7684\u8fc7\u7a0b\u4e2d\uff0c\u6808\u533a\u57df\u91cc\u9762\u7684\u5185\u5bb9\u4f1a\u88ab\u4fee\u6539 # \u8fd9\u6bb5\u8bdd\u8bb2\u4e86\u4e3a\u4ec0\u4e48\u8981\u5148\u8bbe\u7f6e\u597dsp\u5bc4\u5b58\u5668 # \u540c\u65f6\u6ce8\u610f\uff0c\u8fd9\u662friscv\u6c47\u7f16\u7684\u51fd\u6570\u8c03\u7528\u8fc7\u7a0b\uff0c\u5173\u4e8e\u51fd\u6570\u8c03\u7528\u7ea6\u5b9a\u662f\u5b58\u5728\u7684 # \u5373\u4ec0\u4e48\u5bc4\u5b58\u5668\u8be5\u4fdd\u7559\u5728\u6808\u4e2d\uff0c\u51fd\u6570\u8c03\u7528\u7684\u6808\u5e27 \u5c31\u5728\u8fd9\u4e2a\u6808\u4e2d # \u53ea\u4e0d\u8fc7rust\u7f16\u8bd1\u5668\u77e5\u9053\u4e86\u76ee\u524d\u5e73\u53f0\u662f riscv\uff0criscv\u7684\u51fd\u6570\u8c03\u7528\u89c4\u8303\u5b83\u77e5\u9053 # \u5b83\u4f1a\u5728\u5185\u90e8\u5bf9\u5bc4\u5b58\u5668\u7684\u4f7f\u7528\u505a\u51fa\u8c03\u6574\uff0c \u7f16\u8bd1\u5668\u81ea\u52a8\u751f\u6210\u51fd\u6570\u8c03\u7528\u673a\u5236\u76f8\u5173\u7684\u4ee3\u7801 # \u7b80\u5316\u4e86\u6211\u4eec\u5f00\u53d1\u7684\u6d41\u7a0b os/src/linker.ld # \u94fe\u63a5\u811a\u672c OUTPUT_ARCH(riscv) # \u6307\u5b9a\u76ee\u6807\u6587\u4ef6\u6240\u5728\u7684\u5e73\u53f0 ENTRY(_start) # \u6307\u5b9a\u5165\u53e3\u5730\u5740 # \u5728\u7a0b\u5e8f\u4e2d\u6267\u884c\u7684\u7b2c\u4e00\u6761\u6307\u4ee4\u79f0\u4e3a\u5165\u53e3\u70b9\u3002 \u60a8\u53ef\u4ee5\u4f7f\u7528 ENTRY \u94fe\u63a5\u5668\u811a\u672c\u547d\u4ee4\u6765\u8bbe\u7f6e\u5165\u53e3\u70b9\u3002 \u53c2\u6570\u662f\u7b26\u53f7\u540d\u79f0 BASE_ADDRESS = 0x80200000; # \u7c7b\u4f3c\u4e00\u4e2a\u5168\u5c40\u53d8\u91cf # \u6307\u4ee4\u5185\u6838\u4ece 0x80200000 \u5904\u5f00\u59cb\u5b58\u653e SECTIONS { . = BASE_ADDRESS; skernel = .; stext = .; .text : { *(.text.entry) *(.text .text.*) } # \u5185\u6838\u4ece 0x80200000 \u5f00\u59cb\uff0c # \u6700\u5f00\u65f6\u5b58\u653e\u7684\u662f \u4ee3\u7801\u6bb5\uff0c # \u800c\u4e14\u662f\u6307\u5b9a\u7684 .text.entry \u6bb5 # \u5373 entry.asm \u7684 \u7b2c\u4e00\u4e2a\u4ee3\u7801\u6bb5 # \u5176\u4ed6\u7684\u4ee3\u7801\u6bb5\u4e5f\u5b58\u653e\u5728\u6b64\u5904 . = ALIGN(4K); etext = .; srodata = .; .rodata : { *(.rodata .rodata.*) *(.srodata .srodata.*) } # \u6b64\u5904\u5b58\u653e\u6240\u6709\u7684 rodata \u6bb5 . = ALIGN(4K); erodata = .; sdata = .; .data : { *(.data .data.*) *(.sdata .sdata.*) } # \u6b64\u5904\u5b58\u653e\u6240\u6709 data \u6bb5 . = ALIGN(4K); edata = .; .bss : { *(.bss.stack) sbss = .; *(.bss .bss.*) *(.sbss .sbss.*) } # \u6b64\u5904\u5b58\u653e\u6240\u6709 bss \u6bb5 # \u6ce8\u610f\uff0c\u6709\u4e2a \u7279\u6b8a\u7684\u6808\u6bb5\u4e5f\u5b58\u653e\u5728\u6b64\u5904 # \u5373 .bss.stack \u6bb5 . = ALIGN(4K); ebss = .; ekernel = .; /DISCARD/ : { *(.eh_frame) } } os/src/sbi.rs #![allow(unused)] //\u5e76\u975e\u6240\u6709\u7684\u7cfb\u7edf\u8c03\u7528\u90fd\u4f1a\u88ab\u7528\u5230\uff0c\u6240\u4ee5allow(unused) const SBI_SET_TIMER:usize = 0; const SBI_CONSOLE_PUTCHAR:usize = 1; const SBI_CONSOLE_GETCHAR:usize = 2; const SBI_CLEAR_IPI:usize = 3; const SBI_SEND_IPI:usize = 4; const SBI_REMOTE_FENCE_I:usize = 5; const SBI_REMOTE_SFENCE_VMA:usize = 6; const SBI_REMOTE_SFENCE_VMA_ASID:usize = 7; const SBI_SHUTDOWN:usize = 8; // rust-sbi\u63d0\u4f9b\u4e86\u7cfb\u7edf\u8c03\u7528\uff0c /* const LEGACY_SET_TIMER: usize = 0x0; const LEGACY_CONSOLE_PUTCHAR: usize = 0x01; const LEGACY_CONSOLE_GETCHAR: usize = 0x02; // const LEGACY_CLEAR_IPI: usize = 0x03; const LEGACY_SEND_IPI: usize = 0x04; // const LEGACY_REMOTE_FENCE_I: usize = 0x05; // const LEGACY_REMOTE_SFENCE_VMA: usize = 0x06; // const LEGACY_REMOTE_SFENCE_VMA_ASID: usize = 0x07; const LEGACY_SHUTDOWN: usize = 0x08; \u8fd9\u662f rustsbi\u4e2d src/ecall.rs \u7684\u6e90\u7801 */ // \u8fd9\u91cc\u5b9a\u4e49\u7684 8 \u4e2a\u7cfb\u7edf\u8c03\u7528 \u548c rustsbi\u63d0\u4f9b\u7684\u662f\u4e00\u81f4 // \u672c\u8d28\u5c31\u662f\u901a\u8fc7 riscv\u6c47\u7f16 \u7684ecall\u6307\u4ee4\u8c03\u7528 rustsbi\u63d0\u4f9b\u7684\u7cfb\u7edf\u8c03\u7528 use core::arch::asm; #[inline(always)] fn sbi_call(which:usize, arg0:usize, arg1:usize, arg2: usize) -> usize{ let mut ret; unsafe{ asm!( \"ecall\", inlateout(\"x10\") arg0 => ret, in(\"x11\") arg1, in(\"x12\") arg2, in(\"x17\") which, ); } ret } //\u8fd9\u91cc\u672c\u8d28\u5c31\u662f\u5bf9rustsbi\u63d0\u4f9b\u7684\u7cfb\u7edf\u8c03\u7528\u7684\u4e00\u5c42\u5c01\u88c5 pub fn console_putchar(c:usize){ sbi_call(SBI_CONSOLE_PUTCHAR, c, 0, 0); } pub fn shutdown() -> ! { sbi_call(SBI_SHUTDOWN, 0, 0, 0); panic!(\"It should shutdown!\"); } //\u8fdb\u4e00\u6b65\u8fdb\u884c\u5c01\u88c5\uff0c\u7b80\u5316\u8c03\u7528\u7684\u5f62\u5f0f\uff0c\u53ea\u9700\u8981\u5fc5\u8981\u7684\u53c2\u6570 //\u540c\u65f6\u4e5f\u53ef\u4ee5\u6dfb\u52a0\u4e00\u4e9b\u989d\u5916\u7684\u4fe1\u606f os/src/console.rs use crate::sbi::console_putchar; use core::fmt::{self, Write}; struct Stdout; //\u7ed3\u6784\u4f53 Stdout \u4e0d\u5305\u542b\u4efb\u4f55\u5b57\u6bb5\uff0c\u56e0\u6b64\u5b83\u88ab\u79f0\u4e3a\u7c7b\u5355\u5143\u7ed3\u6784\u4f53 impl Write for Stdout{ // core::fmt::Write trait \u5305\u542b\u4e00\u4e2a\u7528\u6765\u5b9e\u73b0 println! \u5b8f\u5f88\u597d\u7528\u7684 write_fmt \u65b9\u6cd5\uff0c //\u4e3a\u6b64\u6211\u4eec\u51c6\u5907\u4e3a\u7ed3\u6784\u4f53 Stdout \u5b9e\u73b0 Write trait \u3002 fn write_str(&mut self, s:&str) -> fmt::Result{ //\u5728 Write trait \u4e2d\uff0c write_str \u65b9\u6cd5\u5fc5\u987b\u5b9e\u73b0\uff0c\u56e0\u6b64\u6211\u4eec\u9700\u8981\u4e3a Stdout \u5b9e\u73b0\u8fd9\u4e00\u65b9\u6cd5\uff0c //\u5b83\u5e76\u4e0d\u96be\u5b9e\u73b0\uff0c\u53ea\u9700\u904d\u5386\u4f20\u5165\u7684 &str \u4e2d\u7684\u6bcf\u4e2a\u5b57\u7b26\u5e76\u8c03\u7528 console_putchar \u5c31\u80fd\u5c06\u4f20\u5165\u7684\u6574\u4e2a\u5b57\u7b26\u4e32\u6253\u5370\u5230\u5c4f\u5e55\u4e0a\u3002 for c in s.chars(){ console_putchar(c as usize); } Ok(()) } } //\u5728\u6b64\u4e4b\u540e Stdout \u4fbf\u53ef\u8c03\u7528 Write trait \u63d0\u4f9b\u7684 write_fmt \u65b9\u6cd5\u5e76\u8fdb\u800c\u5b9e\u73b0 print \u51fd\u6570\u3002 pub fn print(args: fmt::Arguments){ Stdout.write_fmt(args).unwrap(); } //https://doc.rust-lang.org/core/fmt/trait.Write.html#method.write_fmt //\u5728\u58f0\u660e\u5b8f\uff08Declarative macros\uff09 print! \u548c println! \u4e2d\u4f1a\u8c03\u7528 print \u51fd\u6570\u5b8c\u6210\u8f93\u51fa\u3002 #[macro_export] macro_rules! print{ ($fmt: literal $(, $($arg: tt)+)?) => { $crate::console::print(format_args!($fmt $(, $($arg)+)?)); } } #[macro_export] macro_rules! println{ ($fmt: literal $(, $($arg: tt)+)?) => { $crate::console::print(format_args!(concat!($fmt, \"\\n\") $(, $($arg)+)?)); } } trait\u7684\u5b9e\u73b0\u4ee5\u53ca\u5b8f\u7684\u58f0\u660e\u7b49\u540e\u7eed\u5b66\u5b8crust\u540e\u518d\u56de\u8fc7\u5934\u6765\u770b ------------------------------------------------------------------------- == ------------------------------------------------------------------------------- os/src/lang_items.rs use core::panic::PanicInfo; use crate::sbi::shutdown; #[panic_handler] fn panic(info: &PanicInfo) -> ! { if let Some(location) = info.location() { println!( \"Panicked at {}:{} {}\", location.file(), location.line(), info.message().unwrap() ); } else { println!(\"Panicked: {}\", info.message().unwrap()); } //\u6211\u4eec\u9700\u8981\u5728 main.rs \u5f00\u5934\u52a0\u4e0a #![feature(panic_info_message)] //\u624d\u80fd\u901a\u8fc7 PanicInfo::message \u83b7\u53d6\u62a5\u9519\u4fe1\u606f shutdown() } os/src/main.rs #![no_std] #![no_main] #![feature(panic_info_message)] #[macro_use] mod console; mod lang_items; mod sbi; use core::arch::global_asm; global_asm!(include_str!(\"entry.asm\")); fn clear_bss(){ extern \"C\" { fn sbss(); fn ebss(); //extern \u201cC\u201d \u53ef\u4ee5\u5f15\u7528\u4e00\u4e2a\u5916\u90e8\u7684 C \u51fd\u6570\u63a5\u53e3\uff08\u8fd9\u610f\u5473\u7740\u8c03\u7528\u5b83\u7684\u65f6\u5019\u8981\u9075\u4ece\u76ee\u6807\u5e73\u53f0\u7684 C \u8bed\u8a00\u8c03\u7528\u89c4\u8303\uff09\u3002 //\u4f46\u6211\u4eec\u8fd9\u91cc\u53ea\u662f\u5f15\u7528\u4f4d\u7f6e\u6807\u5fd7\u5e76\u5c06\u5176\u8f6c\u6210 usize \u83b7\u53d6\u5b83\u7684\u5730\u5740\u3002\u7531\u6b64\u53ef\u4ee5\u77e5\u9053 .bss \u6bb5\u4e24\u7aef\u7684\u5730\u5740 } // \u901a\u8fc7\u8fd9\u79cd\u65b9\u6cd5\uff0c\u6211\u4eec\u53ef\u4ee5\u83b7\u53d6 linker.ld \u6587\u4ef6\u4e2d\u6bb5\u7684\u5730\u5740 (sbss as usize..ebss as usize).for_each(|a| { unsafe { (a as *mut u8).write_volatile(0)} }); // Rust \u7684\u8fed\u4ee3\u5668\u548c\u95ed\u5305\uff0c\u540e\u7eed\u518d\u4e86\u89e3 } #[no_mangle] pub fn rust_main() -> ! { clear_bss(); println!(\"Hello, world\"); panic!(\"Shutdown machine!\"); } \u5173\u4e8ePanicInfo\u7684\u4f7f\u7528\u8fd8\u6709\u5f85\u4e86\u89e3 \u4e3a\u4ec0\u4e48panic!(\"Shutdown machine!\") \u53ef\u4ee5\u6253\u5370\u51fa\u6765\uff0c\u4f46shut down() \u7684panic!(\"It should shutdown!\")\u6ca1\u6709\u88ab\u6253\u5370\u4e86 \u65e2\u7136\u5df2\u7ecf\u8981\u5173\u673a\u4e86\uff0c\u4e3a\u4ec0\u4e48\u8fd8\u8981\u5199\u53e5\u8bdd\uff1apanic!(\"It should shutdown!\") \u6267\u884c\u6d41\u7a0b \u8fdb\u5165entr.asm\uff0c\u8bbe\u7f6e\u51fd\u6570\u6808\uff0c\u8df3\u8f6c\u5230 rust_main \u6e05\u96f6\u9664.bss.stack\u4ee5\u5916\u7684.bss\u6bb5 \u8c03\u7528println! -> print -> Stdout.write_fmt \u8c03\u7528 painc! -> println! -> shutdown -> sbi_call(SBI_SHUTDOWN, 0, 0, 0)","title":"\u8f93\u51fahello_world"},{"location":"ch1%E8%BE%93%E5%87%BAhello_world/#hello-world","text":"","title":"\u8f93\u51fahello world"},{"location":"ch1%E8%BE%93%E5%87%BAhello_world/#_1","text":"","title":"\u5185\u6838\u7b2c\u4e00\u6761\u6307\u4ee4"},{"location":"ch1%E8%BE%93%E5%87%BAhello_world/#_2","text":"./os/src Rust 4 Files 119 Lines Assembly 1 Files 11 Lines \u251c\u2500\u2500 bootloader(\u5185\u6838\u4f9d\u8d56\u7684\u8fd0\u884c\u5728 M \u7279\u6743\u7ea7\u7684 SBI \u5b9e\u73b0\uff0c\u672c\u9879\u76ee\u4e2d\u6211\u4eec\u4f7f\u7528 RustSBI) \u2502 \u251c\u2500\u2500 rustsbi-k210.bin(\u53ef\u8fd0\u884c\u5728 k210 \u771f\u5b9e\u786c\u4ef6\u5e73\u53f0\u4e0a\u7684\u9884\u7f16\u8bd1\u4e8c\u8fdb\u5236\u7248\u672c) \u2502 \u2514\u2500\u2500 rustsbi-qemu.bin(\u53ef\u8fd0\u884c\u5728 qemu \u865a\u62df\u673a\u4e0a\u7684\u9884\u7f16\u8bd1\u4e8c\u8fdb\u5236\u7248\u672c) \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 os(\u6211\u4eec\u7684\u5185\u6838\u5b9e\u73b0\u653e\u5728 os \u76ee\u5f55\u4e0b) \u2502 \u251c\u2500\u2500 Cargo.toml(\u5185\u6838\u5b9e\u73b0\u7684\u4e00\u4e9b\u914d\u7f6e\u6587\u4ef6) \u2502 \u251c\u2500\u2500 Makefile \u2502 \u2514\u2500\u2500 src(\u6240\u6709\u5185\u6838\u7684\u6e90\u4ee3\u7801\u653e\u5728 os/src \u76ee\u5f55\u4e0b) \u2502 \u251c\u2500\u2500 console.rs(\u5c06\u6253\u5370\u5b57\u7b26\u7684 SBI \u63a5\u53e3\u8fdb\u4e00\u6b65\u5c01\u88c5\u5b9e\u73b0\u66f4\u52a0\u5f3a\u5927\u7684\u683c\u5f0f\u5316\u8f93\u51fa) \u2502 \u251c\u2500\u2500 entry.asm(\u8bbe\u7f6e\u5185\u6838\u6267\u884c\u73af\u5883\u7684\u7684\u4e00\u6bb5\u6c47\u7f16\u4ee3\u7801) \u2502 \u251c\u2500\u2500 lang_items.rs(\u9700\u8981\u6211\u4eec\u63d0\u4f9b\u7ed9 Rust \u7f16\u8bd1\u5668\u7684\u4e00\u4e9b\u8bed\u4e49\u9879\uff0c\u76ee\u524d\u5305\u542b\u5185\u6838 panic \u65f6\u7684\u5904\u7406\u903b\u8f91) \u2502 \u251c\u2500\u2500 linker-k210.ld(\u63a7\u5236\u5185\u6838\u5185\u5b58\u5e03\u5c40\u7684\u94fe\u63a5\u811a\u672c\u4ee5\u4f7f\u5185\u6838\u8fd0\u884c\u5728 k210 \u771f\u5b9e\u786c\u4ef6\u5e73\u53f0\u4e0a) \u2502 \u251c\u2500\u2500 linker-qemu.ld(\u63a7\u5236\u5185\u6838\u5185\u5b58\u5e03\u5c40\u7684\u94fe\u63a5\u811a\u672c\u4ee5\u4f7f\u5185\u6838\u8fd0\u884c\u5728 qemu \u865a\u62df\u673a\u4e0a) \u2502 \u251c\u2500\u2500 main.rs(\u5185\u6838\u4e3b\u51fd\u6570) \u2502 \u2514\u2500\u2500 sbi.rs(\u8c03\u7528\u5e95\u5c42 SBI \u5b9e\u73b0\u63d0\u4f9b\u7684 SBI \u63a5\u53e3) \u251c\u2500\u2500 README.md \u251c\u2500\u2500 rust-toolchain(\u63a7\u5236\u6574\u4e2a\u9879\u76ee\u7684\u5de5\u5177\u94fe\u7248\u672c) \u2514\u2500\u2500 tools(\u81ea\u52a8\u4e0b\u8f7d\u7684\u5c06\u5185\u6838\u70e7\u5199\u5230 k210 \u5f00\u53d1\u677f\u4e0a\u7684\u5de5\u5177) \u251c\u2500\u2500 kflash.py \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 package.json \u251c\u2500\u2500 README.rst \u2514\u2500\u2500 setup.py","title":"\u7b2c\u4e00\u7ae0\u4ee3\u7801\u6811"},{"location":"ch1%E8%BE%93%E5%87%BAhello_world/#_3","text":"","title":"\u672c\u8282\u6587\u4ef6\u89e3\u6790"},{"location":"ch1%E8%BE%93%E5%87%BAhello_world/#bootloader","text":"rustsbi-qemu.bin","title":"bootloader \u6587\u4ef6\u5939\u4e0b"},{"location":"ch1%E8%BE%93%E5%87%BAhello_world/#os","text":"","title":"os \u6587\u4ef6\u5939\u4e0b"},{"location":"ch1%E8%BE%93%E5%87%BAhello_world/#cargoconfig","text":"# \u914d\u7f6e\u6587\u4ef6\u6ca1\u6709\u6ce8\u91ca\uff0c \u9ed8\u8ba4 # \u540e\u9762\u63a5\u6ce8\u91ca [build] target = \"riscv64gc-unknown-none-elf\" # \u6307\u5b9a\u76ee\u6807\u5e73\u53f0\uff0c\u4e0d\u7136\u7f16\u8bd1\u65f6\u8981\u5e26\u4e0a\u53c2\u6570 # cargo run --target riscv64gc-unknown-none-elf [target.riscv64gc-unknown-none-elf] rustflags = [ \"-Clink-arg=-Tsrc/linker.ld\", \"-Cforce-frame-pointers=yes\" ] # \u7528\u4e8e\u6307\u5b9a\u94fe\u63a5\u6587\u4ef6\u7684\u5730\u5740 # -T\u540e\u9762\u63a5\u6587\u4ef6\u8def\u5f84 # -Cforce-frame-pointers=yes \u4f30\u8ba1\u662fllvm\u4e2d\u5bf9\u6307\u9488\u7684\u4f18\u5316\u6216\u5176\u4ed6\u5e95\u5c42\u64cd\u4f5c","title":"./cargo/config"},{"location":"ch1%E8%BE%93%E5%87%BAhello_world/#oscargotoml","text":"[package] name = \"os\" version = \"0.1.0\" edition = \"2021\" # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html [dependencies] # \u6b64\u65f6\u8fd8\u4e0d\u9700\u8981\u914d\u7f6e\u4ec0\u4e48","title":"os/Cargo.toml"},{"location":"ch1%E8%BE%93%E5%87%BAhello_world/#ossrc","text":"","title":"os/src \u6587\u4ef6\u5939\u4e0b"},{"location":"ch1%E8%BE%93%E5%87%BAhello_world/#ossrcentryasm","text":".section .text.entry .global _start _start: la sp, boot_stack_top call rust_main # \u8bbe\u7f6e\u6808\u9876\u4f4d\u7f6e\u540e\u5c06 \u63a7\u5236\u6743\u8f6c\u4ea4\u5230 Rust\u5165\u53e3 .section .bss.stack # \u5173\u4e8e .bss.stack #\u524d\u9762\u6211\u4eec\u63d0\u5230\u8fc7 .bss \u6bb5\u4e00\u822c\u653e\u7f6e\u9700\u8981\u88ab\u521d\u59cb\u5316\u4e3a\u96f6\u7684\u6570\u636e\u3002 #\u7136\u800c\u6808\u5e76\u4e0d\u9700\u8981\u5728\u4f7f\u7528\u524d\u88ab\u521d\u59cb\u5316\u4e3a\u96f6\uff0c\u56e0\u4e3a\u5728\u51fd\u6570\u8c03\u7528\u7684\u65f6\u5019\u6211\u4eec\u4f1a\u63d2\u5165\u6808\u5e27\u8986\u76d6\u5df2\u6709\u7684\u6570\u636e\u3002 #\u6211\u4eec\u5c1d\u8bd5\u5c06\u5176\u653e\u7f6e\u5230\u5168\u5c40\u6570\u636e .data \u6bb5\u4e2d\u4f46\u6700\u540e\u672a\u80fd\u6210\u529f\uff0c\u56e0\u6b64\u624d\u51b3\u5b9a\u5c06\u5176\u653e\u7f6e\u5230 .bss \u6bb5\u4e2d\u3002 #\u5168\u5c40\u7b26\u53f7 sbss \u548c ebss \u5206\u522b\u6307\u5411 .bss \u6bb5\u9664 .bss.stack \u4ee5\u5916\u7684\u8d77\u59cb\u548c\u7ec8\u6b62\u5730\u5740\uff0c #\u6211\u4eec\u5728\u4f7f\u7528\u8fd9\u90e8\u5206\u6570\u636e\u4e4b\u524d\u9700\u8981\u5c06\u5b83\u4eec\u521d\u59cb\u5316\u4e3a\u96f6 .global boot_stack boot_stack: .space 4096 * 16 #\u9884\u7559\u4e86\u4e00\u5757\u5927\u5c0f\u4e3a 4096 * 16 \u5b57\u8282\u4e5f\u5c31\u662f64KB\u7684\u7a7a\u95f4\u7528\u4f5c\u63a5\u4e0b\u6765\u8981\u8fd0\u884c\u7684\u7a0b\u5e8f\u7684\u6808\u7a7a\u95f4 .global boot_stack_top boot_stack_top: ## \u6ce8\u610f\uff1a # \u6211\u4eec\u57fa\u672c\u4e0a\u8bf4\u660e\u4e86\u51fd\u6570\u8c03\u7528\u662f\u5982\u4f55\u57fa\u4e8e\u6808\u6765\u5b9e\u73b0\u7684\u3002 #\u4e0d\u8fc7\u6211\u4eec\u53ef\u4ee5\u6682\u65f6\u5148\u5ffd\u7565\u6389\u8fd9\u4e9b\u7ec6\u8282\uff0c\u56e0\u4e3a\u6211\u4eec\u73b0\u5728\u53ea\u662f\u9700\u8981\u5728\u521d\u59cb\u5316\u9636\u6bb5\u5b8c\u6210\u6808\u7684\u8bbe\u7f6e\uff0c #\u4e5f\u5c31\u662f\u8bbe\u7f6e\u597d\u6808\u6307\u9488 sp \u5bc4\u5b58\u5668\uff0c\u7f16\u8bd1\u5668\u4f1a\u5e2e\u6211\u4eec\u81ea\u52a8\u5b8c\u6210\u540e\u9762\u7684\u51fd\u6570\u8c03\u7528\u76f8\u5173\u673a\u5236\u7684\u4ee3\u7801\u751f\u6210\u3002 #\u9ebb\u70e6\u7684\u662f\uff0c sp \u7684\u503c\u4e5f\u4e0d\u80fd\u968f\u4fbf\u8bbe\u7f6e\uff0c\u81f3\u5c11\u6211\u4eec\u9700\u8981\u4fdd\u8bc1\u5b83\u6307\u5411\u5408\u6cd5\u7684\u7269\u7406\u5185\u5b58\uff0c #\u800c\u4e14\u4e0d\u80fd\u4e0e\u7a0b\u5e8f\u7684\u5176\u4ed6\u4ee3\u7801\u3001\u6570\u636e\u6bb5\u76f8\u4ea4\uff0c\u56e0\u4e3a\u5728\u51fd\u6570\u8c03\u7528\u7684\u8fc7\u7a0b\u4e2d\uff0c\u6808\u533a\u57df\u91cc\u9762\u7684\u5185\u5bb9\u4f1a\u88ab\u4fee\u6539 # \u8fd9\u6bb5\u8bdd\u8bb2\u4e86\u4e3a\u4ec0\u4e48\u8981\u5148\u8bbe\u7f6e\u597dsp\u5bc4\u5b58\u5668 # \u540c\u65f6\u6ce8\u610f\uff0c\u8fd9\u662friscv\u6c47\u7f16\u7684\u51fd\u6570\u8c03\u7528\u8fc7\u7a0b\uff0c\u5173\u4e8e\u51fd\u6570\u8c03\u7528\u7ea6\u5b9a\u662f\u5b58\u5728\u7684 # \u5373\u4ec0\u4e48\u5bc4\u5b58\u5668\u8be5\u4fdd\u7559\u5728\u6808\u4e2d\uff0c\u51fd\u6570\u8c03\u7528\u7684\u6808\u5e27 \u5c31\u5728\u8fd9\u4e2a\u6808\u4e2d # \u53ea\u4e0d\u8fc7rust\u7f16\u8bd1\u5668\u77e5\u9053\u4e86\u76ee\u524d\u5e73\u53f0\u662f riscv\uff0criscv\u7684\u51fd\u6570\u8c03\u7528\u89c4\u8303\u5b83\u77e5\u9053 # \u5b83\u4f1a\u5728\u5185\u90e8\u5bf9\u5bc4\u5b58\u5668\u7684\u4f7f\u7528\u505a\u51fa\u8c03\u6574\uff0c \u7f16\u8bd1\u5668\u81ea\u52a8\u751f\u6210\u51fd\u6570\u8c03\u7528\u673a\u5236\u76f8\u5173\u7684\u4ee3\u7801 # \u7b80\u5316\u4e86\u6211\u4eec\u5f00\u53d1\u7684\u6d41\u7a0b","title":"os/src/entry.asm"},{"location":"ch1%E8%BE%93%E5%87%BAhello_world/#ossrclinkerld","text":"# \u94fe\u63a5\u811a\u672c OUTPUT_ARCH(riscv) # \u6307\u5b9a\u76ee\u6807\u6587\u4ef6\u6240\u5728\u7684\u5e73\u53f0 ENTRY(_start) # \u6307\u5b9a\u5165\u53e3\u5730\u5740 # \u5728\u7a0b\u5e8f\u4e2d\u6267\u884c\u7684\u7b2c\u4e00\u6761\u6307\u4ee4\u79f0\u4e3a\u5165\u53e3\u70b9\u3002 \u60a8\u53ef\u4ee5\u4f7f\u7528 ENTRY \u94fe\u63a5\u5668\u811a\u672c\u547d\u4ee4\u6765\u8bbe\u7f6e\u5165\u53e3\u70b9\u3002 \u53c2\u6570\u662f\u7b26\u53f7\u540d\u79f0 BASE_ADDRESS = 0x80200000; # \u7c7b\u4f3c\u4e00\u4e2a\u5168\u5c40\u53d8\u91cf # \u6307\u4ee4\u5185\u6838\u4ece 0x80200000 \u5904\u5f00\u59cb\u5b58\u653e SECTIONS { . = BASE_ADDRESS; skernel = .; stext = .; .text : { *(.text.entry) *(.text .text.*) } # \u5185\u6838\u4ece 0x80200000 \u5f00\u59cb\uff0c # \u6700\u5f00\u65f6\u5b58\u653e\u7684\u662f \u4ee3\u7801\u6bb5\uff0c # \u800c\u4e14\u662f\u6307\u5b9a\u7684 .text.entry \u6bb5 # \u5373 entry.asm \u7684 \u7b2c\u4e00\u4e2a\u4ee3\u7801\u6bb5 # \u5176\u4ed6\u7684\u4ee3\u7801\u6bb5\u4e5f\u5b58\u653e\u5728\u6b64\u5904 . = ALIGN(4K); etext = .; srodata = .; .rodata : { *(.rodata .rodata.*) *(.srodata .srodata.*) } # \u6b64\u5904\u5b58\u653e\u6240\u6709\u7684 rodata \u6bb5 . = ALIGN(4K); erodata = .; sdata = .; .data : { *(.data .data.*) *(.sdata .sdata.*) } # \u6b64\u5904\u5b58\u653e\u6240\u6709 data \u6bb5 . = ALIGN(4K); edata = .; .bss : { *(.bss.stack) sbss = .; *(.bss .bss.*) *(.sbss .sbss.*) } # \u6b64\u5904\u5b58\u653e\u6240\u6709 bss \u6bb5 # \u6ce8\u610f\uff0c\u6709\u4e2a \u7279\u6b8a\u7684\u6808\u6bb5\u4e5f\u5b58\u653e\u5728\u6b64\u5904 # \u5373 .bss.stack \u6bb5 . = ALIGN(4K); ebss = .; ekernel = .; /DISCARD/ : { *(.eh_frame) } }","title":"os/src/linker.ld"},{"location":"ch1%E8%BE%93%E5%87%BAhello_world/#ossrcsbirs","text":"#![allow(unused)] //\u5e76\u975e\u6240\u6709\u7684\u7cfb\u7edf\u8c03\u7528\u90fd\u4f1a\u88ab\u7528\u5230\uff0c\u6240\u4ee5allow(unused) const SBI_SET_TIMER:usize = 0; const SBI_CONSOLE_PUTCHAR:usize = 1; const SBI_CONSOLE_GETCHAR:usize = 2; const SBI_CLEAR_IPI:usize = 3; const SBI_SEND_IPI:usize = 4; const SBI_REMOTE_FENCE_I:usize = 5; const SBI_REMOTE_SFENCE_VMA:usize = 6; const SBI_REMOTE_SFENCE_VMA_ASID:usize = 7; const SBI_SHUTDOWN:usize = 8; // rust-sbi\u63d0\u4f9b\u4e86\u7cfb\u7edf\u8c03\u7528\uff0c /* const LEGACY_SET_TIMER: usize = 0x0; const LEGACY_CONSOLE_PUTCHAR: usize = 0x01; const LEGACY_CONSOLE_GETCHAR: usize = 0x02; // const LEGACY_CLEAR_IPI: usize = 0x03; const LEGACY_SEND_IPI: usize = 0x04; // const LEGACY_REMOTE_FENCE_I: usize = 0x05; // const LEGACY_REMOTE_SFENCE_VMA: usize = 0x06; // const LEGACY_REMOTE_SFENCE_VMA_ASID: usize = 0x07; const LEGACY_SHUTDOWN: usize = 0x08; \u8fd9\u662f rustsbi\u4e2d src/ecall.rs \u7684\u6e90\u7801 */ // \u8fd9\u91cc\u5b9a\u4e49\u7684 8 \u4e2a\u7cfb\u7edf\u8c03\u7528 \u548c rustsbi\u63d0\u4f9b\u7684\u662f\u4e00\u81f4 // \u672c\u8d28\u5c31\u662f\u901a\u8fc7 riscv\u6c47\u7f16 \u7684ecall\u6307\u4ee4\u8c03\u7528 rustsbi\u63d0\u4f9b\u7684\u7cfb\u7edf\u8c03\u7528 use core::arch::asm; #[inline(always)] fn sbi_call(which:usize, arg0:usize, arg1:usize, arg2: usize) -> usize{ let mut ret; unsafe{ asm!( \"ecall\", inlateout(\"x10\") arg0 => ret, in(\"x11\") arg1, in(\"x12\") arg2, in(\"x17\") which, ); } ret } //\u8fd9\u91cc\u672c\u8d28\u5c31\u662f\u5bf9rustsbi\u63d0\u4f9b\u7684\u7cfb\u7edf\u8c03\u7528\u7684\u4e00\u5c42\u5c01\u88c5 pub fn console_putchar(c:usize){ sbi_call(SBI_CONSOLE_PUTCHAR, c, 0, 0); } pub fn shutdown() -> ! { sbi_call(SBI_SHUTDOWN, 0, 0, 0); panic!(\"It should shutdown!\"); } //\u8fdb\u4e00\u6b65\u8fdb\u884c\u5c01\u88c5\uff0c\u7b80\u5316\u8c03\u7528\u7684\u5f62\u5f0f\uff0c\u53ea\u9700\u8981\u5fc5\u8981\u7684\u53c2\u6570 //\u540c\u65f6\u4e5f\u53ef\u4ee5\u6dfb\u52a0\u4e00\u4e9b\u989d\u5916\u7684\u4fe1\u606f","title":"os/src/sbi.rs"},{"location":"ch1%E8%BE%93%E5%87%BAhello_world/#ossrcconsolers","text":"use crate::sbi::console_putchar; use core::fmt::{self, Write}; struct Stdout; //\u7ed3\u6784\u4f53 Stdout \u4e0d\u5305\u542b\u4efb\u4f55\u5b57\u6bb5\uff0c\u56e0\u6b64\u5b83\u88ab\u79f0\u4e3a\u7c7b\u5355\u5143\u7ed3\u6784\u4f53 impl Write for Stdout{ // core::fmt::Write trait \u5305\u542b\u4e00\u4e2a\u7528\u6765\u5b9e\u73b0 println! \u5b8f\u5f88\u597d\u7528\u7684 write_fmt \u65b9\u6cd5\uff0c //\u4e3a\u6b64\u6211\u4eec\u51c6\u5907\u4e3a\u7ed3\u6784\u4f53 Stdout \u5b9e\u73b0 Write trait \u3002 fn write_str(&mut self, s:&str) -> fmt::Result{ //\u5728 Write trait \u4e2d\uff0c write_str \u65b9\u6cd5\u5fc5\u987b\u5b9e\u73b0\uff0c\u56e0\u6b64\u6211\u4eec\u9700\u8981\u4e3a Stdout \u5b9e\u73b0\u8fd9\u4e00\u65b9\u6cd5\uff0c //\u5b83\u5e76\u4e0d\u96be\u5b9e\u73b0\uff0c\u53ea\u9700\u904d\u5386\u4f20\u5165\u7684 &str \u4e2d\u7684\u6bcf\u4e2a\u5b57\u7b26\u5e76\u8c03\u7528 console_putchar \u5c31\u80fd\u5c06\u4f20\u5165\u7684\u6574\u4e2a\u5b57\u7b26\u4e32\u6253\u5370\u5230\u5c4f\u5e55\u4e0a\u3002 for c in s.chars(){ console_putchar(c as usize); } Ok(()) } } //\u5728\u6b64\u4e4b\u540e Stdout \u4fbf\u53ef\u8c03\u7528 Write trait \u63d0\u4f9b\u7684 write_fmt \u65b9\u6cd5\u5e76\u8fdb\u800c\u5b9e\u73b0 print \u51fd\u6570\u3002 pub fn print(args: fmt::Arguments){ Stdout.write_fmt(args).unwrap(); } //https://doc.rust-lang.org/core/fmt/trait.Write.html#method.write_fmt //\u5728\u58f0\u660e\u5b8f\uff08Declarative macros\uff09 print! \u548c println! \u4e2d\u4f1a\u8c03\u7528 print \u51fd\u6570\u5b8c\u6210\u8f93\u51fa\u3002 #[macro_export] macro_rules! print{ ($fmt: literal $(, $($arg: tt)+)?) => { $crate::console::print(format_args!($fmt $(, $($arg)+)?)); } } #[macro_export] macro_rules! println{ ($fmt: literal $(, $($arg: tt)+)?) => { $crate::console::print(format_args!(concat!($fmt, \"\\n\") $(, $($arg)+)?)); } } trait\u7684\u5b9e\u73b0\u4ee5\u53ca\u5b8f\u7684\u58f0\u660e\u7b49\u540e\u7eed\u5b66\u5b8crust\u540e\u518d\u56de\u8fc7\u5934\u6765\u770b ------------------------------------------------------------------------- == -------------------------------------------------------------------------------","title":"os/src/console.rs"},{"location":"ch1%E8%BE%93%E5%87%BAhello_world/#ossrclang_itemsrs","text":"use core::panic::PanicInfo; use crate::sbi::shutdown; #[panic_handler] fn panic(info: &PanicInfo) -> ! { if let Some(location) = info.location() { println!( \"Panicked at {}:{} {}\", location.file(), location.line(), info.message().unwrap() ); } else { println!(\"Panicked: {}\", info.message().unwrap()); } //\u6211\u4eec\u9700\u8981\u5728 main.rs \u5f00\u5934\u52a0\u4e0a #![feature(panic_info_message)] //\u624d\u80fd\u901a\u8fc7 PanicInfo::message \u83b7\u53d6\u62a5\u9519\u4fe1\u606f shutdown() }","title":"os/src/lang_items.rs"},{"location":"ch1%E8%BE%93%E5%87%BAhello_world/#ossrcmainrs","text":"#![no_std] #![no_main] #![feature(panic_info_message)] #[macro_use] mod console; mod lang_items; mod sbi; use core::arch::global_asm; global_asm!(include_str!(\"entry.asm\")); fn clear_bss(){ extern \"C\" { fn sbss(); fn ebss(); //extern \u201cC\u201d \u53ef\u4ee5\u5f15\u7528\u4e00\u4e2a\u5916\u90e8\u7684 C \u51fd\u6570\u63a5\u53e3\uff08\u8fd9\u610f\u5473\u7740\u8c03\u7528\u5b83\u7684\u65f6\u5019\u8981\u9075\u4ece\u76ee\u6807\u5e73\u53f0\u7684 C \u8bed\u8a00\u8c03\u7528\u89c4\u8303\uff09\u3002 //\u4f46\u6211\u4eec\u8fd9\u91cc\u53ea\u662f\u5f15\u7528\u4f4d\u7f6e\u6807\u5fd7\u5e76\u5c06\u5176\u8f6c\u6210 usize \u83b7\u53d6\u5b83\u7684\u5730\u5740\u3002\u7531\u6b64\u53ef\u4ee5\u77e5\u9053 .bss \u6bb5\u4e24\u7aef\u7684\u5730\u5740 } // \u901a\u8fc7\u8fd9\u79cd\u65b9\u6cd5\uff0c\u6211\u4eec\u53ef\u4ee5\u83b7\u53d6 linker.ld \u6587\u4ef6\u4e2d\u6bb5\u7684\u5730\u5740 (sbss as usize..ebss as usize).for_each(|a| { unsafe { (a as *mut u8).write_volatile(0)} }); // Rust \u7684\u8fed\u4ee3\u5668\u548c\u95ed\u5305\uff0c\u540e\u7eed\u518d\u4e86\u89e3 } #[no_mangle] pub fn rust_main() -> ! { clear_bss(); println!(\"Hello, world\"); panic!(\"Shutdown machine!\"); } \u5173\u4e8ePanicInfo\u7684\u4f7f\u7528\u8fd8\u6709\u5f85\u4e86\u89e3 \u4e3a\u4ec0\u4e48panic!(\"Shutdown machine!\") \u53ef\u4ee5\u6253\u5370\u51fa\u6765\uff0c\u4f46shut down() \u7684panic!(\"It should shutdown!\")\u6ca1\u6709\u88ab\u6253\u5370\u4e86 \u65e2\u7136\u5df2\u7ecf\u8981\u5173\u673a\u4e86\uff0c\u4e3a\u4ec0\u4e48\u8fd8\u8981\u5199\u53e5\u8bdd\uff1apanic!(\"It should shutdown!\")","title":"os/src/main.rs"},{"location":"ch1%E8%BE%93%E5%87%BAhello_world/#_4","text":"\u8fdb\u5165entr.asm\uff0c\u8bbe\u7f6e\u51fd\u6570\u6808\uff0c\u8df3\u8f6c\u5230 rust_main \u6e05\u96f6\u9664.bss.stack\u4ee5\u5916\u7684.bss\u6bb5 \u8c03\u7528println! -> print -> Stdout.write_fmt \u8c03\u7528 painc! -> println! -> shutdown -> sbi_call(SBI_SHUTDOWN, 0, 0, 0)","title":"\u6267\u884c\u6d41\u7a0b"},{"location":"ch1%E8%BF%90%E8%A1%8C%E6%8C%87%E4%BB%A4/","text":"\u8fd0\u884c\u6307\u4ee4 \u751f\u6210\u5185\u6838\u53ef\u6267\u884c\u6587\u4ef6 cargo build --release file target/riscv64gc-unknown-none-elf/release/os \u624b\u52a8\u52a0\u8f7d\u5185\u6838\u53ef\u6267\u884c\u6587\u4ef6 rust-objcopy --strip-all target/riscv64gc-unknown-none-elf/release/os -O binary target/riscv64gc-unknown-none-elf/release/os.bin \u6211\u4eec\u53ef\u4ee5\u4f7f\u7528 stat \u5de5\u5177\u6765\u6bd4\u8f83\u5185\u6838\u53ef\u6267\u884c\u6587\u4ef6\u548c\u5185\u6838\u955c\u50cf\u7684\u5927\u5c0f\uff1a stat target/riscv64gc-unknown-none-elf/release/os stat target/riscv64gc-unknown-none-elf/release/os.bin \u57fa\u4e8eGDB\u9a8c\u8bc1\u542f\u52a8\u6d41\u7a0b qemu-system-riscv64 \\ -machine virt \\ -nographic \\ -bios ../bootloader/rustsbi-qemu.bin \\ -device loader,file=target/riscv64gc-unknown-none-elf/release/os.bin,addr=0x80200000 \\ -s -S -s \u53ef\u4ee5\u4f7f Qemu \u76d1\u542c\u672c\u5730 TCP \u7aef\u53e3 1234 \u7b49\u5f85 GDB \u5ba2\u6237\u7aef\u8fde\u63a5\uff0c\u800c -S \u53ef\u4ee5\u4f7f Qemu \u5728\u6536\u5230 GDB \u7684\u8bf7\u6c42\u540e\u518d\u5f00\u59cb\u8fd0\u884c\u3002\u56e0\u6b64\uff0cQemu \u6682\u65f6\u6ca1\u6709\u4efb\u4f55\u8f93\u51fa\u3002 \u6253\u5f00\u53e6\u4e00\u4e2a\u7ec8\u7aef\uff0c\u542f\u52a8\u4e00\u4e2a GDB \u5ba2\u6237\u7aef\u8fde\u63a5\u5230 Qemu \uff1a riscv64-unknown-elf-gdb \\ -ex 'file target/riscv64gc-unknown-none-elf/release/os' \\ -ex 'set arch riscv:rv64' \\ -ex 'target remote localhost:1234' b *0x80200000 c x/10i $pc GBD\u6307\u4ee4 \u8fd9\u91cc x/10i $pc \u7684\u542b\u4e49\u662f\u4ece\u5f53\u524d PC \u503c\u7684\u4f4d\u7f6e\u5f00\u59cb\uff0c\u5728\u5185\u5b58\u4e2d\u53cd\u6c47\u7f16 10 \u6761\u6307\u4ee4 si \u53ef\u4ee5\u8ba9 Qemu \u6bcf\u6b21\u5411\u4e0b\u6267\u884c\u4e00\u6761\u6307\u4ee4\uff0c\u4e4b\u540e\u5c4f\u5e55\u4f1a\u6253\u5370\u51fa\u5f85\u6267\u884c\u7684\u4e0b\u4e00\u6761\u6307\u4ee4\u7684\u5730\u5740 p/x $t0 \u4ee5 16 \u8fdb\u5236\u6253\u5370\u5bc4\u5b58\u5668 t0 \u7684\u503c\uff0c\u6ce8\u610f\u5f53\u6211\u4eec\u8981\u6253\u5370\u5bc4\u5b58\u5668\u7684\u65f6\u5019\u9700\u8981\u5728\u5bc4\u5b58\u5668\u7684\u540d\u5b57\u524d\u9762\u52a0\u4e0a $ \u6211\u4eec\u5728\u5185\u6838\u7684\u5165\u53e3\u70b9\uff0c\u4e5f\u5373\u5730\u5740 0x80200000 \u5904\u6253\u4e00\u4e2a\u65ad\u70b9\u3002\u9700\u8981\u6ce8\u610f\uff0c\u5f53\u9700\u8981\u5728\u4e00\u4e2a\u7279\u5b9a\u7684\u5730\u5740\u6253\u65ad\u70b9\u65f6\uff0c\u9700\u8981\u5728\u5730\u5740\u524d\u9762\u52a0\u4e0a ` \u3002\u63a5\u4e0b\u6765\u901a\u8fc7 c` \u547d\u4ee4\uff08Continue \u7684\u7f29\u5199\uff09\u8ba9 Qemu \u5411\u4e0b\u8fd0\u884c\u76f4\u5230\u9047\u5230\u4e00\u4e2a\u65ad\u70b9 p/d $x1 \u53ef\u4ee5\u4ee5\u5341\u8fdb\u5236\u6253\u5370\u5bc4\u5b58\u5668 x1 \u7684\u503c\uff0c\u5b83\u7684\u7ed3\u679c\u6b63\u786e","title":"\u8fd0\u884c\u6307\u4ee4"},{"location":"ch1%E8%BF%90%E8%A1%8C%E6%8C%87%E4%BB%A4/#_1","text":"","title":"\u8fd0\u884c\u6307\u4ee4"},{"location":"ch1%E8%BF%90%E8%A1%8C%E6%8C%87%E4%BB%A4/#_2","text":"cargo build --release file target/riscv64gc-unknown-none-elf/release/os","title":"\u751f\u6210\u5185\u6838\u53ef\u6267\u884c\u6587\u4ef6"},{"location":"ch1%E8%BF%90%E8%A1%8C%E6%8C%87%E4%BB%A4/#_3","text":"rust-objcopy --strip-all target/riscv64gc-unknown-none-elf/release/os -O binary target/riscv64gc-unknown-none-elf/release/os.bin \u6211\u4eec\u53ef\u4ee5\u4f7f\u7528 stat \u5de5\u5177\u6765\u6bd4\u8f83\u5185\u6838\u53ef\u6267\u884c\u6587\u4ef6\u548c\u5185\u6838\u955c\u50cf\u7684\u5927\u5c0f\uff1a stat target/riscv64gc-unknown-none-elf/release/os stat target/riscv64gc-unknown-none-elf/release/os.bin","title":"\u624b\u52a8\u52a0\u8f7d\u5185\u6838\u53ef\u6267\u884c\u6587\u4ef6"},{"location":"ch1%E8%BF%90%E8%A1%8C%E6%8C%87%E4%BB%A4/#gdb","text":"qemu-system-riscv64 \\ -machine virt \\ -nographic \\ -bios ../bootloader/rustsbi-qemu.bin \\ -device loader,file=target/riscv64gc-unknown-none-elf/release/os.bin,addr=0x80200000 \\ -s -S -s \u53ef\u4ee5\u4f7f Qemu \u76d1\u542c\u672c\u5730 TCP \u7aef\u53e3 1234 \u7b49\u5f85 GDB \u5ba2\u6237\u7aef\u8fde\u63a5\uff0c\u800c -S \u53ef\u4ee5\u4f7f Qemu \u5728\u6536\u5230 GDB \u7684\u8bf7\u6c42\u540e\u518d\u5f00\u59cb\u8fd0\u884c\u3002\u56e0\u6b64\uff0cQemu \u6682\u65f6\u6ca1\u6709\u4efb\u4f55\u8f93\u51fa\u3002 \u6253\u5f00\u53e6\u4e00\u4e2a\u7ec8\u7aef\uff0c\u542f\u52a8\u4e00\u4e2a GDB \u5ba2\u6237\u7aef\u8fde\u63a5\u5230 Qemu \uff1a riscv64-unknown-elf-gdb \\ -ex 'file target/riscv64gc-unknown-none-elf/release/os' \\ -ex 'set arch riscv:rv64' \\ -ex 'target remote localhost:1234' b *0x80200000 c x/10i $pc","title":"\u57fa\u4e8eGDB\u9a8c\u8bc1\u542f\u52a8\u6d41\u7a0b"},{"location":"ch1%E8%BF%90%E8%A1%8C%E6%8C%87%E4%BB%A4/#gbd","text":"\u8fd9\u91cc x/10i $pc \u7684\u542b\u4e49\u662f\u4ece\u5f53\u524d PC \u503c\u7684\u4f4d\u7f6e\u5f00\u59cb\uff0c\u5728\u5185\u5b58\u4e2d\u53cd\u6c47\u7f16 10 \u6761\u6307\u4ee4 si \u53ef\u4ee5\u8ba9 Qemu \u6bcf\u6b21\u5411\u4e0b\u6267\u884c\u4e00\u6761\u6307\u4ee4\uff0c\u4e4b\u540e\u5c4f\u5e55\u4f1a\u6253\u5370\u51fa\u5f85\u6267\u884c\u7684\u4e0b\u4e00\u6761\u6307\u4ee4\u7684\u5730\u5740 p/x $t0 \u4ee5 16 \u8fdb\u5236\u6253\u5370\u5bc4\u5b58\u5668 t0 \u7684\u503c\uff0c\u6ce8\u610f\u5f53\u6211\u4eec\u8981\u6253\u5370\u5bc4\u5b58\u5668\u7684\u65f6\u5019\u9700\u8981\u5728\u5bc4\u5b58\u5668\u7684\u540d\u5b57\u524d\u9762\u52a0\u4e0a $ \u6211\u4eec\u5728\u5185\u6838\u7684\u5165\u53e3\u70b9\uff0c\u4e5f\u5373\u5730\u5740 0x80200000 \u5904\u6253\u4e00\u4e2a\u65ad\u70b9\u3002\u9700\u8981\u6ce8\u610f\uff0c\u5f53\u9700\u8981\u5728\u4e00\u4e2a\u7279\u5b9a\u7684\u5730\u5740\u6253\u65ad\u70b9\u65f6\uff0c\u9700\u8981\u5728\u5730\u5740\u524d\u9762\u52a0\u4e0a ` \u3002\u63a5\u4e0b\u6765\u901a\u8fc7 c` \u547d\u4ee4\uff08Continue \u7684\u7f29\u5199\uff09\u8ba9 Qemu \u5411\u4e0b\u8fd0\u884c\u76f4\u5230\u9047\u5230\u4e00\u4e2a\u65ad\u70b9 p/d $x1 \u53ef\u4ee5\u4ee5\u5341\u8fdb\u5236\u6253\u5370\u5bc4\u5b58\u5668 x1 \u7684\u503c\uff0c\u5b83\u7684\u7ed3\u679c\u6b63\u786e","title":"GBD\u6307\u4ee4"},{"location":"ch2%E5%AE%9E%E7%8E%B0%E6%89%B9%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","text":"\u5b9e\u73b0\u6279\u5904\u7406\u64cd\u4f5c\u7cfb\u7edf \u7b2c\u4e8c\u7ae0\u4ee3\u7801\u6811 ./os/src Rust 13 Files 372 Lines Assembly 2 Files 58 Lines \u251c\u2500\u2500 bootloader \u2502 \u251c\u2500\u2500 rustsbi-k210.bin \u2502 \u2514\u2500\u2500 rustsbi-qemu.bin \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 os \u2502 \u251c\u2500\u2500 build.rs(\u65b0\u589e\uff1a\u751f\u6210 link_app.S \u5c06\u5e94\u7528\u4f5c\u4e3a\u4e00\u4e2a\u6570\u636e\u6bb5\u94fe\u63a5\u5230\u5185\u6838) \u2502 \u251c\u2500\u2500 Cargo.toml \u2502 \u251c\u2500\u2500 Makefile(\u4fee\u6539\uff1a\u6784\u5efa\u5185\u6838\u4e4b\u524d\u5148\u6784\u5efa\u5e94\u7528) \u2502 \u2514\u2500\u2500 src \u2502 \u251c\u2500\u2500 batch.rs(\u65b0\u589e\uff1a\u5b9e\u73b0\u4e86\u4e00\u4e2a\u7b80\u5355\u7684\u6279\u5904\u7406\u7cfb\u7edf) \u2502 \u251c\u2500\u2500 console.rs \u2502 \u251c\u2500\u2500 entry.asm \u2502 \u251c\u2500\u2500 lang_items.rs \u2502 \u251c\u2500\u2500 link_app.S(\u6784\u5efa\u4ea7\u7269\uff0c\u7531 os/build.rs \u8f93\u51fa) \u2502 \u251c\u2500\u2500 linker-k210.ld \u2502 \u251c\u2500\u2500 linker-qemu.ld \u2502 \u251c\u2500\u2500 main.rs(\u4fee\u6539\uff1a\u4e3b\u51fd\u6570\u4e2d\u9700\u8981\u521d\u59cb\u5316 Trap \u5904\u7406\u5e76\u52a0\u8f7d\u548c\u6267\u884c\u5e94\u7528) \u2502 \u251c\u2500\u2500 sbi.rs \u2502 \u251c\u2500\u2500 sync(\u65b0\u589e\uff1a\u540c\u6b65\u5b50\u6a21\u5757 sync \uff0c\u76ee\u524d\u552f\u4e00\u529f\u80fd\u662f\u63d0\u4f9b UPSafeCell) \u2502 \u2502 \u251c\u2500\u2500 mod.rs \u2502 \u2502 \u2514\u2500\u2500 up.rs(\u5305\u542b UPSafeCell\uff0c\u5b83\u53ef\u4ee5\u5e2e\u52a9\u6211\u4eec\u4ee5\u66f4 Rust \u7684\u65b9\u5f0f\u4f7f\u7528\u5168\u5c40\u53d8\u91cf) \u2502 \u251c\u2500\u2500 syscall(\u65b0\u589e\uff1a\u7cfb\u7edf\u8c03\u7528\u5b50\u6a21\u5757 syscall) \u2502 \u2502 \u251c\u2500\u2500 fs.rs(\u5305\u542b\u6587\u4ef6 I/O \u76f8\u5173\u7684 syscall) \u2502 \u2502 \u251c\u2500\u2500 mod.rs(\u63d0\u4f9b syscall \u65b9\u6cd5\u6839\u636e syscall ID \u8fdb\u884c\u5206\u53d1\u5904\u7406) \u2502 \u2502 \u2514\u2500\u2500 process.rs(\u5305\u542b\u4efb\u52a1\u5904\u7406\u76f8\u5173\u7684 syscall) \u2502 \u2514\u2500\u2500 trap(\u65b0\u589e\uff1aTrap \u76f8\u5173\u5b50\u6a21\u5757 trap) \u2502 \u251c\u2500\u2500 context.rs(\u5305\u542b Trap \u4e0a\u4e0b\u6587 TrapContext) \u2502 \u251c\u2500\u2500 mod.rs(\u5305\u542b Trap \u5904\u7406\u5165\u53e3 trap_handler) \u2502 \u2514\u2500\u2500 trap.S(\u5305\u542b Trap \u4e0a\u4e0b\u6587\u4fdd\u5b58\u4e0e\u6062\u590d\u7684\u6c47\u7f16\u4ee3\u7801) \u251c\u2500\u2500 README.md \u251c\u2500\u2500 rust-toolchain \u251c\u2500\u2500 tools \u2502 \u251c\u2500\u2500 kflash.py \u2502 \u251c\u2500\u2500 LICENSE \u2502 \u251c\u2500\u2500 package.json \u2502 \u251c\u2500\u2500 README.rst \u2502 \u2514\u2500\u2500 setup.py \u2514\u2500\u2500 user(\u65b0\u589e\uff1a\u5e94\u7528\u6d4b\u4f8b\u4fdd\u5b58\u5728 user \u76ee\u5f55\u4e0b) \u251c\u2500\u2500 Cargo.toml \u251c\u2500\u2500 Makefile \u2514\u2500\u2500 src \u251c\u2500\u2500 bin(\u57fa\u4e8e\u7528\u6237\u5e93 user_lib \u5f00\u53d1\u7684\u5e94\u7528\uff0c\u6bcf\u4e2a\u5e94\u7528\u653e\u5728\u4e00\u4e2a\u6e90\u6587\u4ef6\u4e2d) \u2502 \u251c\u2500\u2500 00hello_world.rs \u2502 \u251c\u2500\u2500 01store_fault.rs \u2502 \u251c\u2500\u2500 02power.rs \u2502 \u251c\u2500\u2500 03priv_inst.rs \u2502 \u2514\u2500\u2500 04priv_csr.rs \u251c\u2500\u2500 console.rs \u251c\u2500\u2500 lang_items.rs \u251c\u2500\u2500 lib.rs(\u7528\u6237\u5e93 user_lib) \u251c\u2500\u2500 linker.ld(\u5e94\u7528\u7684\u94fe\u63a5\u811a\u672c) \u2514\u2500\u2500 syscall.rs(\u5305\u542b syscall \u65b9\u6cd5\u751f\u6210\u5b9e\u9645\u7528\u4e8e\u7cfb\u7edf\u8c03\u7528\u7684\u6c47\u7f16\u6307\u4ee4\uff0c \u5404\u4e2a\u5177\u4f53\u7684 syscall \u90fd\u662f\u901a\u8fc7 syscall \u6765\u5b9e\u73b0\u7684) \u672c\u8282\u7684\u4efb\u52a1 \u5728\u6279\u5904\u7406\u64cd\u4f5c\u7cfb\u7edf\u4e2d\uff0c\u6bcf\u5f53\u4e00\u4e2a\u5e94\u7528\u6267\u884c\u5b8c\u6bd5\uff0c\u6211\u4eec\u90fd\u9700\u8981\u5c06\u4e0b\u4e00\u4e2a\u8981\u6267\u884c\u7684\u5e94\u7528\u7684\u4ee3\u7801\u548c\u6570\u636e\u52a0\u8f7d\u5230\u5185\u5b58 \u5982\u4f55\u627e\u5230\u5e94\u7528\u6240\u5728\u7684\u4f4d\u7f6e \u6211\u4eec\u5c06\u591a\u4e2a\u5e94\u7528\u7a0b\u5e8f\u7684\u4ee3\u7801\u548c\u5185\u6838\u7684\u4ee3\u7801\u901a\u8fc7\u7f16\u7a0b\u6280\u5de7\u5c06\u5176 \u7ed1\u5b9a\u5728\u4e00\u8d77\uff0c\u662f\u4e00\u79cd\u9759\u6001\u7ed1\u5b9a \u57fa\u4e8e\u9759\u6001\u7f16\u7801\u7559\u4e0b\u7684\u7ed1\u5b9a\u4fe1\u606f\uff0c\u5185\u6838\u5c31\u53ef\u4ee5\u627e\u5230\u6bcf\u4e2a\u5e94\u7528\u7a0b\u5e8f\u6587\u4ef6\u4e8c\u8fdb\u5236\u4ee3\u7801\u7684\u8d77\u59cb\u5730\u5740\u548c\u957f\u5ea6\uff0c\u5e76\u52a0\u8f7d\u5230\u5185\u5b58\u4e2d\u8fd0\u884c \u672c\u8282\u6587\u4ef6\u89e3\u6790 os\u6587\u4ef6\u5939\u4e0b os/.cargo/config [build] target = \"riscv64gc-unknown-none-elf\" [target.riscv64gc-unknown-none-elf] rustflags = [ \"-Clink-arg=-Tsrc/linker.ld\",\"-Cforce-frame-pointers=yes\" ] os/Cargo.toml [package] name = \"os\" version = \"0.1.0\" edition = \"2021\" # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html [dependencies] riscv = {git = \"https://github.com/rcore-os/riscv\", features = [\"inline-asm\"]} # \u7528\u4e8e\u5f15\u7528 Rust \u7684 riscv \u5e93\uff0c\u65b9\u4fbf\u64cd\u4f5cCSR lazy_static = {version = \"1.4.0\", features = [\"spin_no_std\"]} # \u8c03\u7528\u5916\u90e8\u5e93 lazy_static \uff0c \u7528\u4e8e\u83b7\u53d6 lazy_static! \u5b8f os/src/entry.asm # .section .text.entry # .global _start # _start: # li x1, 100 .section .text.entry .global _start _start: la sp, boot_stack_top call rust_main .section .bss.stack .global boot_stack boot_stack: .space 4096 * 16 .global boot_stack_top boot_stack_top: os/build.rs // \u7528\u4e8e\u751f\u6210 link_app.S use std::io::{Result, Write}; use std::fs::{File, read_dir}; fn main(){ println!(\"cargo:rerun-if-changed=../user/src/\"); println!(\"cargo:rerun-if-changed={}\", TARGET_PATH); insert_app_data().unwrap(); } static TARGET_PATH: &str = \"../user/target/riscv64gc-unknown-none-elf/release/\"; fn insert_app_data() -> Result<()> { let mut f = File::create(\"src/link_app.S\").unwrap(); // \u521b\u5efa link_app.S \u6587\u4ef6 let mut apps: Vec<_> = read_dir(\"../user/src/bin\") // \u8bfb\u53d6user/src/bin \u76ee\u5f55\u4e0b\u7684\u6587\u4ef6\uff0c \u83b7\u53d6\u6587\u4ef6\u540d .unwrap() .into_iter() .map(|dir_entry|{ let mut name_with_ext = dir_entry.unwrap().file_name().into_string().unwrap(); name_with_ext.drain(name_with_ext.find('.').unwrap()..name_with_ext.len()); name_with_ext }) .collect(); apps.sort(); // \u5c06\u6587\u4ef6\u6392\u5e8f writeln!(f, r#\" .align 3 .section .data .global _num_app _num_app: .quad {}\"#, apps.len())?; // \u5e94\u7528\u6587\u4ef6\u7684\u4e2a\u6570 for i in 0..apps.len() { writeln!(f, r#\" .quad app_{}_start\"#, i)?; } writeln!(f, r#\" .quad app_{}_end\"#, apps.len() - 1)?; for (idx, app) in apps.iter().enumerate(){ println!(\"app_{}: {}\", idx, app); writeln!(f, r#\" .section .data .global app_{0}_start .global app_{0}_end app_{0}_start: .incbin \"{2}{1}.bin\" app_{0}_end:\"#, idx, app, TARGET_PATH)?; } // \u5faa\u73af\uff0c\u5c06\u5e94\u7528\u90fd\u653e\u5728 .data\u6bb5\u4e2d\uff0c\u5e76\u83b7\u53d6\u5176 \u5f00\u59cb\u5730\u5740\u548c\u7ed3\u675f\u5730\u5740 // \u6309\u683c\u5f0f\u751f\u6210 link_app.S Ok(()) } os/src/link_app.S #\u5b83\u4e00\u5f00\u59cb\u5e76\u4e0d\u5b58\u5728\uff0c\u800c\u662f\u5728\u6784\u5efa\u64cd\u4f5c\u7cfb\u7edf\u65f6\u81ea\u52a8\u751f\u6210\u7684\u3002\u5f53\u6211\u4eec\u4f7f\u7528 make run \u8ba9\u7cfb\u7edf\u8fd0\u884c\u7684\u8fc7\u7a0b\u4e2d\uff0c\u8fd9\u4e2a\u6c47\u7f16\u4ee3\u7801 link_app.S \u5c31\u751f\u6210\u4e86 .align 3 .section .data .global _num_app _num_app: # .quad \u7528\u4e8e\u5b9a\u4e49\u4e00\u4e2a 64\u4f4d\u7684\u6570\u636e .quad 5 .quad app_0_start .quad app_1_start .quad app_2_start .quad app_3_start .quad app_4_start .quad app_4_end .section .data .global app_0_start .global app_0_end app_0_start: .incbin \"../user/target/riscv64gc-unknown-none-elf/release/00hello_world.bin\" app_0_end: .section .data .global app_1_start .global app_1_end app_1_start: .incbin \"../user/target/riscv64gc-unknown-none-elf/release/01store_fault.bin\" # \u524d\u9762\u6211\u4eec\u4eceELF\u683c\u5f0f\u53ef\u6267\u884c\u6587\u4ef6\u5265\u79bb\u5143\u6570\u636e\u540e\u653e\u5165\u5230\u4e8c\u8fdb\u5236\u955c\u50cf\u6587\u4ef6\u4e2d # \u8fd9\u91cc\u76f4\u63a5\u5c06 \u8fd9\u4e2a\u955c\u50cf\u6587\u4ef6 \u653e\u5728\u5185\u6838\u7684\u6570\u636e\u6bb5 \u94fe\u63a5\u5230\u5185\u6838\u4e2d app_1_end: .section .data .global app_2_start .global app_2_end app_2_start: .incbin \"../user/target/riscv64gc-unknown-none-elf/release/02power.bin\" app_2_end: .section .data .global app_3_start .global app_3_end app_3_start: .incbin \"../user/target/riscv64gc-unknown-none-elf/release/03priv_inst.bin\" app_3_end: .section .data .global app_4_start .global app_4_end app_4_start: .incbin \"../user/target/riscv64gc-unknown-none-elf/release/04priv_csr.bin\" app_4_end: src/sync/up.rs use core::cell::{RefCell, RefMut}; pub struct UPSafeCell<T>{ inner: RefCell<T>, } unsafe impl<T> Sync for UPSafeCell<T> {} impl<T> UPSafeCell<T> { pub unsafe fn new(value: T) -> Self{ Self{ inner: RefCell::new(value)} } pub fn exclusive_access(&self) -> RefMut<'_, T> { self.inner.borrow_mut() } } // \u5173\u4e8e\u6240\u6709\u6743 \u548c \u5b89\u5168 \u76f8\u5173\u7684rust\u7f16\u7a0b\u6280\u5de7\uff0c \u540e\u9762\u518d\u5173\u6ce8 os/src/sync/mod.rs mod up; pub use up::UPSafeCell; os/src/batch.rs // \u672c\u8282\u7684\u6838\u5fc3\u4ee3\u7801 use lazy_static::*; use crate::trap::TrapContext; use crate::sync::UPSafeCell; use core::arch::asm; const USER_STACK_SIZE: usize = 4096 * 2; const KERNEL_STACK_SIZE: usize = 4096 * 2; // \u5e38\u6570\u6307\u51fa \u5185\u6838\u6808\u548c\u7528\u6237\u6808\u7684\u5927\u5c0f \u5206\u522b\u4e3a8KB // \u4ee5\u5168\u5c40\u53d8\u91cf\u7684\u5f62\u5f0f\u5b9e\u4f8b\u5316\u5728\u64cd\u4f5c\u7cfb\u7edf\u7684 .bss \u6bb5\u4e2d const MAX_APP_NUM: usize = 16; const APP_BASE__ADDRESS: usize = 0x80400000; const APP_SIZE_LIMIT: usize = 0x20000; #[repr(align(4096))] struct KernelStack{ data: [u8; KERNEL_STACK_SIZE], } #[repr(align(4096))] struct UserStack{ data: [u8; USER_STACK_SIZE], } // \u8868\u793a\u7528\u6237\u6808\u548c\u5185\u6838\u6808\uff0c\u90fd\u662f\u5b57\u8282\u6570\u7ec4\u7684\u7b80\u5355\u5305\u88c5 // \u7528\u4e8e\u4fdd\u5b58\u5728trap\u53d1\u751f\u524d \u539f\u63a7\u5236\u6d41\u7684\u5bc4\u5b58\u5668\u72b6\u6001 static KERNEL_STACK: KernelStack = KernelStack {data: [0; KERNEL_STACK_SIZE]}; static USER_STACK: UserStack = UserStack { data: [0; USER_STACK_SIZE]}; impl KernelStack{ fn get_sp(&self) -> usize{ self.data.as_ptr() as usize + KERNEL_STACK_SIZE // .as_ptr \u83b7\u53d6\u5b57\u7b26\u4e32\u5b57\u9762\u91cf\u7684\u5730\u5740 } pub fn push_context(&self, cx: TrapContext) -> &'static mut TrapContext { let cx_ptr = (self.get_sp() - core::mem::size_of::<TrapContext>()) as *mut TrapContext; unsafe { *cx_ptr = cx;} unsafe { cx_ptr.as_mut().unwrap() } } } impl UserStack { fn get_sp(&self) -> usize { self.data.as_ptr() as usize + USER_STACK_SIZE } } // \u5b9e\u73b0 get_sp \u65b9\u6cd5 \u6765\u83b7\u53d6\u6808\u9876\u5730\u5740 // \u7531\u4e8e\u5728RISCV\u4e2d\u6808\u662f\u5411\u4e0b\u589e\u957f\u7684\uff0c\u53ea\u9700\u8fd4\u56de\u5305\u88f9\u7684\u6570\u7ec4\u7684\u7ed3\u5c3e\u5730\u5740 // \u7528\u6237\u6808\u548c\u5185\u6838\u6808\u7684\u5207\u6362\uff0c \u53ea\u9700\u8981\u5c06 sp \u5bc4\u5b58\u5668\u7684\u503c\u4fee\u6539\u4e3a get_sp \u7684\u8fd4\u56de\u503c\u5373\u53ef // \u5e94\u7528\u7ba1\u7406\u5668 \u672c\u8282\u7684\u6838\u5fc3\u7ec4\u4ef6 // \u80fd\u591f\u627e\u5230\u5e76\u52a0\u8f7d\u5e94\u7528\u7a0b\u5e8f\u4e8c\u8fdb\u5236\u7801 struct AppManager{ num_app: usize, // \u4fdd\u5b58\u5e94\u7528\u6570\u91cf current_app: usize, // \u5f53\u524d\u6267\u884c\u5230\u4e86\u7b2c\u51e0\u4e2a\u5e94\u7528 app_start: [usize; MAX_APP_NUM+1], // \u4fdd\u5b58\u5e94\u7528\u7684\u5404\u81ea\u7684\u4f4d\u7f6e } // \u6839\u636e\u5e94\u7528\u7a0b\u5e8f\u4f4d\u7f6e\u4fe1\u606f\uff0c\u521d\u59cb\u5316\u597d\u5e94\u7528\u6240\u9700\u5185\u5b58\u7a7a\u95f4\uff0c\u5e76\u52a0\u8f7d\u5e94\u7528\u6267\u884c impl AppManager { pub fn print_app_info(&self){ println!(\"[kernel] num_app = {}\", self.num_app); for i in 0..self.num_app { println!(\"[kernel] app_{} [{:#x}, {:#x})\", i, self.app_start[i], self.app_start[i+1]); } } unsafe fn load_app(&self, app_id: usize){ if app_id >= self.num_app{ panic!(\"All applications completed!\"); } println!(\"[kernel] Loading app_{}\", app_id); asm!(\"fence.i\"); // \u6c47\u7f16\u6307\u4ee4 fence.i \u662f\u7528\u6765\u6e05\u7406 i-cache \u7684 // \u901a\u5e38\u60c5\u51b5\u4e0b\uff0c CPU \u4f1a\u8ba4\u4e3a\u7a0b\u5e8f\u7684\u4ee3\u7801\u6bb5\u4e0d\u4f1a\u53d1\u751f\u53d8\u5316\uff0c\u56e0\u6b64 i-cache \u662f\u4e00\u79cd\u53ea\u8bfb\u7f13\u5b58\u3002 //\u4f46\u5728\u8fd9\u91cc\uff0c\u6211\u4eec\u5c06\u4fee\u6539\u4f1a\u88ab CPU \u53d6\u6307\u7684\u5185\u5b58\u533a\u57df\uff0c\u8fd9\u4f1a\u4f7f\u5f97 i-cache \u4e2d\u542b\u6709\u4e0e\u5185\u5b58\u4e2d\u4e0d\u4e00\u81f4\u7684\u5185\u5bb9\u3002 //\u56e0\u6b64\u6211\u4eec\u8fd9\u91cc\u5fc5\u987b\u4f7f\u7528 fence.i \u6307\u4ee4\u624b\u52a8\u6e05\u7a7a i-cache \uff0c\u8ba9\u91cc\u9762\u6240\u6709\u7684\u5185\u5bb9\u5168\u90e8\u5931\u6548\uff0c //\u624d\u80fd\u591f\u4fdd\u8bc1CPU\u8bbf\u95ee\u5185\u5b58\u6570\u636e\u548c\u4ee3\u7801\u7684\u6b63\u786e\u6027 core::slice::from_raw_parts_mut( APP_BASE__ADDRESS as *mut u8, APP_SIZE_LIMIT ).fill(0); let app_src = core::slice::from_raw_parts( self.app_start[app_id] as *const u8, self.app_start[app_id + 1] - self.app_start[app_id] ); let app_dst = core::slice::from_raw_parts_mut( APP_BASE__ADDRESS as *mut u8, app_src.len() ); app_dst.copy_from_slice(app_src); } pub fn get_current_app(&self) -> usize {self.current_app} pub fn move_to_next_app(&mut self){ self.current_app += 1; } } // \u4f7f\u7528 lazy_static! \u5b8f // lazy_static! \u5b8f\u63d0\u4f9b\u4e86\u5168\u5c40\u53d8\u91cf\u7684\u8fd0\u884c\u65f6\u521d\u59cb\u5316\u529f\u80fd // \u6709\u5173\u5b8f\u7684\u5177\u4f53\u7ec6\u8282\uff0c \u540e\u9762\u518d\u4e86\u89e3 lazy_static! { // \u9759\u6001\u751f\u6210\u4e00\u4e2a\u5168\u5c40\u7684 AppManager \u7684\u4e00\u4e2a\u5b9e\u4f8b APP_MANAGER static ref APP_MANAGER: UPSafeCell<AppManager> = unsafe {UPSafeCell::new({ extern \"C\" {fn _num_app();} // \u627e\u5230 link_app.S \u4e2d\u63d0\u4f9b\u7684\u7b26\u53f7 _num_app // \u5e76\u4ece\u8fd9\u91cc\u5f00\u59cb\u89e3\u6790\u51fa\u5e94\u7528\u6570\u91cf\u4ee5\u53ca\u5404\u4e2a\u5e94\u7528\u7684\u8d77\u59cb\u5730\u5740 // link_app.S \u4e2d\u83b7\u53d6 _num_app \u7684\u5730\u5740\uff0c\u4ece\u800c\u53ef\u4ee5\u89e3\u6790\u51fa // _num_app: // .quad 5 // .quad app_0_start // .quad app_1_start // .quad app_2_start // .quad app_3_start // .quad app_4_start // .quad app_4_end let num_app_ptr = _num_app as usize as *const usize; let num_app = num_app_ptr.read_volatile(); let mut app_start: [usize; MAX_APP_NUM + 1] = [0; MAX_APP_NUM + 1]; let app_start_raw: &[usize] = core::slice::from_raw_parts( num_app_ptr.add(1), num_app + 1 ); app_start[..=num_app].copy_from_slice(app_start_raw); AppManager { num_app, current_app: 0, app_start, } // \u521d\u59cb\u5316 AppManager \u7684\u5168\u5c40\u5b9e\u4f8b APP_MANAGER })}; } // batch \u5b50\u6a21\u5757\u5bf9\u5916\u66b4\u9732\u7684\u63a5\u53e3\u5982\u4e0b pub fn init() { print_app_info(); } // \u8c03\u7528 print_app_info \u7684\u65f6\u5019\u7b2c\u4e00\u6b21\u7528\u5230\u4e86\u5168\u5c40\u53d8\u91cf APP_MANAGER \uff0c //\u5b83\u4e5f\u662f\u5728\u8fd9\u4e2a\u65f6\u5019\u5b8c\u6210\u521d\u59cb\u5316 pub fn print_app_info() { APP_MANAGER.exclusive_access().print_app_info(); // exclusive_access \u662f os/src/sync/up.rs \u6a21\u5757\u63d0\u4f9b\u7684\u7528\u4e8e\u5185\u5b58\u5b89\u5168\u7684\u4e00\u79cd\u51fd\u6570 } pub fn run_next_app() -> ! { let mut app_manager = APP_MANAGER.exclusive_access(); let current_app = app_manager.get_current_app(); unsafe { app_manager.load_app(current_app); } app_manager.move_to_next_app(); drop(app_manager); extern \"C\" {fn __restore(cx_addr: usize);} unsafe { __restore(KERNEL_STACK.push_context( TrapContext::app_init_context(APP_BASE__ADDRESS, USER_STACK.get_sp()) ) as *const _ as usize); // \u5728\u5185\u6838\u6808\u4e0a\u538b\u5165\u4e00\u4e2atrap \u4e0a\u4e0b\u6587 // sepc \u662f\u5e94\u7528\u7a0b\u5e8f\u5165\u53e3\u5730\u5740 0x80400000 // sp \u5bc4\u5b58\u5668\u6307\u5411\u7528\u6237\u6808 // sstatus \u7684 SPP \u5b57\u6bb5\u88ab\u8bbe\u7f6e\u4e3a User // push_context \u7684\u8fd4\u56de\u503c\u662f \u5185\u6838\u6808\u538b\u5165 Trap \u4e0a\u4e0b\u6587\u4e4b\u540e\u7684\u6808\u9876 // \u5b83\u88ab\u4f5c\u4e3a __restore \u7684\u53c2\u6570\uff0c \u8fd9\u4f7f\u5f97 __restore \u51fd\u6570\u4e2d sp \u4ecd\u7136\u53ef\u4ee5\u6307\u5411\u5185\u6838\u6808\u7684\u6808\u9876 // \u8fd9\u4e4b\u540e\u5c31\u548c\u6267\u884c\u4e00\u6b21\u666e\u901a\u7684 __restore \u51fd\u6570\u8c03\u7528\u4e00\u6837\u4e86 } panic!(\"Unreachable in batch::run_current_app!\"); // \u8fd9\u4e2a\u4e0d\u4f1a\u88ab\u89e6\u53d1\uff0c\u5728\u6b64\u4e4b\u524d\u4f1a\u6709\u4e00\u4e2apanic\uff0c\u5c31\u76f4\u63a5 shutdown\u4e86 } // \u6279\u5904\u7406\u64cd\u4f5c\u7cfb\u7edf\u7684\u6838\u5fc3\u64cd\u4f5c\uff0c\u5373\u52a0\u8f7d\u5e76\u8fd0\u884c\u4e0b\u4e00\u4e2a\u5e94\u7528\u7a0b\u5e8f\u3002 // \u5f53\u6279\u5904\u7406\u64cd\u4f5c\u7cfb\u7edf\u5b8c\u6210\u521d\u59cb\u5316\u6216\u8005\u4e00\u4e2a\u5e94\u7528\u7a0b\u5e8f\u8fd0\u884c\u7ed3\u675f\u6216\u51fa\u9519\u4e4b\u540e\u4f1a\u8c03\u7528\u8be5\u51fd\u6570 os/src/trap/context.rs use riscv::register::sstatus::{Sstatus, self, SPP}; // Trap \u4e0a\u4e0b\u6587\uff0c\u7c7b\u4f3c\u51fd\u6570\u8c03\u7528\u4e0a\u4e0b\u6587\uff0c // \u5373\u5728Trap\u53d1\u751f\u65f6\u9700\u8981\u4fdd\u5b58\u7684\u7269\u7406\u8d44\u6e90\u5185\u5bb9 #[repr(C)] pub struct TrapContext{ pub x: [usize; 32], // \u6240\u6709\u901a\u7528\u5bc4\u5b58\u5668 // \u627e\u51fa\u54ea\u4e9b\u5bc4\u5b58\u5668\u65e0\u9700\u4fdd\u5b58\u5f88\u96be\uff0c\u751a\u81f3\u4e0d\u53ef\u80fd\uff0c\u90a3\u5c31\u76f4\u63a5\u5168\u90e8\u4fdd\u5b58 pub sstatus: Sstatus, pub sepc: usize, // \u5bf9\u4e8e CSR \u800c\u8a00\uff0c\u6211\u4eec\u77e5\u9053\u8fdb\u5165 Trap \u7684\u65f6\u5019\uff0c //\u786c\u4ef6\u4f1a\u7acb\u5373\u8986\u76d6\u6389 scause/stval/sstatus/sepc \u7684\u5168\u90e8\u6216\u662f\u5176\u4e2d\u4e00\u90e8\u5206\u3002scause/stval \u7684\u60c5\u51b5\u662f\uff1a //\u5b83\u603b\u662f\u5728 Trap \u5904\u7406\u7684\u7b2c\u4e00\u65f6\u95f4\u5c31\u88ab\u4f7f\u7528\u6216\u8005\u662f\u5728\u5176\u4ed6\u5730\u65b9\u4fdd\u5b58\u4e0b\u6765\u4e86\uff0c\u56e0\u6b64\u5b83\u6ca1\u6709\u88ab\u4fee\u6539\u5e76\u9020\u6210\u4e0d\u826f\u5f71\u54cd\u7684\u98ce\u9669\u3002 //\u800c\u5bf9\u4e8e sstatus/sepc \u800c\u8a00\uff0c\u5b83\u4eec\u4f1a\u5728 Trap \u5904\u7406\u7684\u5168\u7a0b\u6709\u610f\u4e49\uff08\u5728 Trap \u63a7\u5236\u6d41\u6700\u540e sret \u7684\u65f6\u5019\u8fd8\u7528\u5230\u4e86\u5b83\u4eec\uff09\uff0c //\u800c\u4e14\u786e\u5b9e\u4f1a\u51fa\u73b0 Trap \u5d4c\u5957\u7684\u60c5\u51b5\u4f7f\u5f97\u5b83\u4eec\u7684\u503c\u88ab\u8986\u76d6\u6389\u3002 //\u6240\u4ee5\u6211\u4eec\u9700\u8981\u5c06\u5b83\u4eec\u4e5f\u4e00\u8d77\u4fdd\u5b58\u4e0b\u6765\uff0c\u5e76\u5728 sret \u4e4b\u524d\u6062\u590d\u539f\u6837 } impl TrapContext{ pub fn set_sp(&mut self, sp: usize) { self.x[2] = sp; // x2 = sp } pub fn app_init_context(entry: usize, sp: usize) -> Self{ let mut sstatus = sstatus::read(); sstatus.set_spp(SPP::User); let mut cx = Self{ x: [0; 32], sstatus, sepc: entry, }; cx.set_sp(sp); cx // \u4fee\u6539\u5176\u4e2d\u7684 sepc \u5bc4\u5b58\u5668\u4e3a\u5e94\u7528\u7a0b\u5e8f\u5165\u53e3\u70b9 entry // sp \u5bc4\u5b58\u5668 \u4e3a\u6211\u4eec\u8bbe\u5b9a\u7684\u4e00\u4e2a\u6808\u6307\u9488\uff0c // sstatus \u5bc4\u5b58\u5668\u7684 SPP \u5b57\u6bb5\u8bbe\u7f6e\u4e3a User } } os/src/trap/mod.rs mod context; use riscv::register::{ mtvec::TrapMode, stvec, scause::{ self, Trap, Exception, }, stval }; use crate::syscall::syscall; use crate::batch::run_next_app; use core::arch::global_asm; global_asm!(include_str!(\"trap.S\")); // \u5728\u64cd\u4f5c\u7cfb\u7edf\u521d\u59cb\u5316\u7684\u65f6\u5019\uff0c \u6211\u4eec\u9700\u8981\u4fee\u6539stvec \u5bc4\u5b58\u5668\u6765\u6307\u5411\u6b63\u786e\u7684Trap\u5904\u7406\u5165\u53e3\u70b9 pub fn init(){ extern \"C\" {fn __alltraps();} // \u5f15\u5165\u5916\u90e8\u7b26\u53f7 __alltraps unsafe{ stvec::write(__alltraps as usize, TrapMode::Direct); // \u5c06stvec\u8bbe\u7f6e\u4e3aDirect\u6a21\u5f0f\u6307\u5411\u5b83\u7684\u5730\u5740 } } #[no_mangle] pub fn trap_handler(cx: &mut TrapContext) -> &mut TrapContext{ let scause = scause::read(); let stval = stval::read(); match scause.cause(){ // scause \u5bc4\u5b58\u5668\u6240\u4fdd\u5b58\u7684 Trap \u7684\u539f\u56e0\u8fdb\u884c\u5206\u53d1\u5904\u7406\u3002\u8fd9\u91cc\u6211\u4eec\u65e0\u9700\u624b\u52a8\u64cd\u4f5c\u8fd9\u4e9b CSR \uff0c // \u800c\u662f\u4f7f\u7528 Rust \u7684 riscv \u5e93\u6765\u66f4\u52a0\u65b9\u4fbf\u7684\u505a\u8fd9\u4e9b\u4e8b\u60c5 // \u8981\u5f15\u5165riscv\u5e93\uff0c \u9700\u8981\u5728os/Cargo.toml \u914d\u7f6e\u6587\u4ef6\u4e2d \u6dfb\u52a0 // [dependencies] // riscv = { git = \"https://github.com/rcore-os/riscv\", features = [\"inline-asm\"] } Trap::Exception(Exception::UserEnvCall) => { // \u5982\u679c\u89e6\u53d1 Trap \u7684\u539f\u56e0\u662f\u6765\u81ea U\u6001 \u7684 \u7cfb\u7edf\u8c03\u7528 cx.sepc += 4; // \u9996\u5148\u4fee\u6539\u4fdd\u5b58\u5728\u5185\u6838\u6808\u4e0a\u7684 Trap \u4e0a\u4e0b\u6587\u91cc\u9762 sepc\uff0c\u8ba9\u5176\u589e\u52a0 4 // \u6211\u4eec\u77e5\u9053\u8fd9\u662f\u4e00\u4e2a\u7531 ecall \u6307\u4ee4\u89e6\u53d1\u7684\u7cfb\u7edf\u8c03\u7528\uff0c\u5728\u8fdb\u5165 Trap \u7684\u65f6\u5019\uff0c // \u786c\u4ef6\u4f1a\u5c06 sepc \u8bbe\u7f6e\u4e3a\u8fd9\u6761 ecall \u6307\u4ee4\u6240\u5728\u7684\u5730\u5740\uff08\u56e0\u4e3a\u5b83\u662f\u8fdb\u5165 Trap \u4e4b\u524d\u6700\u540e\u4e00\u6761\u6267\u884c\u7684\u6307\u4ee4\uff09\u3002 // \u800c\u5728 Trap \u8fd4\u56de\u4e4b\u540e\uff0c\u6211\u4eec\u5e0c\u671b\u5e94\u7528\u7a0b\u5e8f\u63a7\u5236\u6d41\u4ece ecall \u7684\u4e0b\u4e00\u6761\u6307\u4ee4\u5f00\u59cb\u6267\u884c\u3002 // \u56e0\u6b64\u6211\u4eec\u53ea\u9700\u4fee\u6539 Trap \u4e0a\u4e0b\u6587\u91cc\u9762\u7684 sepc\uff0c\u8ba9\u5b83\u589e\u52a0 ecall \u6307\u4ee4\u7684\u7801\u957f\uff0c\u4e5f\u5373 4 \u5b57\u8282\u3002 // \u8fd9\u6837\u5728 __restore \u7684\u65f6\u5019 sepc \u5728\u6062\u590d\u4e4b\u540e\u5c31\u4f1a\u6307\u5411 ecall \u7684\u4e0b\u4e00\u6761\u6307\u4ee4\uff0c // \u5e76\u5728 sret \u4e4b\u540e\u4ece\u90a3\u91cc\u5f00\u59cb\u6267\u884c cx.x[10] = syscall(cx.x[17], [cx.x[10], cx.x[11], cx.x[12]]) as usize; // x10=a0 x17=a7 x10=a0 x11=a1 x12=a2 // \u5904\u7406\u6b63\u5e38\u7cfb\u7edf\u8c03\u7528\u7684\u63a7\u5236\u903b\u8f91 // \u7528\u6765\u4fdd\u5b58\u7cfb\u7edf\u8c03\u7528\u8fd4\u56de\u503c\u7684 a0 \u5bc4\u5b58\u5668\u4e5f\u4f1a\u540c\u6837\u53d1\u751f\u53d8\u5316\u3002 // \u6211\u4eec\u4ece Trap \u4e0a\u4e0b\u6587\u53d6\u51fa\u4f5c\u4e3a syscall ID \u7684 a7 \u548c\u7cfb\u7edf\u8c03\u7528\u7684\u4e09\u4e2a\u53c2\u6570 a0~a2 // \u4f20\u7ed9 syscall \u51fd\u6570\u5e76\u83b7\u53d6\u8fd4\u56de\u503c // syscall \u5728 syscall \u5b50\u6a21\u5757\u4e2d\u5b9e\u73b0 } Trap::Exception(Exception::StoreFault) | Trap::Exception(Exception::StorePageFault) => { // \u5904\u7406\u5e94\u7528\u7a0b\u5e8f\u51fa\u73b0\u8bbf\u5b58\u9519\u8bef println!(\"[kernel] PageFault in application, kernel killed it.\"); // \u6253\u5370\u9519\u8bef\u4fe1\u606f run_next_app(); // \u76f4\u63a5\u5207\u6362\u5e76\u8fd0\u884c\u4e0b\u4e00\u4e2a\u5e94\u7528\u7a0b\u5e8f } Trap::Exception(Exception::IllegalInstruction) => { // \u975e\u6cd5\u6307\u4ee4\u9519\u8bef println!(\"[kernel] IllegalInstruction in application, kernel killed it.\"); run_next_app(); } _ => { // \u5f53\u9047\u5230\u76ee\u524d\u8fd8\u4e0d\u652f\u6301\u7684Trap\u7c7b\u578b\u65f6\uff0c\u64cd\u4f5c\u6574\u4e2apanic\u62a5\u9519\u9000\u51fa panic!(\"Unsupported trap {:?}, stval = {:#x}!\", scause.cause(), stval); } } cx // \u5c06\u4f20\u5165\u7684 cx \u539f\u6837\u8fd4\u56de\uff0c\u56e0\u6b64\u5728 __restore \u7684\u65f6\u5019 a0 \u5bc4\u5b58\u5668\u5728\u8c03\u7528 trap_handler \u524d\u540e\u5e76\u6ca1\u6709\u53d1\u751f\u53d8\u5316\uff0c // \u4ecd\u7136\u6307\u5411\u5206\u914d Trap \u4e0a\u4e0b\u6587\u4e4b\u540e\u7684\u5185\u6838\u6808\u6808\u9876\uff0c\u548c\u6b64\u65f6 sp \u7684\u503c\u76f8\u540c\uff0c\u8fd9\u91cc\u7684 sp <- a0 \u5e76\u4e0d\u4f1a\u6709\u95ee\u9898 } pub use context::TrapContext; os/src/trap/trap.S .altmacro # \u52a0\u5165.altmacro \u624d\u80fd\u6b63\u5e38\u4f7f\u7528 .rept \u547d\u4ee4 .macro SAVE_GP n sd x\\n, \\n*8(sp) .endm .macro LOAD_GP n ld x\\n, \\n*8(sp) .endm .section .text .globl __alltraps .globl __restore .align 2 # .align \u5c06 __alltraps \u7684\u5730\u5740 4 \u5b57\u8282\u5bf9\u9f50\uff0c\u8fd9\u662f RISC-V \u7279\u6743\u7ea7\u89c4\u8303\u7684\u8981\u6c42 __alltraps: # \u5c06Trap\u4e0a\u4e0b\u6587\u4fdd\u5b58\u5728\u5185\u6838\u6808\u4e0a # sp -> user stack, sscratch -> kernel stack csrrw sp, sscratch, sp # sp -> kernel stack, sscratch -> user stack # csrrw \u539f\u578b\u662f csrrw rd, csr, rs \u53ef\u4ee5\u5c06 CSR \u5f53\u524d\u7684\u503c\u8bfb\u5230\u901a\u7528\u5bc4\u5b58\u5668 rd \u4e2d\uff0c # \u7136\u540e\u5c06\u901a\u7528\u5bc4\u5b58\u5668 rs \u7684\u503c\u5199\u5165\u8be5 CSR \u3002 # \u56e0\u6b64\u8fd9\u91cc\u8d77\u5230\u7684\u662f\u4ea4\u6362 sscratch \u548c sp \u7684\u6548\u679c\u3002\u5728\u8fd9\u4e00\u884c\u4e4b\u524d sp \u6307\u5411\u7528\u6237\u6808\uff0c # sscratch \u6307\u5411\u5185\u6838\u6808\uff08\u539f\u56e0\u7a0d\u540e\u8bf4\u660e\uff09\uff0c\u73b0\u5728 sp \u6307\u5411\u5185\u6838\u6808\uff0c sscratch \u6307\u5411\u7528\u6237\u6808 addi sp, sp, -34*8 # \u51c6\u5907\u5728\u5185\u6838\u6808\u4e0a\u4fdd\u5b58Trap\u4e0a\u4e0b\u6587\uff0c \u9884\u5148\u5206\u914d 34x8 \u5b57\u8282\u7684\u6808\u5e27 # \u6b64\u65f6 sp -> kernel stack sd x1, 1*8(sp) # \u6211\u4eec\u5728\u8fd9\u91cc\u4e5f\u4e0d\u4fdd\u5b58 sp(x2)\uff0c\u56e0\u4e3a\u6211\u4eec\u8981\u57fa\u4e8e\u5b83\u6765\u627e\u5230\u6bcf\u4e2a\u5bc4\u5b58\u5668\u5e94\u8be5\u88ab\u4fdd\u5b58\u5230\u7684\u6b63\u786e\u7684\u4f4d\u7f6e sd x3, 3*8(sp) # tp(x4) \u4e4b\u524d\u8bf4\u660e\u4e86\u539f\u56e0 .set n, 5 .rept 27 # \u7c7b\u4f3c\u5faa\u73af SAVE_GP %n .set n, n+1 .endr # \u4fdd\u5b5832 \u4e2a\u901a\u7528\u5bc4\u5b58\u5668\u7684\u540e 27\u4e2a # \u5728\u6808\u5206\u914d\u4e4b\u540e\uff0c\u53ef\u7528\u4e8e\u4fdd\u5b58Trap\u4e0a\u4e0b\u6587\u7684\u5730\u5740\u533a\u95f4\u4e3a [sp, sp + 8x34] # \u6309\u7167TrapContext\u7684\u5185\u5b58\u5e03\u5c40 # pub struct TrapContext{ # pub x: [usize; 32], # pub sstatus: Sstatus, # pub sepc: usize, # \u57fa\u4e8e\u5185\u6838\u6808\u7684\u4f4d\u7f6e\uff08sp\u6240\u6307\u5730\u5740\uff09\u6765\u4ece\u4f4e\u5730\u5740\u5230\u9ad8\u5730\u5740\u5206\u522b\u6309\u987a\u5e8f\u653e\u7f6e x0~x31\u8fd9\u4e9b\u901a\u7528\u5bc4\u5b58\u5668\uff0c # \u6700\u540e\u662f sstatus \u548c sepc # \u56e0\u6b64\u901a\u7528\u5bc4\u5b58\u5668 xn \u5e94\u8be5\u88ab\u4fdd\u5b58\u5728\u5730\u5740\u533a\u95f4 [sp + 8n, sp + 8(n+1)] } csrr t0, sstatus csrr t1, sepc # \u6307\u4ee4 csrr rd, rs \u7684\u529f\u80fd\u5c31\u662f\u5c06 CSR \u7684\u503c\u8bfb\u5230\u5bc4\u5b58\u5668 rd \u4e2d\u3002 # \u8fd9\u91cc\u6211\u4eec\u4e0d\u7528\u62c5\u5fc3 t0 \u548c t1 \u88ab\u8986\u76d6\uff0c\u56e0\u4e3a\u5b83\u4eec\u521a\u521a\u5df2\u7ecf\u88ab\u4fdd\u5b58\u4e86 sd t0, 32*8(sp) sd t1, 33*8(sp) # \u56e0\u4e3a\u4e0d\u80fd\u76f4\u63a5 \u64cd\u4f5c csr # \u6211\u4eec\u5c06 CSR sstatus \u548c sepc \u7684\u503c\u5206\u522b\u8bfb\u5230\u5bc4\u5b58\u5668 t0 \u548c t1 \u4e2d\u7136\u540e\u4fdd\u5b58\u5230\u5185\u6838\u6808\u5bf9\u5e94\u7684\u4f4d\u7f6e\u4e0a csrr t2, sscratch sd t2, 2*8(sp) # \u9996\u5148\u5c06 sscratch \u7684\u503c\u8bfb\u5230\u5bc4\u5b58\u5668 t2 \u5e76\u4fdd\u5b58\u5230\u5185\u6838\u6808\u4e0a\uff0c # \u6ce8\u610f\uff1a sscratch \u7684\u503c\u662f\u8fdb\u5165 Trap \u4e4b\u524d\u7684 sp \u7684\u503c\uff0c\u6307\u5411\u7528\u6237\u6808\u3002\u800c\u73b0\u5728\u7684 sp \u5219\u6307\u5411\u5185\u6838\u6808 mv a0, sp # sp -> a0 # \u8ba9\u5bc4\u5b58\u5668 a0 \u6307\u5411\u5185\u6838\u6808\u7684\u6808\u6307\u9488\u4e5f\u5c31\u662f\u6211\u4eec\u521a\u521a\u4fdd\u5b58\u7684 Trap \u4e0a\u4e0b\u6587\u7684\u5730\u5740\uff0c # \u8fd9\u662f\u7531\u4e8e\u6211\u4eec\u63a5\u4e0b\u6765\u8981\u8c03\u7528 trap_handler \u8fdb\u884c Trap \u5904\u7406\uff0c\u5b83\u7684\u7b2c\u4e00\u4e2a\u53c2\u6570 cx \u7531\u8c03\u7528\u89c4\u8303\u8981\u4ece a0 \u4e2d\u83b7\u53d6\u3002 # \u800c Trap \u5904\u7406\u51fd\u6570 trap_handler \u9700\u8981 Trap \u4e0a\u4e0b\u6587\u7684\u539f\u56e0\u5728\u4e8e\uff1a\u5b83\u9700\u8981\u77e5\u9053\u5176\u4e2d\u67d0\u4e9b\u5bc4\u5b58\u5668\u7684\u503c\uff0c # \u6bd4\u5982\u5728\u7cfb\u7edf\u8c03\u7528\u7684\u65f6\u5019\u5e94\u7528\u7a0b\u5e8f\u4f20\u8fc7\u6765\u7684 syscall ID \u548c\u5bf9\u5e94\u53c2\u6570\u3002\u6211\u4eec\u4e0d\u80fd\u76f4\u63a5\u4f7f\u7528\u8fd9\u4e9b\u5bc4\u5b58\u5668\u73b0\u5728\u7684\u503c\uff0c # \u56e0\u4e3a\u5b83\u4eec\u53ef\u80fd\u5df2\u7ecf\u88ab\u4fee\u6539\u4e86\uff0c\u56e0\u6b64\u8981\u53bb\u5185\u6838\u6808\u4e0a\u627e\u5df2\u7ecf\u88ab\u4fdd\u5b58\u4e0b\u6765\u7684\u503c call trap_handler # \u8df3\u8f6c\u5230\u7528rust\u7f16\u5199\u7684 trap_handler \u51fd\u6570\u5b8c\u6210trap\u5206\u53d1\u53ca\u5904\u7406 # RISC-V \u4e2d\u8bfb\u5199 CSR \u7684\u6307\u4ee4\u662f\u4e00\u7c7b\u80fd\u4e0d\u4f1a\u88ab\u6253\u65ad\u5730\u5b8c\u6210\u591a\u4e2a\u8bfb\u5199\u64cd\u4f5c\u7684\u6307\u4ee4\u3002 # \u8fd9\u79cd\u4e0d\u4f1a\u88ab\u6253\u65ad\u5730\u5b8c\u6210\u591a\u4e2a\u64cd\u4f5c\u7684\u6307\u4ee4\u88ab\u79f0\u4e3a \u539f\u5b50\u6307\u4ee4 (Atomic Instruction) # RISC-V \u67b6\u6784\u4e2d\u5e38\u89c4\u7684\u6570\u636e\u5904\u7406\u548c\u8bbf\u5b58\u7c7b\u6307\u4ee4\u53ea\u80fd\u64cd\u4f5c\u901a\u7528\u5bc4\u5b58\u5668\u800c\u4e0d\u80fd\u64cd\u4f5c CSR \u3002 # \u56e0\u6b64\uff0c\u5f53\u60f3\u8981\u5bf9 CSR \u8fdb\u884c\u64cd\u4f5c\u65f6\uff0c\u9700\u8981\u5148\u4f7f\u7528\u8bfb\u53d6 CSR \u7684\u6307\u4ee4\u5c06 CSR \u8bfb\u5230\u4e00\u4e2a\u901a\u7528\u5bc4\u5b58\u5668\u4e2d\uff0c # \u800c\u540e\u64cd\u4f5c\u8be5\u901a\u7528\u5bc4\u5b58\u5668\uff0c\u6700\u540e\u518d\u4f7f\u7528\u5199\u5165 CSR \u7684\u6307\u4ee4\u5c06\u8be5\u901a\u7528\u5bc4\u5b58\u5668\u7684\u503c\u5199\u5165\u5230 CSR \u4e2d # trap_handler\u8fd4\u56de \u4f1a\u56de\u5230\u6b64\u5904 __restore: # \u4ece\u4fdd\u5b58\u7684\u5185\u6838\u6808\u4e0a\u7684trap\u4e0a\u4e0b\u6587\u6062\u590d\u5bc4\u5b58\u5668 mv sp, a0 # sp -> kernel stack, sscratch -> user stack ld t0, 32*8(sp) ld t1, 33*8(sp) ld t2, 2*8(sp) csrw sstatus, t0 csrw sepc, t1 csrw sscratch, t2 # CSR\u5bc4\u5b58\u5668\u4e0d\u80fd\u76f4\u63a5\u64cd\u4f5c\uff0c\u8981\u901a\u8fc7\u901a\u7528\u5bc4\u5b58\u5668\u4f5c\u4e3a\u5a92\u4ecb # \u5148\u6062\u590dCSR\uff0c \u518d\u6062\u590d\u901a\u7528\u5bc4\u5b58\u5668\uff0c \u8fd9\u6837\u4e0a\u9762\u4e0a\u4e2a\u4e34\u65f6\u5bc4\u5b58\u5668\u624d\u80fd\u88ab\u6b63\u786e\u6062\u590d ld x1, 1*8(sp) ld x3, 3*8(sp) .set n, 5 .rept 27 LOAD_GP %n .set n, n+1 .endr # sp -> kernel stack(\u8fd9\u662f\u4fdd\u5b58\u5185\u6838\u4e0a\u4e0b\u6587\u4e4b\u540e\u7684\u6808\uff0c \u5373 sp + \u5404\u4e2a\u5bc4\u5b58\u5668\u7684\u7a7a\u95f4), # sscratch -> user stack addi sp, sp, 34*8 # \u5728\u5185\u6838\u6808\u4e0a\u56de\u6536Trap\u4e0a\u4e0b\u6587\u6240\u5360\u7528\u7684\u5185\u5b58 # sp -> kernel stack(trap\u4e4b\u524d\u7684\u5185\u6838\u6808) csrrw sp, sscratch, sp # \u518d\u6b21\u4ea4\u6362sscratch \u548c sp # sp -> \u7528\u6237\u6808\u6808\u9876\uff0c sscratch -> \u4fdd\u5b58\u8fdb\u5165Trap\u4e4b\u524d\u7684\u72b6\u6001\u5e76\u6307\u5411\u5185\u6838\u6808\u6808\u9876 sret # \u6267\u884c sret \u4ece S \u7279\u6743\u7ea7\u5207\u6362\u5230 U \u7279\u6743\u7ea7 # \u56de\u5230\u5e94\u7528\u7a0b\u5e8f\u6267\u884c # sscratch CSR \u7684\u7528\u9014 # \u5728\u7279\u6743\u7ea7\u5207\u6362\u7684\u65f6\u5019\uff0c\u6211\u4eec\u9700\u8981\u5c06 Trap \u4e0a\u4e0b\u6587\u4fdd\u5b58\u5728\u5185\u6838\u6808\u4e0a\uff0c\u56e0\u6b64\u9700\u8981\u4e00\u4e2a\u5bc4\u5b58\u5668\u6682\u5b58\u5185\u6838\u6808\u5730\u5740\uff0c # \u5e76\u4ee5\u5b83\u4f5c\u4e3a\u57fa\u5730\u5740\u6307\u9488\u6765\u4f9d\u6b21\u4fdd\u5b58 Trap \u4e0a\u4e0b\u6587\u7684\u5185\u5bb9\u3002\u4f46\u662f\u6240\u6709\u7684\u901a\u7528\u5bc4\u5b58\u5668\u90fd\u4e0d\u80fd\u591f\u7528\u4f5c\u57fa\u5730\u5740\u6307\u9488\uff0c # \u56e0\u4e3a\u5b83\u4eec\u90fd\u9700\u8981\u88ab\u4fdd\u5b58\uff0c\u5982\u679c\u8986\u76d6\u6389\u5b83\u4eec\uff0c\u5c31\u4f1a\u5f71\u54cd\u540e\u7eed\u5e94\u7528\u63a7\u5236\u6d41\u7684\u6267\u884c\u3002 # \u4e8b\u5b9e\u4e0a\u6211\u4eec\u7f3a\u5c11\u4e86\u4e00\u4e2a\u91cd\u8981\u7684\u4e2d\u8f6c\u5bc4\u5b58\u5668\uff0c\u800c sscratch CSR \u6b63\u662f\u4e3a\u6b64\u800c\u751f\u3002\u4ece\u4e0a\u9762\u7684\u6c47\u7f16\u4ee3\u7801\u4e2d\u53ef\u4ee5\u770b\u51fa\uff0c # \u5728\u4fdd\u5b58 Trap \u4e0a\u4e0b\u6587\u7684\u65f6\u5019\uff0c\u5b83\u8d77\u5230\u4e86\u4e24\u4e2a\u4f5c\u7528\uff1a\u9996\u5148\u662f\u4fdd\u5b58\u4e86\u5185\u6838\u6808\u7684\u5730\u5740\uff0c # \u5176\u6b21\u5b83\u53ef\u4f5c\u4e3a\u4e00\u4e2a\u4e2d\u8f6c\u7ad9\u8ba9 sp \uff08\u76ee\u524d\u6307\u5411\u7684\u7528\u6237\u6808\u7684\u5730\u5740\uff09\u7684\u503c\u53ef\u4ee5\u6682\u65f6\u4fdd\u5b58\u5728 sscratch \u3002 # \u8fd9\u6837\u4ec5\u9700\u4e00\u6761 csrrw sp, sscratch, sp \u6307\u4ee4\uff08\u4ea4\u6362\u5bf9 sp \u548c sscratch \u4e24\u4e2a\u5bc4\u5b58\u5668\u5185\u5bb9\uff09 # \u5c31\u5b8c\u6210\u4e86\u4ece\u7528\u6237\u6808\u5230\u5185\u6838\u6808\u7684\u5207\u6362\uff0c\u8fd9\u662f\u4e00\u79cd\u6781\u5176\u7cbe\u5de7\u7684\u5b9e\u73b0\u3002 os/src/syscall/mod.rs const SYSCALL_WRITE: usize = 64; const SYSCALL_EXIT: usize = 93; mod fs; mod process; use fs::*; use process::*; // syscall \u51fd\u6570\u5e76\u4e0d\u4f1a\u5b9e\u9645\u5904\u7406\u7cfb\u7edf\u8c03\u7528\uff0c // \u800c\u53ea\u662f\u6839\u636e syscall ID \u5206\u53d1\u5230\u5177\u4f53\u7684\u5904\u7406\u51fd\u6570 pub fn syscall(syscall_id: usize, args: [usize; 3]) -> isize{ match syscall_id { SYSCALL_WRITE => sys_write(args[0], args[1] as *const u8, args[2]), // \u8fd9\u91cc \u53ea\u662f\u5c06\u4f20\u8fdb\u6765\u7684\u53c2\u6570 args \u8f6c\u5316\u6210\u80fd\u591f\u88ab\u5177\u4f53\u7684\u7cfb\u7edf\u8c03\u7528\u5904\u7406\u51fd\u6570\u63a5\u53d7\u7684\u7c7b\u578b SYSCALL_EXIT => sys_exit(args[0] as i32), _ => panic!(\"Unsupported syscall_id: {}\", syscall_id), } } os/src/syscall/fs.rs const FD_STDOUT: usize = 1; pub fn sys_write(fd: usize, buf: *const u8, len: usize) -> isize{ match fd{ FD_STDOUT => { let slice = unsafe{ core::slice::from_raw_parts(buf, len)}; let str = core::str::from_utf8(slice).unwrap(); print!(\"{}\", str); len as isize // sys_write \u6211\u4eec\u5c06\u4f20\u5165\u7684\u4f4d\u4e8e\u5e94\u7528\u7a0b\u5e8f\u5185\u7684\u7f13\u51b2\u533a\u7684\u5f00\u59cb\u5730\u5740\u548c\u957f\u5ea6\u8f6c\u5316\u4e3a\u4e00\u4e2a\u5b57\u7b26\u4e32 &str \uff0c // \u7136\u540e\u4f7f\u7528\u6279\u5904\u7406\u64cd\u4f5c\u7cfb\u7edf\u5df2\u7ecf\u5b9e\u73b0\u7684 print! \u5b8f\u6253\u5370\u51fa\u6765\u3002\u6ce8\u610f\u8fd9\u91cc\u6211\u4eec\u5e76\u6ca1\u6709\u68c0\u67e5\u4f20\u5165\u53c2\u6570\u7684\u5b89\u5168\u6027\uff0c // \u5373\u4f7f\u4f1a\u5728\u51fa\u9519\u4e25\u91cd\u7684\u65f6\u5019 panic\uff0c\u8fd8\u662f\u4f1a\u5b58\u5728\u5b89\u5168\u9690\u60a3\u3002\u8fd9\u91cc\u6211\u4eec\u51fa\u4e8e\u5b9e\u73b0\u65b9\u4fbf\u6682\u4e14\u4e0d\u505a\u4fee\u8865 }, _ => { panic!(\"Unsupported fd in sys_write!\"); } } } os/src/syscall/process.rs use crate::batch::run_next_app; pub fn sys_exit(xstate: i32) -> !{ println!(\"[kernel Application exited with code {}\", xstate); run_next_app() // sys_exit \u6253\u5370\u9000\u51fa\u7684\u5e94\u7528\u7a0b\u5e8f\u7684\u8fd4\u56de\u503c\u5e76\u540c\u6837\u8c03\u7528 run_next_app \u5207\u6362\u5230\u4e0b\u4e00\u4e2a\u5e94\u7528\u7a0b\u5e8f } os/Makefile #Building TARGET := riscv64gc-unknown-none-elf MODE := release KERNEL_ELF := target/$(TARGET)/$(MODE)/os KERNEL_BIN := $(KERNEL_ELF).bin DISASM_TMP := target/$(TARGET)/$(MODE)/asm #BOARD BOARD ?= qemu SBI ?= rustsbi BOOTLOADER := ../bootloader/$(SBI)-$(BOARD).bin K210_BOOTLOADER_SIZE := 131072 #KERNEL ENTRY ifeq ($(BOARD), qemu) KERNEL_ENTRY_PA := 0x80200000 else ifeq ($(BOARD), k210) KERNEL_ENTRY_PA := 0x80020000 endif #Run K210 K210-SERIALPORT = /dev/ttyUSB0 K210-BURNER = ../tools/kflash.py #Binutils OBJDUMP := rust-objdump --arch-name=riscv64 OBJCOPY := rust-objcopy --binary-architecture=riscv64 #Disassembly DISASM ?= -x build: env switch-check $(KERNEL_BIN) switch-check: ifeq ($(BOARD), qemu) (which last-qemu) || (rm -f last-k210 && touch last-qemu && make clean) else ifeq ($(BOARD), k210) (which last-k210) || (rm -f last-qemu && touch last-k210 && make clean) endif env: (rustup target list | grep \"riscv64gc-unknown-none-elf (installed)\") || rustup target add $(TARGET) cargo install cargo-binutils --vers =0.3.3 rustup component add rust-src rustup component add llvm-tools-preview $(KERNEL_BIN): kernel @$(OBJCOPY) $(KERNEL_ELF) --strip-all -O binary $@ kernel: @cd ../user && make build @echo Platform: $(BOARD) @cp src/linker-$(BOARD).ld src/linker.ld @cargo build --release @rm src/linker.ld clean: @cargo clean disasm: kernel @$(OBJDUMP) $(DISASM) $(KERNEL_ELF) | less disasm-vim: kernel @$(OBJDUMP) $(DISASM) $(KERNEL_ELF) > $(DISASM_TMP) @vim $(DISASM_TMP) @rm $(DISASM_TMP) run: run-inner run-inner: build ifeq ($(BOARD), qemu) @qemu-system-riscv64 \\ -machine virt \\ -nographic \\ -bios $(BOOTLOADER) \\ -device loader,file=$(KERNEL_BIN),addr=$(KERNEL_ENTRY_PA) else (which $(K210-BURNER)) || (cd .. && git clone https://github.com/sipeed/kflash.py.git && mv kflash.py tools) @cp $(BOOTLOADER) $(BOOTLOADER).copy @dd if=$(KERNEL_BIN) of=$(BOOTLOADER).copy bs=$(K210_BOOTLOADER_SIZE) seek=1 @mv $(BOOTLOADER).copy $(KERNEL_BIN) @sudo chmod 777 $(K210-SERIALPORT) python3 $(K210-BURNER) -p $(K210-SERIALPORT) -b 1500000 $(KERNEL_BIN) python3 -m serial.tools.miniterm --eol LF --dtr 0 --rts 0 --filter direct $(K210-SERIALPORT) 115200 endif debug: build @tmux new-session -d \\ \"qemu-system-riscv64 -machine virt -nographic -bios $(BOOTLOADER) -device loader,file=$(KERNEL_BIN),addr=$(KERNEL_ENTRY_PA) -s -S\" && \\ tmux split-window -h \"riscv64-unknown-elf-gdb -ex 'file $(KERNEL_ELF)' -ex 'set arch riscv64:riscv64' -ex 'target remote localhost:1234'\" && \\ tmux -2 attach-session -d .PHONY: build env kernel clean disasm disasm-vim run-inner switch-check user \u6587\u4ef6\u5939\u4e0b user/.cargo/config [build] target = \"riscv64gc-unknown-none-elf\" [target.riscv64gc-unknown-none-elf] rustflags = [ \"-Clink-args=-Tsrc/linker.ld\" ] user/Cargo.toml [package] name = \"user_lib\" version = \"0.1.0\" edition = \"2021\" # \u5c06\u5e93\u7684\u540d\u5b57\u8bbe\u7f6e\u4e3a\uff1a user_lib # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html [dependencies] riscv = { git = \"https://github.com/rcore-os/riscv\", features = [\"inline-asm\"] } user/src/linker.ld OUTPUT_ARCH(riscv) ENTRY(_start) # \u5728lib.rs \u4e2d\u5b9a\u4e49\u4e86\u7528\u6237\u5e93\u7684\u5165\u5e93\u70b9 _start # \u901a\u8fc7rust\u7684\u5b8f #[link_section = \".text.entry\"] # \u5c06_start\u7684\u90a3\u6bb5\u4ee3\u7801\u7f16\u8bd1\u540e\u7684\u6c47\u7f16\u4ee3\u7801\u653e\u5728\u4e00\u4e2a\u540d\u4e3a .text.entry \u7684\u6bb5\u4e2d BASE_ADDRESS = 0x80400000; # \u7a0b\u5e8f\u7684\u8d77\u59cb\u5730\u5740\u4e3a 0x80400000 SECTIONS{ . = BASE_ADDRESS; .text : { *(.text.entry) # \u5c06 _start \u6240\u5728\u7684 .text.entry \u6bb5\u653e\u5728\u6574\u4e2a\u7a0b\u5e8f\u7684\u5f00\u5934 # \u5373\u653e\u5728 0x80400000\u5904 *(.text .text.*) } .rodata : { *(.rodata .rodata.*) *(.srodata .srodata.*) } .data : { *(.data .data.*) *(.sdata .sdata.*) } .bss : { start_bss = .; *(.bss .bss.*) *(.sbss .sbss.*) end_bss = .; # \u8fdb\u5165\u7528\u6237\u5e93\u5165\u53e3\u4e4b\u540e\uff0c\u8981\u624b\u52a8\u6e05\u7a7a\u9700\u8981\u96f6\u521d\u59cb\u5316\u7684 .bss \u6bb5 # \u7531\u4e8e\u5185\u6838\u76ee\u524d\u8fd8\u6ca1\u6709\u8fd9\u4e2a\u80fd\u529b\uff0c\u53ea\u80fd\u5728\u7528\u6237\u5e93\u4e2d\u5b8c\u6210 # \u8fd9\u91cc\u7684start_bss \u3001 end_bss \u4fbf\u4e8e\u521d\u59cb\u5316 } /DISCARD/ : { *(.eh_frame) *(.debug*) } } user/src/syscall.rs // \u5728\u5b50\u6a21\u5757 syscall \u4e2d\u6211\u4eec\u4f5c\u4e3a\u5e94\u7528\u7a0b\u5e8f\u6765\u901a\u8fc7 ecall \u8c03\u7528\u6279\u5904\u7406\u7cfb\u7edf\u63d0\u4f9b\u7684\u63a5\u53e3\uff0c //\u7531\u4e8e\u5e94\u7528\u7a0b\u5e8f\u8fd0\u884c\u5728\u7528\u6237\u6001\uff08\u5373 U \u6a21\u5f0f\uff09\uff0c //ecall \u6307\u4ee4\u4f1a\u89e6\u53d1 \u540d\u4e3a Environment call from U-mode \u7684\u5f02\u5e38\uff0c //\u5e76 Trap \u8fdb\u5165 S \u6a21\u5f0f\u6267\u884c\u6279\u5904\u7406\u7cfb\u7edf\u9488\u5bf9\u8fd9\u4e2a\u5f02\u5e38\u7279\u522b\u63d0\u4f9b\u7684\u670d\u52a1\u4ee3\u7801 //\u6211\u4eec\u77e5\u9053\u7cfb\u7edf\u8c03\u7528\u5b9e\u9645\u4e0a\u662f\u6c47\u7f16\u6307\u4ee4\u7ea7\u7684\u4e8c\u8fdb\u5236\u63a5\u53e3\uff0c\u56e0\u6b64\u8fd9\u91cc\u7ed9\u51fa\u7684\u53ea\u662f\u4f7f\u7528 Rust \u8bed\u8a00\u63cf\u8ff0\u7684 API \u7248\u672c\u3002 //\u5728\u5b9e\u9645\u8c03\u7528\u7684\u65f6\u5019\uff0c\u6211\u4eec\u9700\u8981\u6309\u7167 RISC-V \u8c03\u7528\u89c4\u8303\uff08\u5373ABI\u683c\u5f0f\uff09\u5728\u5408\u9002\u7684\u5bc4\u5b58\u5668\u4e2d\u653e\u7f6e\u7cfb\u7edf\u8c03\u7528\u7684\u53c2\u6570\uff0c //\u7136\u540e\u6267\u884c ecall \u6307\u4ee4\u89e6\u53d1 Trap\u3002\u5728 Trap \u56de\u5230 U \u6a21\u5f0f\u7684\u5e94\u7528\u7a0b\u5e8f\u4ee3\u7801\u4e4b\u540e\uff0c //\u4f1a\u4ece ecall \u7684\u4e0b\u4e00\u6761\u6307\u4ee4\u7ee7\u7eed\u6267\u884c\uff0c\u540c\u65f6\u6211\u4eec\u80fd\u591f\u6309\u7167\u8c03\u7528\u89c4\u8303\u5728\u5408\u9002\u7684\u5bc4\u5b58\u5668\u4e2d\u8bfb\u53d6\u8fd4\u56de\u503c //\u5728 RISC-V \u8c03\u7528\u89c4\u8303\u4e2d\uff0c\u548c\u51fd\u6570\u8c03\u7528\u7684 ABI \u60c5\u5f62\u7c7b\u4f3c\uff0c\u7ea6\u5b9a\u5bc4\u5b58\u5668 a0~a6 \u4fdd\u5b58\u7cfb\u7edf\u8c03\u7528\u7684\u53c2\u6570\uff0c //a0~a1 \u4fdd\u5b58\u7cfb\u7edf\u8c03\u7528\u7684\u8fd4\u56de\u503c\u3002\u6709\u4e9b\u8bb8\u4e0d\u540c\u7684\u662f\u5bc4\u5b58\u5668 a7 \u7528\u6765\u4f20\u9012 syscall ID\uff0c //\u8fd9\u662f\u56e0\u4e3a\u6240\u6709\u7684 syscall \u90fd\u662f\u901a\u8fc7 ecall \u6307\u4ee4\u89e6\u53d1\u7684\uff0c //\u9664\u4e86\u5404\u8f93\u5165\u53c2\u6570\u4e4b\u5916\u6211\u4eec\u8fd8\u989d\u5916\u9700\u8981\u4e00\u4e2a\u5bc4\u5b58\u5668\u6765\u4fdd\u5b58\u8981\u8bf7\u6c42\u54ea\u4e2a\u7cfb\u7edf\u8c03\u7528\u3002 //\u7531\u4e8e\u8fd9\u8d85\u51fa\u4e86 Rust \u8bed\u8a00\u7684\u8868\u8fbe\u80fd\u529b\uff0c //\u6211\u4eec\u9700\u8981\u5728\u4ee3\u7801\u4e2d\u4f7f\u7528\u5185\u5d4c\u6c47\u7f16\u6765\u5b8c\u6210\u53c2\u6570/\u8fd4\u56de\u503c\u7ed1\u5b9a\u548c ecall \u6307\u4ee4\u7684\u63d2\u5165 use core::arch::asm; const SYSCALL_WRITE: usize = 64; const SYSCALL_EXIT: usize = 93; fn syscall(id: usize, args: [usize; 3]) -> isize{ let mut ret: isize; unsafe{ asm!( \"ecall\", inlateout(\"x10\") args[0] => ret, in(\"x11\") args[1], in(\"x12\") args[2], in(\"x17\") id ); } //\u5728\u7b2c\u4e00\u7ae0\u4e2d\uff0c\u6211\u4eec\u66fe\u7ecf\u4f7f\u7528 global_asm! \u5b8f\u6765\u5d4c\u5165\u5168\u5c40\u6c47\u7f16\u4ee3\u7801\uff0c //\u800c\u8fd9\u91cc\u7684 asm! \u5b8f\u53ef\u4ee5\u5c06\u6c47\u7f16\u4ee3\u7801\u5d4c\u5165\u5230\u5c40\u90e8\u7684\u51fd\u6570\u4e0a\u4e0b\u6587\u4e2d\u3002 //\u76f8\u6bd4 global_asm! \uff0c asm! \u5b8f\u53ef\u4ee5\u83b7\u53d6\u4e0a\u4e0b\u6587\u4e2d\u7684\u53d8\u91cf\u4fe1\u606f\u5e76\u5141\u8bb8\u5d4c\u5165\u7684\u6c47\u7f16\u4ee3\u7801\u5bf9\u8fd9\u4e9b\u53d8\u91cf\u8fdb\u884c\u64cd\u4f5c\u3002 //\u7531\u4e8e\u7f16\u8bd1\u5668\u7684\u80fd\u529b\u4e0d\u8db3\u4ee5\u5224\u5b9a\u63d2\u5165\u6c47\u7f16\u4ee3\u7801\u8fd9\u4e2a\u884c\u4e3a\u7684\u5b89\u5168\u6027\uff0c //\u6240\u4ee5\u6211\u4eec\u9700\u8981\u5c06\u5176\u5305\u88f9\u5728 unsafe \u5757\u4e2d\u81ea\u5df1\u6765\u5bf9\u5b83\u8d1f\u8d23 ret } // \u5c31\u662f\u8c03\u7528rustsbi\u63d0\u4f9b\u7684\u7cfb\u7edf\u8c03\u7528 pub fn sys_write(fd: usize, buffer: &[u8]) -> isize{ syscall(SYSCALL_WRITE, [fd, buffer.as_ptr() as usize, buffer.len()]) } pub fn sys_exit(exit_code: i32) -> isize { syscall(SYSCALL_EXIT, [exit_code as usize, 0, 0]) } //\u518d\u8fdb\u884c\u5c01\u88c5\uff0c\u4fbf\u4e8e\u5e94\u7528\u7a0b\u5e8f\u8c03\u7528 /* /// \u529f\u80fd\uff1a\u5c06\u5185\u5b58\u4e2d\u7f13\u51b2\u533a\u4e2d\u7684\u6570\u636e\u5199\u5165\u6587\u4ef6\u3002 /// \u53c2\u6570\uff1a`fd` \u8868\u793a\u5f85\u5199\u5165\u6587\u4ef6\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\uff1b /// `buf` \u8868\u793a\u5185\u5b58\u4e2d\u7f13\u51b2\u533a\u7684\u8d77\u59cb\u5730\u5740\uff1b /// `len` \u8868\u793a\u5185\u5b58\u4e2d\u7f13\u51b2\u533a\u7684\u957f\u5ea6\u3002 /// \u8fd4\u56de\u503c\uff1a\u8fd4\u56de\u6210\u529f\u5199\u5165\u7684\u957f\u5ea6\u3002 /// syscall ID\uff1a64 fn sys_write(fd: usize, buf: *const u8, len: usize) -> isize; /// \u529f\u80fd\uff1a\u9000\u51fa\u5e94\u7528\u7a0b\u5e8f\u5e76\u5c06\u8fd4\u56de\u503c\u544a\u77e5\u6279\u5904\u7406\u7cfb\u7edf\u3002 /// \u53c2\u6570\uff1a`xstate` \u8868\u793a\u5e94\u7528\u7a0b\u5e8f\u7684\u8fd4\u56de\u503c\u3002 /// \u8fd4\u56de\u503c\uff1a\u8be5\u7cfb\u7edf\u8c03\u7528\u4e0d\u5e94\u8be5\u8fd4\u56de\u3002 /// syscall ID\uff1a93 fn sys_exit(xstate: usize) -> !; */ user/src/console.rs use core::fmt::{self, Write}; use super::write; struct Stdout; const STDOUT: usize = 1; impl Write for Stdout{ fn write_str(&mut self, s: &str) -> fmt::Result{ write(STDOUT, s.as_bytes()); Ok(()) } //\u6211\u4eec\u628a console \u5b50\u6a21\u5757\u4e2d Stdout::write_str \u6539\u6210\u57fa\u4e8e write \u7684\u5b9e\u73b0\uff0c //\u4e14\u4f20\u5165\u7684 fd \u53c2\u6570\u8bbe\u7f6e\u4e3a 1\uff0c\u5b83\u4ee3\u8868\u6807\u51c6\u8f93\u51fa\uff0c \u4e5f\u5c31\u662f\u8f93\u51fa\u5230\u5c4f\u5e55 } pub fn print(args: fmt::Arguments){ Stdout.write_fmt(args).unwrap(); } #[macro_export] macro_rules! print{ ($fmt: literal $(, $($args: tt)+)?) => { $crate::console::print(format_args!($fmt $(, $($arg)+)?)); } } #[macro_export] macro_rules! println{ ($fmt: literal $(, $($arg: tt)+)?) => { $crate::console::print(format_args!(concat!($fmt, \"\\n\") $(, $($arg)+)?)); } } user/src/lang_items.rs use crate::println; #[panic_handler] fn panic_handler(panic_info: &core::panic::PanicInfo) -> ! { let err = panic_info.message().unwrap(); if let Some(location) = panic_info.location() { println!(\"Panicked at {}:{}, {}\", location.file(), location.line(), err); } else{ println!(\"Panicked: {}\", err); } loop {} } // \u9664\u4e86\u6ca1\u6709shutdown\uff0c\u6ca1\u6709\u672c\u8d28\u533a\u522b user/src/lib.rs #![no_std] #![feature(panic_info_message)] // \u4e3a\u4e86\u83b7\u53d6panic\u7684\u4fe1\u606f #![feature(linkage)] // \u4e3a\u4e86\u652f\u6301\u5f31\u8fde\u63a5 pub mod console; mod syscall; mod lang_items; #[no_mangle] #[link_section = \".text.entry\"] //\u4f7f\u7528 Rust \u7684\u5b8f\u5c06 _start \u8fd9\u6bb5\u4ee3\u7801\u7f16\u8bd1\u540e\u7684\u6c47\u7f16\u4ee3\u7801\u4e2d\u653e\u5728\u4e00\u4e2a\u540d\u4e3a .text.entry \u7684\u4ee3\u7801\u6bb5\u4e2d\uff0c //\u65b9\u4fbf\u6211\u4eec\u5728\u540e\u7eed\u94fe\u63a5\u7684\u65f6\u5019\u8c03\u6574\u5b83\u7684\u4f4d\u7f6e\u4f7f\u5f97\u5b83\u80fd\u591f\u4f5c\u4e3a\u7528\u6237\u5e93\u7684\u5165\u53e3 pub extern \"C\" fn _start() -> ! { clear_bss(); //\u624b\u52a8\u6e05\u7a7a\u9700\u8981\u96f6\u521d\u59cb\u5316\u7684 .bss \u6bb5 exit(main()); panic!(\"unreachable after sys_exit!\"); } //\u6211\u4eec\u4f7f\u7528 Rust \u7684\u5b8f\u5c06\u5176\u51fd\u6570\u7b26\u53f7 main \u6807\u5fd7\u4e3a\u5f31\u94fe\u63a5\u3002\u8fd9\u6837\u5728\u6700\u540e\u94fe\u63a5\u7684\u65f6\u5019\uff0c //\u867d\u7136\u5728 lib.rs \u548c bin \u76ee\u5f55\u4e0b\u7684\u67d0\u4e2a\u5e94\u7528\u7a0b\u5e8f\u90fd\u6709 main \u7b26\u53f7\uff0c //\u4f46\u7531\u4e8e lib.rs \u4e2d\u7684 main \u7b26\u53f7\u662f\u5f31\u94fe\u63a5\uff0c\u94fe\u63a5\u5668\u4f1a\u4f7f\u7528 bin \u76ee\u5f55\u4e0b\u7684\u5e94\u7528\u4e3b\u903b\u8f91\u4f5c\u4e3a main \u3002 //\u8fd9\u91cc\u6211\u4eec\u4e3b\u8981\u662f\u8fdb\u884c\u67d0\u79cd\u7a0b\u5ea6\u4e0a\u7684\u4fdd\u62a4\uff0c\u5982\u679c\u5728 bin \u76ee\u5f55\u4e0b\u627e\u4e0d\u5230\u4efb\u4f55 main \uff0c //\u90a3\u4e48\u7f16\u8bd1\u4e5f\u80fd\u591f\u901a\u8fc7\uff0c\u4f46\u4f1a\u5728\u8fd0\u884c\u65f6\u62a5\u9519\u3002 #[linkage = \"weak\"] #[no_mangle] fn main() -> i32 { panic!(\"Cannot find main\"); } fn clear_bss(){ extern \"C\" { fn start_bss(); fn end_bss(); } (start_bss as usize..end_bss as usize).for_each(|addr|{ unsafe{ (addr as *mut u8).write_volatile(0);} }); } use syscall::*; pub fn write(fd: usize, buf: &[u8]) -> isize {sys_write(fd, buf)} pub fn exit(exit_code: i32) -> isize {sys_exit(exit_code)} // \u8fdb\u4e00\u6b65\u5c01\u88c5\uff0c\u4ece\u800c\u66f4\u52a0\u63a5\u8fd1Linux\u7b49\u5e73\u53f0\u7684\u5b9e\u9645\u7cfb\u7edf\u8c03\u7528\u63a5\u53e3 user/src/bin/00hello_world.rs #![no_std] #![no_main] #[macro_use] extern crate user_lib; // \u5f15\u5165\u5916\u90e8\u5e93 // \u5e93\u540d \u4ee5Cargo\u3002toml \u6587\u4ef6\u89c4\u5b9a\u4e3a\u4e3b #[no_mangle] fn main() -> i32{ println!(\"Hello, world!\"); 0 } Hello, world! user/src/bin/01store_fault.rs #![no_std] #![no_main] #[macro_use] extern crate user_lib; #[no_mangle] fn main() -> i32{ println!(\"Into Test store_fault, we will insert an invalid store operation...\"); println!(\"Kernel should kill this application!\"); unsafe{(0x0 as *mut u8).write_volatile(0);} // \u8bbf\u95ee\u4e00\u4e2a\u975e\u6cd5\u7684\u7269\u7406\u5730\u5740 0 } Into Test store_fault, we will insert an invalid store operation... Kernel should kill this application! Segmentation fault (core dumped) user/src/bin/02priv_inst.rs #![no_std] #![no_main] #[macro_use] extern crate user_lib; use core::arch::asm; #[no_mangle] fn main() -> i32{ println!(\"Try to execute privileged instruction in U Mode\"); println!(\"Kernel should kill this application!\"); unsafe{ asm!(\"sret\"); // \u5728\u7528\u6237\u6001\u6267\u884c\u5185\u6838\u6001\u7684\u7279\u6743\u6307\u4ee4 sret } 0 } Try to execute privileged instruction in U Mode Kernel should kill this application! Illegal instruction (core dumped) user/src/bin/03priv_csr.rs #![no_std] #![no_main] #[macro_use] extern crate user_lib; use riscv::register::sstatus::{self, SPP}; #[no_mangle] fn main() -> i32{ println!(\"Try to access privileged CSR in U Mode\"); println!(\"Kernel should kill this application!\"); unsafe{ sstatus::set_spp(SPP::User); } // \u5728\u7528\u6237\u6001\u4fee\u6539\u5185\u6838\u6001CSR sstatus 0 } Try to access privileged CSR in U Mode Kernel should kill this application! Illegal instruction (core dumped) user/Makefile TARGET := riscv64gc-unknown-none-elf MODE := release APP_DIR := src/bin TARGET_DIR := target/$(TARGET)/$(MODE) # target/riscv64gc-unknown-none-elf APPS := $(wildcard $(APP_DIR)/*.rs) # src/bin/*.rs ELFS := $(patsubst $(APP_DIR)/%.rs, $(TARGET_DIR)/%, $(APPS)) # src/bin/*.rs target/riscv64gc-unknown-none-elf/*.rs BINS := $(patsubst $(APP_DIR)/%.rs, $(TARGET_DIR)/%.bin, $(APPS)) # src/bin/*.rs target/riscv64gc-unknown-none-elf/*.bin OBJDUMP := rust-objdump --arch-name=riscv64 OBJCOPY := rust-objcopy --binary-architecture=riscv64 elf: @cargo build --release @echo $(APPS) @echo $(ELFS) @echo $(BINS) binary: elf $(foreach elf, $(ELFS), $(OBJCOPY) $(elf) --strip-all -O binary $(patsubst $(TARGET_DIR)/%, $(TARGET_DIR)/%.bin, $(elf));) build: binary \u53bb\u6389\u5e93\u51fd\u6570\u7684\u5f15\u7528\u4f1a\u600e\u6837 \u8fdb\u5165entr.asm\uff0c\u8bbe\u7f6e\u51fd\u6570\u6808\uff0c\u8df3\u8f6c\u5230 rust_main \u6e05\u96f6\u9664.bss.stack\u4ee5\u5916\u7684.bss\u6bb5 \u8c03\u7528println! -> print -> Stdout.write_fmt \u8c03\u7528 painc! -> println! -> shutdown -> sbi_call(SBI_SHUTDOWN, 0, 0, 0) \u6267\u884c\u6d41\u7a0b os/src/main.rs \u5bfc\u5165 entry.asm \u8bbe\u7f6e\u51fd\u6570\u6808\uff0c \u8df3\u8f6c\u5230rust_main \u5bfc\u5165 link_app.S \u8fd9\u91cc\u5168\u662f\u6570\u636e\u6bb5\uff0c \u53ef\u6267\u884c\u6587\u4ef6\u5728\u90e8\u5206\u6570\u636e\u6bb5\u4e2d \u8c03\u7528 clear_bass \u51fd\u6570\uff0c \u6e05\u9664 \u9664 .bss.stack \u4ee5\u5916\u7684 .bss \u6bb5 \u8c03\u7528 println! \u6253\u5370 [kernel] Hello, world! , \u6b64\u65f6\u5904\u4e8e\u5185\u6838\u6001 \u8c03\u7528 trap::init os/src/trap/mod.rs \u6211\u4eec\u9700\u8981\u4fee\u6539stvec \u5bc4\u5b58\u5668\u6765\u6307\u5411\u6b63\u786e\u7684Trap\u5904\u7406\u5165\u53e3\u70b9 \u5c06stvec\u8bbe\u7f6e\u4e3aDirect\u6a21\u5f0f\u6307\u5411\u5b83\u7684\u5730\u5740 \u6ce8\u610f\uff1a\u7531\u4e8e\u524d\u9762\u6709\u5bfc\u5165 trap.S\uff0c \u6240\u6709\u8fd9\u91cc\u77e5\u9053 Trap\u7684\u5904\u7406\u5165\u53e3 \u5373 __alltraps os/src/main.rs \u8c03\u7528batch::init os/src/batch.rs lazy_static! \u5b8f\u63d0\u4f9b\u4e86\u5168\u5c40\u53d8\u91cf\u7684\u8fd0\u884c\u65f6\u521d\u59cb\u5316\u529f\u80fd\uff0c \u751f\u6210\u4e00\u4e2a AppManager \u7684\u5b9e\u4f8b APP_MANAGER \u627e\u5230 link_app.S \u4e2d\u63d0\u4f9b\u7684\u7b26\u53f7 _num_app \u5e76\u4ece\u8fd9\u91cc\u5f00\u59cb\u89e3\u6790\u51fa\u5e94\u7528\u6570\u91cf\u4ee5\u53ca\u5404\u4e2a\u5e94\u7528\u7684\u8d77\u59cb\u5730\u5740 \u8c03\u7528 print_app_info \u51fd\u6570 prin_app_info \u51fd\u6570\u8c03\u7528 APP_MANAGER \u5b9e\u4f8b\u7684 print_app_info \u51fd\u6570 \u6253\u5370\u51fa \u4efb\u52a1\u6570 \u548c \u6bcf\u4e2a\u4efb\u52a1\u7684\u5730\u5740\u533a\u95f4 os/src/main.rs \u8c03\u7528 batch::run_next_app os/src/batch.rs \u5bf9\u5168\u5c40\u53d8\u91cf APP_MANAGER \u8fdb\u884c\u64cd\u4f5c \u5c06\u5168\u5c40\u53d8\u91cf\u7684 APP_MANAGER \u7684\u6240\u6709\u6743 \u501f\u7ed9\u4e00\u4e2a \u53ef\u53d8\u53d8\u91cf \u8c03\u7528\u5b9e\u4f8b\u7684 get_current_app \u83b7\u53d6\u5f53\u524d\u662f \u7b2c\u51e0\u4e2a \u4efb\u52a1 \u8c03\u7528\u5b9e\u4f8b\u7684 load_app\u52a0\u8f7d\u5f53\u524d\u4efb\u52a1 load_app \u7684\u903b\u8f91 \u5982\u679c \u5f53\u524d\u4efb\u52a1\u7684\u7f16\u53f7 \u5927\u4e8e \u603b\u7684\u4efb\u52a1\u6570\uff0c\u76f4\u63a5 panic \uff0c \u800c panic \u4e2d\u4f1a\u8c03\u7528 shutdown\uff0c \u6240\u4ee5\u4f1a\u76f4\u63a5\u5173\u673a \u5982\u679c\u6ca1\u8d85\u8fc7\u4efb\u52a1\u6570\uff0c\u6253\u5370\u5f53\u524d\u4efb\u52a1\u7f16\u53f7 \u8c03\u7528\u6c47\u7f16\u6307\u4ee4 fence.i \u6765\u6e05\u7406 i-cache \u5c06\u52a0\u8f7d\u5e94\u7528\u7a0b\u5e8f\u7684\u5730\u5740 [0x80400000 ~ 0x80400000 + 0x20000] \u75280\u586b\u5145 \u4ece AppManger \u7684\u5b9e\u4f8b\u4e2d\u83b7\u53d6\u5f53\u524d\u4efb\u52a1\u7684 \u5730\u5740\u533a\u95f4 \u6b64\u65f6\u7684\u5730\u5740\u4e3a \u8ddf\u7740\u5185\u6838\u52a0\u8f7d\u5230\u7684 .data \u6bb5\u4e2d\u7684\u5730\u5740 \u751f\u6210\u5f85\u653e\u7f6e\u5e94\u7528\u7684 \u5730\u5740\u533a\u95f4 \uff0c\u5373 0x80400000 ~ 0x8040000 + len \u8c03\u7528 copy_from_slice , \u5c06\u5e94\u7528\u590d\u5236\u8fc7\u53bb \u8c03\u7528 AppManager \u5b9e\u4f8b\u7684 move_to_next_app \u51fd\u6570 \u5c31\u662f\u5c06\u5f53\u524d\u4efb\u52a1\u7684\u7f16\u53f7 + 1 \u8c03\u7528drop\u51fd\u6570\uff0c \u5373\u6790\u6784\u51fd\u6570\uff0c \u9500\u6bc1\u8fd9\u4e2a\u53ef\u53d8\u53d8\u91cf \u83b7\u53d6 __restore \u7684\u5730\u5740\uff0c __restore \u5728 Trap.S \u91cc \u5c06 __restore \u53d8\u6210\u4e00\u4e2a\u9700\u8981 \u4e00\u4e2a\u53c2\u6570 \u7684\u51fd\u6570 \u5728\u8fd9\u4e2a\u6587\u4ef6\u5f00\u5934\u5b9a\u4e49\u4e86\u4e24\u4e2a\u9759\u6001\u53d8\u91cf\uff0c \u4ed6\u4eec\u662f\u7ed3\u6784\u4f53\u7c7b\u578b\uff0c\u7ed3\u6784\u4f53\u90fd\u662f \u4e00\u4e2a u8 \u6570\u7ec4 \u521d\u59cb\u5316\u7684\u53c2\u6570\u4e3a 0 \u6570\u7ec4\uff0c\u7ed3\u6784\u4f53\u7684\u6570\u7ec4\u5927\u5c0f\u4e3a 4096 * 2 \u7528\u4e8e\u5b58\u653e trap \u7684\u4e0a\u4e0b\u6587 \u8c03\u7528 KERNEL_STACK \u8fd9\u4e2a KernelStack \u7ed3\u6784\u4f53\u7684\u5b9e\u4f8b \u7684\u51fd\u6570 push_context \u5c06\u83b7\u53d6\u5230\u7684 trap \u4e0a\u4e0b\u6587\u4f5c\u4e3a\u53c2\u6570 \u4f20\u5165 \u8fd4\u56de\u4e00\u4e2atrap\u4e0a\u4e0b\u6587 \u8c03\u7528 TrapContext \u7684 app_init_context \u4f20\u5165\u5e94\u7528\u7a0b\u5e8f\u7684\u5730\u5740 APP_BASE_ADDRESS \uff0c\u5373 0x80400000 \u4f20\u5165 \u7528\u6237\u6808 USER_STACK \u7684 sp\uff0c\u5373\u7528\u6237\u6808\u7684\u6808\u9876\uff0c USER_STACK \u662f\u4e00\u4e2a\u7528\u4e8e\u5b58\u653e trap\u4e0a\u4e0b\u6587\u7684 u8\u6570\u7ec4, \u7528\u4e8e\u5b58\u653e\u4e00\u4e2a\u7528\u6237\u6808 os/src/trap/context.rs \u8c03\u7528TrapContext \u7ed3\u6784\u7684 app_init_context \u65b9\u6cd5 app_init_context \u903b\u8f91 \u4f20\u5165 \u5165\u53e3\u5730\u5740\uff0c\u5373\u5e94\u7528\u7a0b\u5e8f\u7684\u5165\u53e3\u5730\u5740\uff0c 0x80400000 \u548c\u7528\u6237\u6808 \u7684 \u6808\u9876 sp \u6ce8\u610f\uff1a\u8fd9\u4e2a\u7528\u6237\u6808\u662f\u901a\u8fc7USER_STACK\u8fd9\u4e2a\u5b9e\u4f8b\u7684 get_sp \u65b9\u6cd5\u5f97\u5230\u7684 \u4f46\u8fd9\u4e2a\u65b9\u6cd5\u4e2d \u7684\u7528\u6237\u6808\u7684\u8d77\u59cb\u4f4d\u7f6e\u662f\u4e0d\u786e\u5b9a\u7684\uff0c\u6211\u4eec\u53ea\u80fd\u77e5\u9053\u6808\u7684\u5927\u5c0f \u6240\u4ee5\u7528\u6237\u6808\u7684\u5730\u5740\u662f\u52a8\u6001\u968f\u673a\u7684 \u83b7\u53d6 sstatus, \u5c06sstatus \u7684 SPP\u5b57\u6bb5 \u8bbe\u4e3a User \u521b\u5efa\u4e00\u4e2aTrapContext \u7684 \u7ed3\u6784 cx\uff0c \u5c0632 \u4e2a\u901a\u7528\u5bc4\u5b58\u5668\u7684\u503c \u7f6e0 \u5c06 \u521a\u521a\u83b7\u53d6\u5e76\u6539\u53d8SPP\u5b57\u6bb5\u7684 sstatus \u5bc4\u5b58\u5668 \u7684\u503c\u5199\u5165\u7ed3\u6784 cx \u7684sstatus\u4e2d \u5c06 sepc \u5b57\u6bb5 \u8bbe\u4e3a \u5e94\u7528\u7a0b\u5e8f\u7684\u5165\u53e3\u5730\u5740 \u5c06sp \u6539\u4e3a \u4f20\u5165\u7684\u5e94\u7528\u7a0b\u5e8f\u7684 \u7528\u6237\u6808\u6bb5 \u8fd4\u56de\u8fd9\u4e2a\u7ed3\u6784 cx\uff0c \u5373\u4e00\u4e2atrap\u4e0a\u4e0b\u6587\u7684\u7ed3\u6784 os/src/batch.rs \u83b7\u5f97\u8fd9\u4e2atrap\u4e0a\u4e0b\u6587\u7684\u7ed3\u6784\u540e\uff0c\u5c06\u5176\u4f20\u5165\u5230 push_context \u4e2d \u521b\u5efa\u4e00\u4e2a\u53ef\u53d8\u7684 TrapContext \u7ed3\u6784\u4f53\u7684\u6307\u9488 \u8fd9\u4e2a\u6307\u9488\u6307\u5411\u7684\u662f\u8ddd\u79bb\u5185\u6838\u6808\u6808\u9876\u4e00\u4e2aTrap\u4e0a\u4e0b\u6587\u5927\u5c0f\u7684 \u5730\u5740\u5904 \u5728\u8fd9\u4e2a\u5730\u5740\u5904\u5f00\u59cb\u5b58\u653e cx \u7684\u7ed3\u6784 \u6ce8\u610f\uff1ariscv\u4e2d\u6808\u662f\u5411\u4e0b\u589e\u957f\u7684 \u4f46\u5411\u6808\u4e2d\u5b58\u653e\u6570\u636e\u65f6\u662f\u4ecesp\u5904\u5f00\u59cb\u5411\u4e0a\u5b58\u653e\uff0c\u6211\u4eec\u6839\u636e\u8981\u5b58\u653e\u7684\u6570\u636e\u7684\u5927\u5c0f\u5c06sp\u5411\u4e0b\u79fb\u7684\uff0c\u6570\u636e\u4e0d\u4f1a\u8d8a\u754c \u76f8\u5f53\u4e8e\u5c06 \u8fd9\u4e2aTrap\u4e0a\u4e0b\u6587 push \u5230 \u5185\u6838\u6808 \u540c\u65f6\u8fd4\u56de\u8fd9\u4e2a\u5728\u6307\u9488\u7684 \u89e3\u5f15\u7528 \u5373\u6307\u9488\u6240\u6307\u7684\u5730\u5740\u7684\u503c\uff0c\u5373trap\u4e0a\u4e0b\u6587 \u7684\u5730\u5740\uff0c\u5c31\u662f\u5185\u6838\u6808\u7684\u79bb\u6808\u9876\u4e00\u4e2aTrapContext \u7ed3\u6784\u5927\u5c0f\u7684\u5730\u65b9 \u5c06\u8fd4\u56de\u5185\u6838\u6808\u7684\u79bb\u6808\u9876\u4e00\u4e2aTrapContext \u7ed3\u6784\u5927\u5c0f\u7684\u5730\u5740\u4f5c\u4e3a\u53c2\u6570\uff0c\u4f20\u9012\u7ed9 __restore \u51fd\u6570 \u6700\u7ec8\uff0c\u7528\u6237\u6808\u7684\u4e0a\u4e0b\u6587\u5b58\u653e\u5728\u5185\u6838\u6808\u4e2d os/src/trap.S \u4f20\u5165\u7684\u53c2\u6570 a0, \u5373 \u5185\u6838\u6808\u7684\u79bb\u6808\u9876\u4e00\u4e2aTrapContext \u7ed3\u6784\u5927\u5c0f\u7684\u5730\u5740 \u5c06\u8fd9\u4e2a\u5730\u5740\u4f20\u4e2a sp\uff0c sp -> \u5185\u6838\u6808\uff0c \u800c\u8fd9\u4e2a\u5185\u6838\u6808\u4e2d\u7684\u5185\u5bb9\u662f \u7528\u6237\u6808\u7684\u4e0a\u4e0b\u6587 \u9996\u5148\u6062\u590dsstatus, sepc \u548c sscratch \u5bc4\u5b58\u5668 \u5176\u5b9e\u4e5f\u4e0d\u53eb\u6062\u590d\uff0c\u800c\u662f\u5c06\u7528\u6237\u6808\u7684\u4e0a\u4e0b\u6587 \u7ed9 \u901a\u7528\u5bc4\u5b58\u5668 \u548c CSR \u5c06sp+34*8\uff0c\u5373pop\u5185\u6838\u6808\uff0c\u56de\u6536\u4e86\u5185\u6838\u4e0a\u5b58\u653e\u7684\u7528\u6237\u6808\u7684\u4e0a\u4e0b\u6587 \u5c06 sp -> user stack, sret, \u8df3\u8f6c\u5230\u7528\u6237\u6808\uff0c\u6267\u884c\u7528\u6237\u7a0b\u5e8f user/lib.rs \u518d\u8f6c\u5230\u7528\u6237\u7a0b\u5e8f\u7684\u903b\u8f91\u91cc rust \u7528cargo\u751f\u6210 --bin \u9879\u76ee\u53ea\u4f1a \u6709\u4e00\u4e2a\u53ef\u6267\u884c\u7a0b\u5e8f\u751f\u6210 \u5c31main.rs --lib \u9879\u76ee\uff0c\u53ea\u8981\u4e00\u4e2a\u6587\u4ef6\u4e2d\u6709\u4e14\u4ec5\u6709\u4e00\u4e2a main \u51fd\u6570\uff0c\u8fd9\u4e2a\u6587\u4ef6\u5c31\u53ef\u4ee5\u751f\u6210\u5bf9\u5e94\u7684\u53ef\u6267\u884c\u7a0b\u5e8f \u5728\u8fd9\u4e2auser\u9879\u76ee\u4e0b\uff0c\u6bcf\u4e2a\u5e94\u7528\u7a0b\u5e8f\u90fd\u5bfc\u5165\u4e86\u5916\u90e8\u94fe\u63a5\uff0c\u90a3\u5916\u90e8\u7684\u6574\u4e2a\u7a0b\u5e8f\u90fd\u4f1a\u88ab\u7f16\u8bd1\u5728\u4e00\u8d77 \u7531\u4e8e\u6211\u4eec\u6709linker.ld\u6587\u4ef6\uff0c\u800c\u4e14\u5c06 _start \u51fd\u6570\u5206\u914d\u5728 .text.entry \u6bb5\u4e2d\uff0c\u6240\u4ee5\u6bcf\u4e2a\u53ef\u6267\u884c\u6587\u4ef6\u4e2d\u8fd8\u662f\u4f1a\u5148\u8fd0\u884c _start \u51fd\u6570\uff0c\u5728 _start \u51fd\u6570\u4e2d\u8df3\u8f6c\u5230 main \u51fd\u6570\u4e2d \u6267\u884c _start \u51fd\u6570 \u8c03\u7528 clear_bss \u51fd\u6570\uff0c\u6ce8\u610f\uff0c\u6b64\u5904\u6ca1\u6709 .bss.stack \u6bb5 \u6240\u4ee5\u76f4\u63a5\u5c06\u6574\u4e2a .bss \u6bb5\u6e05\u96f6 \u5148\u6267\u884c main \u51fd\u6570 \u5c31\u4e00\u4e2a\u7b80\u5355\u7684\u6253\u5370 hello world, \u8fd4\u56de0 \u5c06main\u51fd\u6570\u7684\u8fd4\u56de\u503c\u4f5c\u4e3a\u53c2\u6570 \u4f20\u5165\u5230 exit\u51fd\u6570\u4e2d exit \u8c03\u7528 sys_exit user/syscall.rs sys_exit \u8c03\u7528 syscall syscall \u5c06 SYSCALL_EXIT \u548c main\u51fd\u6570\u8fd4\u56de\u503c0 \u4f5c\u4e3a\u53c2\u6570 \u8fdb\u884c trap \u9677\u5165\uff0c\u5373\u8c03\u7528 ecall os/src/trap/trap.S \u7531\u4e8e trap::init \u5c06 stvec \u6307\u5411\u4e86 __alltraps, \u90a3\u8fdb\u5165 __alltraps \u4e2d \u5c06\u5f53\u524d\u8fd9\u4e2a \u7528\u6237\u4e0a\u4e0b\u6587 \u5b58\u5165\u5230 \u5185\u6838\u6808\u4e0a \u5c06\u8fd9\u4e2a\u5185\u6838\u6808\u7684 \u6808\u6307\u9488\u5b58\u5165\u5230 a0 \u5bc4\u5b58\u5668\u4e2d \u8c03\u7528 trap_handler \u51fd\u6570 os/src/trap/mod.rs trap_handler \u51fd\u6570\u7684\u903b\u8f91 \u5c06 a0 \u5bc4\u5b58\u5668\u7684\u503c \u5373trap\u4e0a\u4e0b\u6587\u7684\u5730\u5740 \u4f5c\u4e3a\u53c2\u6570\u4f20\u5165 \u76f4\u63a5\u83b7\u53d6\u5f53\u524d scause \u548c stval \u4e24\u4e2a \u63a7\u5236\u5bc4\u5b58\u5668\u7684 \u503c \u7531\u4e8e\u521a\u624d\u53ea\u662f\u4fdd\u5b58 trap\u4e0a\u4e0b\u6587\uff0c \u6ca1\u6709\u6539\u53d8\u8fc7 scause \u548c stval , \u6240\u6709\u53ef\u4ee5\u76f4\u63a5\u4f7f\u7528 \u901a\u8fc7 scause.cause \u5224\u65ad trap\u7684\u539f\u56e0 \u7b2c\u4e00\u4e2a\u539f\u56e0\u662f\u7cfb\u7edf\u8c03\u7528 \u4e00\u4e2a\u7531 ecall \u6307\u4ee4\u89e6\u53d1\u7684\u7cfb\u7edf\u8c03\u7528\uff0c\u5728\u8fdb\u5165 Trap \u7684\u65f6\u5019\uff0c \u786c\u4ef6\u4f1a\u5c06 sepc \u8bbe\u7f6e\u4e3a\u8fd9\u6761 ecall \u6307\u4ee4\u6240\u5728\u7684\u5730\u5740 sepc + 4 \uff0c\u8ba9\u5176\u6307\u5411 ecall \u7684\u4e0b\u4e00\u6761\u6307\u4ee4 \uff08\u4e0d\u8fc7\u8fd9\u91cc\u662f\u4e0d\u4f1a\u6267\u884c\u5230 ecall\u7684\u4e0b\u4e00\u6761\u6307\u4ee4\u7684) \u6839\u636e \u4f20\u5165\u7684\u7cfb\u7edf\u8c03\u7528\u7684\u7c7b\u578b\u548c\u53c2\u6570\u503c(\u8fd9\u91cc\u4fdd\u5b58\u5728\u901a\u7528\u5bc4\u5b58\u5668\u4e2d)\u8fdb\u884c\u5185\u6838\u7684\u7cfb\u7edf\u8c03\u7528 os/src/syscall/mod.rs \u6839\u636e\u4f20\u5165\u7684\u7cfb\u7edf\u8c03\u7528\u7684 id \u548c \u53c2\u6570\u503c\uff0c\u8f6c\u5230\u5bf9\u5e94\u7684\u7cfb\u7edf\u8c03\u7528\u7684\u6267\u884c\u51fd\u6570\u4e2d os/src/syscall/process.rs \u6253\u5370\u9000\u51fa\u7801 \u8c03\u7528 run_next_app \u52a0\u8f7d\u7b2c\u4e8c\u4e2a\u5e94\u7528\u7a0b\u5e8f \u51fa\u73b0\u975e\u6cd5\u6307\u4ee4\uff0c \u8df3\u5230 __alltraps, \u4fdd\u5b58\u4e0a\u4e0b\u6587\uff0c call trap_handler trap_handler \u53d1\u73b0\u662f StoreFault \u6253\u5370 \u9519\u8bef\u539f\u56e0 \u8df3\u8f6c\u5230\u4e0b\u4e00\u4e2a \u5e94\u7528\u7a0b\u5e8f \u52a0\u8f7d\u7b2c\u4e09\u4e2a \u5e94\u7528\u7a0b\u5e8f \u6b63\u5e38\u6267\u884c\uff0c\u548c\u7b2c\u4e00\u4e2a\u4e00\u6837\u6b63\u5e38\u9000\u51fa \u52a0\u8f7d\u7b2c\u56db\u4e2a \u51fa\u73b0\u975e\u6cd5\u6307\u4ee4\uff0c \u6253\u5370\u9519\u8bef \u8df3\u8f6c\u5230\u4e0b\u4e00\u4e2a\u5e94\u7528\u7a0b\u5e8f \u52a0\u8f7d\u7b2c\u4e94\u4e2a \u51fa\u73b0\u975e\u6cd5\u6307\u4ee4\uff0c \u6253\u5370\u9519\u8bef \u8df3\u8f6c\u5230\u4e0b\u4e00\u4e2a\u5e94\u7528\u7a0b\u5e8f load_app \u65f6\u53d1\u73b0 app_id \u5df2\u7ecf\u5927\u4e8e num_app\uff0c \u76f4\u63a5\u8c03\u7528 panic \uff0c\u6253\u5370\u540e \u8c03\u7528 shutdown \u6b63\u5e38\u5173\u673a","title":"\u5b9e\u73b0\u6279\u5904\u7406\u64cd\u4f5c\u7cfb\u7edf"},{"location":"ch2%E5%AE%9E%E7%8E%B0%E6%89%B9%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#_1","text":"","title":"\u5b9e\u73b0\u6279\u5904\u7406\u64cd\u4f5c\u7cfb\u7edf"},{"location":"ch2%E5%AE%9E%E7%8E%B0%E6%89%B9%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#_2","text":"./os/src Rust 13 Files 372 Lines Assembly 2 Files 58 Lines \u251c\u2500\u2500 bootloader \u2502 \u251c\u2500\u2500 rustsbi-k210.bin \u2502 \u2514\u2500\u2500 rustsbi-qemu.bin \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 os \u2502 \u251c\u2500\u2500 build.rs(\u65b0\u589e\uff1a\u751f\u6210 link_app.S \u5c06\u5e94\u7528\u4f5c\u4e3a\u4e00\u4e2a\u6570\u636e\u6bb5\u94fe\u63a5\u5230\u5185\u6838) \u2502 \u251c\u2500\u2500 Cargo.toml \u2502 \u251c\u2500\u2500 Makefile(\u4fee\u6539\uff1a\u6784\u5efa\u5185\u6838\u4e4b\u524d\u5148\u6784\u5efa\u5e94\u7528) \u2502 \u2514\u2500\u2500 src \u2502 \u251c\u2500\u2500 batch.rs(\u65b0\u589e\uff1a\u5b9e\u73b0\u4e86\u4e00\u4e2a\u7b80\u5355\u7684\u6279\u5904\u7406\u7cfb\u7edf) \u2502 \u251c\u2500\u2500 console.rs \u2502 \u251c\u2500\u2500 entry.asm \u2502 \u251c\u2500\u2500 lang_items.rs \u2502 \u251c\u2500\u2500 link_app.S(\u6784\u5efa\u4ea7\u7269\uff0c\u7531 os/build.rs \u8f93\u51fa) \u2502 \u251c\u2500\u2500 linker-k210.ld \u2502 \u251c\u2500\u2500 linker-qemu.ld \u2502 \u251c\u2500\u2500 main.rs(\u4fee\u6539\uff1a\u4e3b\u51fd\u6570\u4e2d\u9700\u8981\u521d\u59cb\u5316 Trap \u5904\u7406\u5e76\u52a0\u8f7d\u548c\u6267\u884c\u5e94\u7528) \u2502 \u251c\u2500\u2500 sbi.rs \u2502 \u251c\u2500\u2500 sync(\u65b0\u589e\uff1a\u540c\u6b65\u5b50\u6a21\u5757 sync \uff0c\u76ee\u524d\u552f\u4e00\u529f\u80fd\u662f\u63d0\u4f9b UPSafeCell) \u2502 \u2502 \u251c\u2500\u2500 mod.rs \u2502 \u2502 \u2514\u2500\u2500 up.rs(\u5305\u542b UPSafeCell\uff0c\u5b83\u53ef\u4ee5\u5e2e\u52a9\u6211\u4eec\u4ee5\u66f4 Rust \u7684\u65b9\u5f0f\u4f7f\u7528\u5168\u5c40\u53d8\u91cf) \u2502 \u251c\u2500\u2500 syscall(\u65b0\u589e\uff1a\u7cfb\u7edf\u8c03\u7528\u5b50\u6a21\u5757 syscall) \u2502 \u2502 \u251c\u2500\u2500 fs.rs(\u5305\u542b\u6587\u4ef6 I/O \u76f8\u5173\u7684 syscall) \u2502 \u2502 \u251c\u2500\u2500 mod.rs(\u63d0\u4f9b syscall \u65b9\u6cd5\u6839\u636e syscall ID \u8fdb\u884c\u5206\u53d1\u5904\u7406) \u2502 \u2502 \u2514\u2500\u2500 process.rs(\u5305\u542b\u4efb\u52a1\u5904\u7406\u76f8\u5173\u7684 syscall) \u2502 \u2514\u2500\u2500 trap(\u65b0\u589e\uff1aTrap \u76f8\u5173\u5b50\u6a21\u5757 trap) \u2502 \u251c\u2500\u2500 context.rs(\u5305\u542b Trap \u4e0a\u4e0b\u6587 TrapContext) \u2502 \u251c\u2500\u2500 mod.rs(\u5305\u542b Trap \u5904\u7406\u5165\u53e3 trap_handler) \u2502 \u2514\u2500\u2500 trap.S(\u5305\u542b Trap \u4e0a\u4e0b\u6587\u4fdd\u5b58\u4e0e\u6062\u590d\u7684\u6c47\u7f16\u4ee3\u7801) \u251c\u2500\u2500 README.md \u251c\u2500\u2500 rust-toolchain \u251c\u2500\u2500 tools \u2502 \u251c\u2500\u2500 kflash.py \u2502 \u251c\u2500\u2500 LICENSE \u2502 \u251c\u2500\u2500 package.json \u2502 \u251c\u2500\u2500 README.rst \u2502 \u2514\u2500\u2500 setup.py \u2514\u2500\u2500 user(\u65b0\u589e\uff1a\u5e94\u7528\u6d4b\u4f8b\u4fdd\u5b58\u5728 user \u76ee\u5f55\u4e0b) \u251c\u2500\u2500 Cargo.toml \u251c\u2500\u2500 Makefile \u2514\u2500\u2500 src \u251c\u2500\u2500 bin(\u57fa\u4e8e\u7528\u6237\u5e93 user_lib \u5f00\u53d1\u7684\u5e94\u7528\uff0c\u6bcf\u4e2a\u5e94\u7528\u653e\u5728\u4e00\u4e2a\u6e90\u6587\u4ef6\u4e2d) \u2502 \u251c\u2500\u2500 00hello_world.rs \u2502 \u251c\u2500\u2500 01store_fault.rs \u2502 \u251c\u2500\u2500 02power.rs \u2502 \u251c\u2500\u2500 03priv_inst.rs \u2502 \u2514\u2500\u2500 04priv_csr.rs \u251c\u2500\u2500 console.rs \u251c\u2500\u2500 lang_items.rs \u251c\u2500\u2500 lib.rs(\u7528\u6237\u5e93 user_lib) \u251c\u2500\u2500 linker.ld(\u5e94\u7528\u7684\u94fe\u63a5\u811a\u672c) \u2514\u2500\u2500 syscall.rs(\u5305\u542b syscall \u65b9\u6cd5\u751f\u6210\u5b9e\u9645\u7528\u4e8e\u7cfb\u7edf\u8c03\u7528\u7684\u6c47\u7f16\u6307\u4ee4\uff0c \u5404\u4e2a\u5177\u4f53\u7684 syscall \u90fd\u662f\u901a\u8fc7 syscall \u6765\u5b9e\u73b0\u7684)","title":"\u7b2c\u4e8c\u7ae0\u4ee3\u7801\u6811"},{"location":"ch2%E5%AE%9E%E7%8E%B0%E6%89%B9%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#_3","text":"\u5728\u6279\u5904\u7406\u64cd\u4f5c\u7cfb\u7edf\u4e2d\uff0c\u6bcf\u5f53\u4e00\u4e2a\u5e94\u7528\u6267\u884c\u5b8c\u6bd5\uff0c\u6211\u4eec\u90fd\u9700\u8981\u5c06\u4e0b\u4e00\u4e2a\u8981\u6267\u884c\u7684\u5e94\u7528\u7684\u4ee3\u7801\u548c\u6570\u636e\u52a0\u8f7d\u5230\u5185\u5b58 \u5982\u4f55\u627e\u5230\u5e94\u7528\u6240\u5728\u7684\u4f4d\u7f6e \u6211\u4eec\u5c06\u591a\u4e2a\u5e94\u7528\u7a0b\u5e8f\u7684\u4ee3\u7801\u548c\u5185\u6838\u7684\u4ee3\u7801\u901a\u8fc7\u7f16\u7a0b\u6280\u5de7\u5c06\u5176 \u7ed1\u5b9a\u5728\u4e00\u8d77\uff0c\u662f\u4e00\u79cd\u9759\u6001\u7ed1\u5b9a \u57fa\u4e8e\u9759\u6001\u7f16\u7801\u7559\u4e0b\u7684\u7ed1\u5b9a\u4fe1\u606f\uff0c\u5185\u6838\u5c31\u53ef\u4ee5\u627e\u5230\u6bcf\u4e2a\u5e94\u7528\u7a0b\u5e8f\u6587\u4ef6\u4e8c\u8fdb\u5236\u4ee3\u7801\u7684\u8d77\u59cb\u5730\u5740\u548c\u957f\u5ea6\uff0c\u5e76\u52a0\u8f7d\u5230\u5185\u5b58\u4e2d\u8fd0\u884c","title":"\u672c\u8282\u7684\u4efb\u52a1"},{"location":"ch2%E5%AE%9E%E7%8E%B0%E6%89%B9%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#_4","text":"","title":"\u672c\u8282\u6587\u4ef6\u89e3\u6790"},{"location":"ch2%E5%AE%9E%E7%8E%B0%E6%89%B9%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#os","text":"","title":"os\u6587\u4ef6\u5939\u4e0b"},{"location":"ch2%E5%AE%9E%E7%8E%B0%E6%89%B9%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#oscargoconfig","text":"[build] target = \"riscv64gc-unknown-none-elf\" [target.riscv64gc-unknown-none-elf] rustflags = [ \"-Clink-arg=-Tsrc/linker.ld\",\"-Cforce-frame-pointers=yes\" ]","title":"os/.cargo/config"},{"location":"ch2%E5%AE%9E%E7%8E%B0%E6%89%B9%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#oscargotoml","text":"[package] name = \"os\" version = \"0.1.0\" edition = \"2021\" # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html [dependencies] riscv = {git = \"https://github.com/rcore-os/riscv\", features = [\"inline-asm\"]} # \u7528\u4e8e\u5f15\u7528 Rust \u7684 riscv \u5e93\uff0c\u65b9\u4fbf\u64cd\u4f5cCSR lazy_static = {version = \"1.4.0\", features = [\"spin_no_std\"]} # \u8c03\u7528\u5916\u90e8\u5e93 lazy_static \uff0c \u7528\u4e8e\u83b7\u53d6 lazy_static! \u5b8f","title":"os/Cargo.toml"},{"location":"ch2%E5%AE%9E%E7%8E%B0%E6%89%B9%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#ossrcentryasm","text":"# .section .text.entry # .global _start # _start: # li x1, 100 .section .text.entry .global _start _start: la sp, boot_stack_top call rust_main .section .bss.stack .global boot_stack boot_stack: .space 4096 * 16 .global boot_stack_top boot_stack_top:","title":"os/src/entry.asm"},{"location":"ch2%E5%AE%9E%E7%8E%B0%E6%89%B9%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#osbuildrs","text":"// \u7528\u4e8e\u751f\u6210 link_app.S use std::io::{Result, Write}; use std::fs::{File, read_dir}; fn main(){ println!(\"cargo:rerun-if-changed=../user/src/\"); println!(\"cargo:rerun-if-changed={}\", TARGET_PATH); insert_app_data().unwrap(); } static TARGET_PATH: &str = \"../user/target/riscv64gc-unknown-none-elf/release/\"; fn insert_app_data() -> Result<()> { let mut f = File::create(\"src/link_app.S\").unwrap(); // \u521b\u5efa link_app.S \u6587\u4ef6 let mut apps: Vec<_> = read_dir(\"../user/src/bin\") // \u8bfb\u53d6user/src/bin \u76ee\u5f55\u4e0b\u7684\u6587\u4ef6\uff0c \u83b7\u53d6\u6587\u4ef6\u540d .unwrap() .into_iter() .map(|dir_entry|{ let mut name_with_ext = dir_entry.unwrap().file_name().into_string().unwrap(); name_with_ext.drain(name_with_ext.find('.').unwrap()..name_with_ext.len()); name_with_ext }) .collect(); apps.sort(); // \u5c06\u6587\u4ef6\u6392\u5e8f writeln!(f, r#\" .align 3 .section .data .global _num_app _num_app: .quad {}\"#, apps.len())?; // \u5e94\u7528\u6587\u4ef6\u7684\u4e2a\u6570 for i in 0..apps.len() { writeln!(f, r#\" .quad app_{}_start\"#, i)?; } writeln!(f, r#\" .quad app_{}_end\"#, apps.len() - 1)?; for (idx, app) in apps.iter().enumerate(){ println!(\"app_{}: {}\", idx, app); writeln!(f, r#\" .section .data .global app_{0}_start .global app_{0}_end app_{0}_start: .incbin \"{2}{1}.bin\" app_{0}_end:\"#, idx, app, TARGET_PATH)?; } // \u5faa\u73af\uff0c\u5c06\u5e94\u7528\u90fd\u653e\u5728 .data\u6bb5\u4e2d\uff0c\u5e76\u83b7\u53d6\u5176 \u5f00\u59cb\u5730\u5740\u548c\u7ed3\u675f\u5730\u5740 // \u6309\u683c\u5f0f\u751f\u6210 link_app.S Ok(()) }","title":"os/build.rs"},{"location":"ch2%E5%AE%9E%E7%8E%B0%E6%89%B9%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#ossrclink_apps","text":"#\u5b83\u4e00\u5f00\u59cb\u5e76\u4e0d\u5b58\u5728\uff0c\u800c\u662f\u5728\u6784\u5efa\u64cd\u4f5c\u7cfb\u7edf\u65f6\u81ea\u52a8\u751f\u6210\u7684\u3002\u5f53\u6211\u4eec\u4f7f\u7528 make run \u8ba9\u7cfb\u7edf\u8fd0\u884c\u7684\u8fc7\u7a0b\u4e2d\uff0c\u8fd9\u4e2a\u6c47\u7f16\u4ee3\u7801 link_app.S \u5c31\u751f\u6210\u4e86 .align 3 .section .data .global _num_app _num_app: # .quad \u7528\u4e8e\u5b9a\u4e49\u4e00\u4e2a 64\u4f4d\u7684\u6570\u636e .quad 5 .quad app_0_start .quad app_1_start .quad app_2_start .quad app_3_start .quad app_4_start .quad app_4_end .section .data .global app_0_start .global app_0_end app_0_start: .incbin \"../user/target/riscv64gc-unknown-none-elf/release/00hello_world.bin\" app_0_end: .section .data .global app_1_start .global app_1_end app_1_start: .incbin \"../user/target/riscv64gc-unknown-none-elf/release/01store_fault.bin\" # \u524d\u9762\u6211\u4eec\u4eceELF\u683c\u5f0f\u53ef\u6267\u884c\u6587\u4ef6\u5265\u79bb\u5143\u6570\u636e\u540e\u653e\u5165\u5230\u4e8c\u8fdb\u5236\u955c\u50cf\u6587\u4ef6\u4e2d # \u8fd9\u91cc\u76f4\u63a5\u5c06 \u8fd9\u4e2a\u955c\u50cf\u6587\u4ef6 \u653e\u5728\u5185\u6838\u7684\u6570\u636e\u6bb5 \u94fe\u63a5\u5230\u5185\u6838\u4e2d app_1_end: .section .data .global app_2_start .global app_2_end app_2_start: .incbin \"../user/target/riscv64gc-unknown-none-elf/release/02power.bin\" app_2_end: .section .data .global app_3_start .global app_3_end app_3_start: .incbin \"../user/target/riscv64gc-unknown-none-elf/release/03priv_inst.bin\" app_3_end: .section .data .global app_4_start .global app_4_end app_4_start: .incbin \"../user/target/riscv64gc-unknown-none-elf/release/04priv_csr.bin\" app_4_end:","title":"os/src/link_app.S"},{"location":"ch2%E5%AE%9E%E7%8E%B0%E6%89%B9%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#srcsyncuprs","text":"use core::cell::{RefCell, RefMut}; pub struct UPSafeCell<T>{ inner: RefCell<T>, } unsafe impl<T> Sync for UPSafeCell<T> {} impl<T> UPSafeCell<T> { pub unsafe fn new(value: T) -> Self{ Self{ inner: RefCell::new(value)} } pub fn exclusive_access(&self) -> RefMut<'_, T> { self.inner.borrow_mut() } } // \u5173\u4e8e\u6240\u6709\u6743 \u548c \u5b89\u5168 \u76f8\u5173\u7684rust\u7f16\u7a0b\u6280\u5de7\uff0c \u540e\u9762\u518d\u5173\u6ce8","title":"src/sync/up.rs"},{"location":"ch2%E5%AE%9E%E7%8E%B0%E6%89%B9%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#ossrcsyncmodrs","text":"mod up; pub use up::UPSafeCell;","title":"os/src/sync/mod.rs"},{"location":"ch2%E5%AE%9E%E7%8E%B0%E6%89%B9%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#ossrcbatchrs","text":"// \u672c\u8282\u7684\u6838\u5fc3\u4ee3\u7801 use lazy_static::*; use crate::trap::TrapContext; use crate::sync::UPSafeCell; use core::arch::asm; const USER_STACK_SIZE: usize = 4096 * 2; const KERNEL_STACK_SIZE: usize = 4096 * 2; // \u5e38\u6570\u6307\u51fa \u5185\u6838\u6808\u548c\u7528\u6237\u6808\u7684\u5927\u5c0f \u5206\u522b\u4e3a8KB // \u4ee5\u5168\u5c40\u53d8\u91cf\u7684\u5f62\u5f0f\u5b9e\u4f8b\u5316\u5728\u64cd\u4f5c\u7cfb\u7edf\u7684 .bss \u6bb5\u4e2d const MAX_APP_NUM: usize = 16; const APP_BASE__ADDRESS: usize = 0x80400000; const APP_SIZE_LIMIT: usize = 0x20000; #[repr(align(4096))] struct KernelStack{ data: [u8; KERNEL_STACK_SIZE], } #[repr(align(4096))] struct UserStack{ data: [u8; USER_STACK_SIZE], } // \u8868\u793a\u7528\u6237\u6808\u548c\u5185\u6838\u6808\uff0c\u90fd\u662f\u5b57\u8282\u6570\u7ec4\u7684\u7b80\u5355\u5305\u88c5 // \u7528\u4e8e\u4fdd\u5b58\u5728trap\u53d1\u751f\u524d \u539f\u63a7\u5236\u6d41\u7684\u5bc4\u5b58\u5668\u72b6\u6001 static KERNEL_STACK: KernelStack = KernelStack {data: [0; KERNEL_STACK_SIZE]}; static USER_STACK: UserStack = UserStack { data: [0; USER_STACK_SIZE]}; impl KernelStack{ fn get_sp(&self) -> usize{ self.data.as_ptr() as usize + KERNEL_STACK_SIZE // .as_ptr \u83b7\u53d6\u5b57\u7b26\u4e32\u5b57\u9762\u91cf\u7684\u5730\u5740 } pub fn push_context(&self, cx: TrapContext) -> &'static mut TrapContext { let cx_ptr = (self.get_sp() - core::mem::size_of::<TrapContext>()) as *mut TrapContext; unsafe { *cx_ptr = cx;} unsafe { cx_ptr.as_mut().unwrap() } } } impl UserStack { fn get_sp(&self) -> usize { self.data.as_ptr() as usize + USER_STACK_SIZE } } // \u5b9e\u73b0 get_sp \u65b9\u6cd5 \u6765\u83b7\u53d6\u6808\u9876\u5730\u5740 // \u7531\u4e8e\u5728RISCV\u4e2d\u6808\u662f\u5411\u4e0b\u589e\u957f\u7684\uff0c\u53ea\u9700\u8fd4\u56de\u5305\u88f9\u7684\u6570\u7ec4\u7684\u7ed3\u5c3e\u5730\u5740 // \u7528\u6237\u6808\u548c\u5185\u6838\u6808\u7684\u5207\u6362\uff0c \u53ea\u9700\u8981\u5c06 sp \u5bc4\u5b58\u5668\u7684\u503c\u4fee\u6539\u4e3a get_sp \u7684\u8fd4\u56de\u503c\u5373\u53ef // \u5e94\u7528\u7ba1\u7406\u5668 \u672c\u8282\u7684\u6838\u5fc3\u7ec4\u4ef6 // \u80fd\u591f\u627e\u5230\u5e76\u52a0\u8f7d\u5e94\u7528\u7a0b\u5e8f\u4e8c\u8fdb\u5236\u7801 struct AppManager{ num_app: usize, // \u4fdd\u5b58\u5e94\u7528\u6570\u91cf current_app: usize, // \u5f53\u524d\u6267\u884c\u5230\u4e86\u7b2c\u51e0\u4e2a\u5e94\u7528 app_start: [usize; MAX_APP_NUM+1], // \u4fdd\u5b58\u5e94\u7528\u7684\u5404\u81ea\u7684\u4f4d\u7f6e } // \u6839\u636e\u5e94\u7528\u7a0b\u5e8f\u4f4d\u7f6e\u4fe1\u606f\uff0c\u521d\u59cb\u5316\u597d\u5e94\u7528\u6240\u9700\u5185\u5b58\u7a7a\u95f4\uff0c\u5e76\u52a0\u8f7d\u5e94\u7528\u6267\u884c impl AppManager { pub fn print_app_info(&self){ println!(\"[kernel] num_app = {}\", self.num_app); for i in 0..self.num_app { println!(\"[kernel] app_{} [{:#x}, {:#x})\", i, self.app_start[i], self.app_start[i+1]); } } unsafe fn load_app(&self, app_id: usize){ if app_id >= self.num_app{ panic!(\"All applications completed!\"); } println!(\"[kernel] Loading app_{}\", app_id); asm!(\"fence.i\"); // \u6c47\u7f16\u6307\u4ee4 fence.i \u662f\u7528\u6765\u6e05\u7406 i-cache \u7684 // \u901a\u5e38\u60c5\u51b5\u4e0b\uff0c CPU \u4f1a\u8ba4\u4e3a\u7a0b\u5e8f\u7684\u4ee3\u7801\u6bb5\u4e0d\u4f1a\u53d1\u751f\u53d8\u5316\uff0c\u56e0\u6b64 i-cache \u662f\u4e00\u79cd\u53ea\u8bfb\u7f13\u5b58\u3002 //\u4f46\u5728\u8fd9\u91cc\uff0c\u6211\u4eec\u5c06\u4fee\u6539\u4f1a\u88ab CPU \u53d6\u6307\u7684\u5185\u5b58\u533a\u57df\uff0c\u8fd9\u4f1a\u4f7f\u5f97 i-cache \u4e2d\u542b\u6709\u4e0e\u5185\u5b58\u4e2d\u4e0d\u4e00\u81f4\u7684\u5185\u5bb9\u3002 //\u56e0\u6b64\u6211\u4eec\u8fd9\u91cc\u5fc5\u987b\u4f7f\u7528 fence.i \u6307\u4ee4\u624b\u52a8\u6e05\u7a7a i-cache \uff0c\u8ba9\u91cc\u9762\u6240\u6709\u7684\u5185\u5bb9\u5168\u90e8\u5931\u6548\uff0c //\u624d\u80fd\u591f\u4fdd\u8bc1CPU\u8bbf\u95ee\u5185\u5b58\u6570\u636e\u548c\u4ee3\u7801\u7684\u6b63\u786e\u6027 core::slice::from_raw_parts_mut( APP_BASE__ADDRESS as *mut u8, APP_SIZE_LIMIT ).fill(0); let app_src = core::slice::from_raw_parts( self.app_start[app_id] as *const u8, self.app_start[app_id + 1] - self.app_start[app_id] ); let app_dst = core::slice::from_raw_parts_mut( APP_BASE__ADDRESS as *mut u8, app_src.len() ); app_dst.copy_from_slice(app_src); } pub fn get_current_app(&self) -> usize {self.current_app} pub fn move_to_next_app(&mut self){ self.current_app += 1; } } // \u4f7f\u7528 lazy_static! \u5b8f // lazy_static! \u5b8f\u63d0\u4f9b\u4e86\u5168\u5c40\u53d8\u91cf\u7684\u8fd0\u884c\u65f6\u521d\u59cb\u5316\u529f\u80fd // \u6709\u5173\u5b8f\u7684\u5177\u4f53\u7ec6\u8282\uff0c \u540e\u9762\u518d\u4e86\u89e3 lazy_static! { // \u9759\u6001\u751f\u6210\u4e00\u4e2a\u5168\u5c40\u7684 AppManager \u7684\u4e00\u4e2a\u5b9e\u4f8b APP_MANAGER static ref APP_MANAGER: UPSafeCell<AppManager> = unsafe {UPSafeCell::new({ extern \"C\" {fn _num_app();} // \u627e\u5230 link_app.S \u4e2d\u63d0\u4f9b\u7684\u7b26\u53f7 _num_app // \u5e76\u4ece\u8fd9\u91cc\u5f00\u59cb\u89e3\u6790\u51fa\u5e94\u7528\u6570\u91cf\u4ee5\u53ca\u5404\u4e2a\u5e94\u7528\u7684\u8d77\u59cb\u5730\u5740 // link_app.S \u4e2d\u83b7\u53d6 _num_app \u7684\u5730\u5740\uff0c\u4ece\u800c\u53ef\u4ee5\u89e3\u6790\u51fa // _num_app: // .quad 5 // .quad app_0_start // .quad app_1_start // .quad app_2_start // .quad app_3_start // .quad app_4_start // .quad app_4_end let num_app_ptr = _num_app as usize as *const usize; let num_app = num_app_ptr.read_volatile(); let mut app_start: [usize; MAX_APP_NUM + 1] = [0; MAX_APP_NUM + 1]; let app_start_raw: &[usize] = core::slice::from_raw_parts( num_app_ptr.add(1), num_app + 1 ); app_start[..=num_app].copy_from_slice(app_start_raw); AppManager { num_app, current_app: 0, app_start, } // \u521d\u59cb\u5316 AppManager \u7684\u5168\u5c40\u5b9e\u4f8b APP_MANAGER })}; } // batch \u5b50\u6a21\u5757\u5bf9\u5916\u66b4\u9732\u7684\u63a5\u53e3\u5982\u4e0b pub fn init() { print_app_info(); } // \u8c03\u7528 print_app_info \u7684\u65f6\u5019\u7b2c\u4e00\u6b21\u7528\u5230\u4e86\u5168\u5c40\u53d8\u91cf APP_MANAGER \uff0c //\u5b83\u4e5f\u662f\u5728\u8fd9\u4e2a\u65f6\u5019\u5b8c\u6210\u521d\u59cb\u5316 pub fn print_app_info() { APP_MANAGER.exclusive_access().print_app_info(); // exclusive_access \u662f os/src/sync/up.rs \u6a21\u5757\u63d0\u4f9b\u7684\u7528\u4e8e\u5185\u5b58\u5b89\u5168\u7684\u4e00\u79cd\u51fd\u6570 } pub fn run_next_app() -> ! { let mut app_manager = APP_MANAGER.exclusive_access(); let current_app = app_manager.get_current_app(); unsafe { app_manager.load_app(current_app); } app_manager.move_to_next_app(); drop(app_manager); extern \"C\" {fn __restore(cx_addr: usize);} unsafe { __restore(KERNEL_STACK.push_context( TrapContext::app_init_context(APP_BASE__ADDRESS, USER_STACK.get_sp()) ) as *const _ as usize); // \u5728\u5185\u6838\u6808\u4e0a\u538b\u5165\u4e00\u4e2atrap \u4e0a\u4e0b\u6587 // sepc \u662f\u5e94\u7528\u7a0b\u5e8f\u5165\u53e3\u5730\u5740 0x80400000 // sp \u5bc4\u5b58\u5668\u6307\u5411\u7528\u6237\u6808 // sstatus \u7684 SPP \u5b57\u6bb5\u88ab\u8bbe\u7f6e\u4e3a User // push_context \u7684\u8fd4\u56de\u503c\u662f \u5185\u6838\u6808\u538b\u5165 Trap \u4e0a\u4e0b\u6587\u4e4b\u540e\u7684\u6808\u9876 // \u5b83\u88ab\u4f5c\u4e3a __restore \u7684\u53c2\u6570\uff0c \u8fd9\u4f7f\u5f97 __restore \u51fd\u6570\u4e2d sp \u4ecd\u7136\u53ef\u4ee5\u6307\u5411\u5185\u6838\u6808\u7684\u6808\u9876 // \u8fd9\u4e4b\u540e\u5c31\u548c\u6267\u884c\u4e00\u6b21\u666e\u901a\u7684 __restore \u51fd\u6570\u8c03\u7528\u4e00\u6837\u4e86 } panic!(\"Unreachable in batch::run_current_app!\"); // \u8fd9\u4e2a\u4e0d\u4f1a\u88ab\u89e6\u53d1\uff0c\u5728\u6b64\u4e4b\u524d\u4f1a\u6709\u4e00\u4e2apanic\uff0c\u5c31\u76f4\u63a5 shutdown\u4e86 } // \u6279\u5904\u7406\u64cd\u4f5c\u7cfb\u7edf\u7684\u6838\u5fc3\u64cd\u4f5c\uff0c\u5373\u52a0\u8f7d\u5e76\u8fd0\u884c\u4e0b\u4e00\u4e2a\u5e94\u7528\u7a0b\u5e8f\u3002 // \u5f53\u6279\u5904\u7406\u64cd\u4f5c\u7cfb\u7edf\u5b8c\u6210\u521d\u59cb\u5316\u6216\u8005\u4e00\u4e2a\u5e94\u7528\u7a0b\u5e8f\u8fd0\u884c\u7ed3\u675f\u6216\u51fa\u9519\u4e4b\u540e\u4f1a\u8c03\u7528\u8be5\u51fd\u6570","title":"os/src/batch.rs"},{"location":"ch2%E5%AE%9E%E7%8E%B0%E6%89%B9%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#ossrctrapcontextrs","text":"use riscv::register::sstatus::{Sstatus, self, SPP}; // Trap \u4e0a\u4e0b\u6587\uff0c\u7c7b\u4f3c\u51fd\u6570\u8c03\u7528\u4e0a\u4e0b\u6587\uff0c // \u5373\u5728Trap\u53d1\u751f\u65f6\u9700\u8981\u4fdd\u5b58\u7684\u7269\u7406\u8d44\u6e90\u5185\u5bb9 #[repr(C)] pub struct TrapContext{ pub x: [usize; 32], // \u6240\u6709\u901a\u7528\u5bc4\u5b58\u5668 // \u627e\u51fa\u54ea\u4e9b\u5bc4\u5b58\u5668\u65e0\u9700\u4fdd\u5b58\u5f88\u96be\uff0c\u751a\u81f3\u4e0d\u53ef\u80fd\uff0c\u90a3\u5c31\u76f4\u63a5\u5168\u90e8\u4fdd\u5b58 pub sstatus: Sstatus, pub sepc: usize, // \u5bf9\u4e8e CSR \u800c\u8a00\uff0c\u6211\u4eec\u77e5\u9053\u8fdb\u5165 Trap \u7684\u65f6\u5019\uff0c //\u786c\u4ef6\u4f1a\u7acb\u5373\u8986\u76d6\u6389 scause/stval/sstatus/sepc \u7684\u5168\u90e8\u6216\u662f\u5176\u4e2d\u4e00\u90e8\u5206\u3002scause/stval \u7684\u60c5\u51b5\u662f\uff1a //\u5b83\u603b\u662f\u5728 Trap \u5904\u7406\u7684\u7b2c\u4e00\u65f6\u95f4\u5c31\u88ab\u4f7f\u7528\u6216\u8005\u662f\u5728\u5176\u4ed6\u5730\u65b9\u4fdd\u5b58\u4e0b\u6765\u4e86\uff0c\u56e0\u6b64\u5b83\u6ca1\u6709\u88ab\u4fee\u6539\u5e76\u9020\u6210\u4e0d\u826f\u5f71\u54cd\u7684\u98ce\u9669\u3002 //\u800c\u5bf9\u4e8e sstatus/sepc \u800c\u8a00\uff0c\u5b83\u4eec\u4f1a\u5728 Trap \u5904\u7406\u7684\u5168\u7a0b\u6709\u610f\u4e49\uff08\u5728 Trap \u63a7\u5236\u6d41\u6700\u540e sret \u7684\u65f6\u5019\u8fd8\u7528\u5230\u4e86\u5b83\u4eec\uff09\uff0c //\u800c\u4e14\u786e\u5b9e\u4f1a\u51fa\u73b0 Trap \u5d4c\u5957\u7684\u60c5\u51b5\u4f7f\u5f97\u5b83\u4eec\u7684\u503c\u88ab\u8986\u76d6\u6389\u3002 //\u6240\u4ee5\u6211\u4eec\u9700\u8981\u5c06\u5b83\u4eec\u4e5f\u4e00\u8d77\u4fdd\u5b58\u4e0b\u6765\uff0c\u5e76\u5728 sret \u4e4b\u524d\u6062\u590d\u539f\u6837 } impl TrapContext{ pub fn set_sp(&mut self, sp: usize) { self.x[2] = sp; // x2 = sp } pub fn app_init_context(entry: usize, sp: usize) -> Self{ let mut sstatus = sstatus::read(); sstatus.set_spp(SPP::User); let mut cx = Self{ x: [0; 32], sstatus, sepc: entry, }; cx.set_sp(sp); cx // \u4fee\u6539\u5176\u4e2d\u7684 sepc \u5bc4\u5b58\u5668\u4e3a\u5e94\u7528\u7a0b\u5e8f\u5165\u53e3\u70b9 entry // sp \u5bc4\u5b58\u5668 \u4e3a\u6211\u4eec\u8bbe\u5b9a\u7684\u4e00\u4e2a\u6808\u6307\u9488\uff0c // sstatus \u5bc4\u5b58\u5668\u7684 SPP \u5b57\u6bb5\u8bbe\u7f6e\u4e3a User } }","title":"os/src/trap/context.rs"},{"location":"ch2%E5%AE%9E%E7%8E%B0%E6%89%B9%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#ossrctrapmodrs","text":"mod context; use riscv::register::{ mtvec::TrapMode, stvec, scause::{ self, Trap, Exception, }, stval }; use crate::syscall::syscall; use crate::batch::run_next_app; use core::arch::global_asm; global_asm!(include_str!(\"trap.S\")); // \u5728\u64cd\u4f5c\u7cfb\u7edf\u521d\u59cb\u5316\u7684\u65f6\u5019\uff0c \u6211\u4eec\u9700\u8981\u4fee\u6539stvec \u5bc4\u5b58\u5668\u6765\u6307\u5411\u6b63\u786e\u7684Trap\u5904\u7406\u5165\u53e3\u70b9 pub fn init(){ extern \"C\" {fn __alltraps();} // \u5f15\u5165\u5916\u90e8\u7b26\u53f7 __alltraps unsafe{ stvec::write(__alltraps as usize, TrapMode::Direct); // \u5c06stvec\u8bbe\u7f6e\u4e3aDirect\u6a21\u5f0f\u6307\u5411\u5b83\u7684\u5730\u5740 } } #[no_mangle] pub fn trap_handler(cx: &mut TrapContext) -> &mut TrapContext{ let scause = scause::read(); let stval = stval::read(); match scause.cause(){ // scause \u5bc4\u5b58\u5668\u6240\u4fdd\u5b58\u7684 Trap \u7684\u539f\u56e0\u8fdb\u884c\u5206\u53d1\u5904\u7406\u3002\u8fd9\u91cc\u6211\u4eec\u65e0\u9700\u624b\u52a8\u64cd\u4f5c\u8fd9\u4e9b CSR \uff0c // \u800c\u662f\u4f7f\u7528 Rust \u7684 riscv \u5e93\u6765\u66f4\u52a0\u65b9\u4fbf\u7684\u505a\u8fd9\u4e9b\u4e8b\u60c5 // \u8981\u5f15\u5165riscv\u5e93\uff0c \u9700\u8981\u5728os/Cargo.toml \u914d\u7f6e\u6587\u4ef6\u4e2d \u6dfb\u52a0 // [dependencies] // riscv = { git = \"https://github.com/rcore-os/riscv\", features = [\"inline-asm\"] } Trap::Exception(Exception::UserEnvCall) => { // \u5982\u679c\u89e6\u53d1 Trap \u7684\u539f\u56e0\u662f\u6765\u81ea U\u6001 \u7684 \u7cfb\u7edf\u8c03\u7528 cx.sepc += 4; // \u9996\u5148\u4fee\u6539\u4fdd\u5b58\u5728\u5185\u6838\u6808\u4e0a\u7684 Trap \u4e0a\u4e0b\u6587\u91cc\u9762 sepc\uff0c\u8ba9\u5176\u589e\u52a0 4 // \u6211\u4eec\u77e5\u9053\u8fd9\u662f\u4e00\u4e2a\u7531 ecall \u6307\u4ee4\u89e6\u53d1\u7684\u7cfb\u7edf\u8c03\u7528\uff0c\u5728\u8fdb\u5165 Trap \u7684\u65f6\u5019\uff0c // \u786c\u4ef6\u4f1a\u5c06 sepc \u8bbe\u7f6e\u4e3a\u8fd9\u6761 ecall \u6307\u4ee4\u6240\u5728\u7684\u5730\u5740\uff08\u56e0\u4e3a\u5b83\u662f\u8fdb\u5165 Trap \u4e4b\u524d\u6700\u540e\u4e00\u6761\u6267\u884c\u7684\u6307\u4ee4\uff09\u3002 // \u800c\u5728 Trap \u8fd4\u56de\u4e4b\u540e\uff0c\u6211\u4eec\u5e0c\u671b\u5e94\u7528\u7a0b\u5e8f\u63a7\u5236\u6d41\u4ece ecall \u7684\u4e0b\u4e00\u6761\u6307\u4ee4\u5f00\u59cb\u6267\u884c\u3002 // \u56e0\u6b64\u6211\u4eec\u53ea\u9700\u4fee\u6539 Trap \u4e0a\u4e0b\u6587\u91cc\u9762\u7684 sepc\uff0c\u8ba9\u5b83\u589e\u52a0 ecall \u6307\u4ee4\u7684\u7801\u957f\uff0c\u4e5f\u5373 4 \u5b57\u8282\u3002 // \u8fd9\u6837\u5728 __restore \u7684\u65f6\u5019 sepc \u5728\u6062\u590d\u4e4b\u540e\u5c31\u4f1a\u6307\u5411 ecall \u7684\u4e0b\u4e00\u6761\u6307\u4ee4\uff0c // \u5e76\u5728 sret \u4e4b\u540e\u4ece\u90a3\u91cc\u5f00\u59cb\u6267\u884c cx.x[10] = syscall(cx.x[17], [cx.x[10], cx.x[11], cx.x[12]]) as usize; // x10=a0 x17=a7 x10=a0 x11=a1 x12=a2 // \u5904\u7406\u6b63\u5e38\u7cfb\u7edf\u8c03\u7528\u7684\u63a7\u5236\u903b\u8f91 // \u7528\u6765\u4fdd\u5b58\u7cfb\u7edf\u8c03\u7528\u8fd4\u56de\u503c\u7684 a0 \u5bc4\u5b58\u5668\u4e5f\u4f1a\u540c\u6837\u53d1\u751f\u53d8\u5316\u3002 // \u6211\u4eec\u4ece Trap \u4e0a\u4e0b\u6587\u53d6\u51fa\u4f5c\u4e3a syscall ID \u7684 a7 \u548c\u7cfb\u7edf\u8c03\u7528\u7684\u4e09\u4e2a\u53c2\u6570 a0~a2 // \u4f20\u7ed9 syscall \u51fd\u6570\u5e76\u83b7\u53d6\u8fd4\u56de\u503c // syscall \u5728 syscall \u5b50\u6a21\u5757\u4e2d\u5b9e\u73b0 } Trap::Exception(Exception::StoreFault) | Trap::Exception(Exception::StorePageFault) => { // \u5904\u7406\u5e94\u7528\u7a0b\u5e8f\u51fa\u73b0\u8bbf\u5b58\u9519\u8bef println!(\"[kernel] PageFault in application, kernel killed it.\"); // \u6253\u5370\u9519\u8bef\u4fe1\u606f run_next_app(); // \u76f4\u63a5\u5207\u6362\u5e76\u8fd0\u884c\u4e0b\u4e00\u4e2a\u5e94\u7528\u7a0b\u5e8f } Trap::Exception(Exception::IllegalInstruction) => { // \u975e\u6cd5\u6307\u4ee4\u9519\u8bef println!(\"[kernel] IllegalInstruction in application, kernel killed it.\"); run_next_app(); } _ => { // \u5f53\u9047\u5230\u76ee\u524d\u8fd8\u4e0d\u652f\u6301\u7684Trap\u7c7b\u578b\u65f6\uff0c\u64cd\u4f5c\u6574\u4e2apanic\u62a5\u9519\u9000\u51fa panic!(\"Unsupported trap {:?}, stval = {:#x}!\", scause.cause(), stval); } } cx // \u5c06\u4f20\u5165\u7684 cx \u539f\u6837\u8fd4\u56de\uff0c\u56e0\u6b64\u5728 __restore \u7684\u65f6\u5019 a0 \u5bc4\u5b58\u5668\u5728\u8c03\u7528 trap_handler \u524d\u540e\u5e76\u6ca1\u6709\u53d1\u751f\u53d8\u5316\uff0c // \u4ecd\u7136\u6307\u5411\u5206\u914d Trap \u4e0a\u4e0b\u6587\u4e4b\u540e\u7684\u5185\u6838\u6808\u6808\u9876\uff0c\u548c\u6b64\u65f6 sp \u7684\u503c\u76f8\u540c\uff0c\u8fd9\u91cc\u7684 sp <- a0 \u5e76\u4e0d\u4f1a\u6709\u95ee\u9898 } pub use context::TrapContext;","title":"os/src/trap/mod.rs"},{"location":"ch2%E5%AE%9E%E7%8E%B0%E6%89%B9%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#ossrctraptraps","text":".altmacro # \u52a0\u5165.altmacro \u624d\u80fd\u6b63\u5e38\u4f7f\u7528 .rept \u547d\u4ee4 .macro SAVE_GP n sd x\\n, \\n*8(sp) .endm .macro LOAD_GP n ld x\\n, \\n*8(sp) .endm .section .text .globl __alltraps .globl __restore .align 2 # .align \u5c06 __alltraps \u7684\u5730\u5740 4 \u5b57\u8282\u5bf9\u9f50\uff0c\u8fd9\u662f RISC-V \u7279\u6743\u7ea7\u89c4\u8303\u7684\u8981\u6c42 __alltraps: # \u5c06Trap\u4e0a\u4e0b\u6587\u4fdd\u5b58\u5728\u5185\u6838\u6808\u4e0a # sp -> user stack, sscratch -> kernel stack csrrw sp, sscratch, sp # sp -> kernel stack, sscratch -> user stack # csrrw \u539f\u578b\u662f csrrw rd, csr, rs \u53ef\u4ee5\u5c06 CSR \u5f53\u524d\u7684\u503c\u8bfb\u5230\u901a\u7528\u5bc4\u5b58\u5668 rd \u4e2d\uff0c # \u7136\u540e\u5c06\u901a\u7528\u5bc4\u5b58\u5668 rs \u7684\u503c\u5199\u5165\u8be5 CSR \u3002 # \u56e0\u6b64\u8fd9\u91cc\u8d77\u5230\u7684\u662f\u4ea4\u6362 sscratch \u548c sp \u7684\u6548\u679c\u3002\u5728\u8fd9\u4e00\u884c\u4e4b\u524d sp \u6307\u5411\u7528\u6237\u6808\uff0c # sscratch \u6307\u5411\u5185\u6838\u6808\uff08\u539f\u56e0\u7a0d\u540e\u8bf4\u660e\uff09\uff0c\u73b0\u5728 sp \u6307\u5411\u5185\u6838\u6808\uff0c sscratch \u6307\u5411\u7528\u6237\u6808 addi sp, sp, -34*8 # \u51c6\u5907\u5728\u5185\u6838\u6808\u4e0a\u4fdd\u5b58Trap\u4e0a\u4e0b\u6587\uff0c \u9884\u5148\u5206\u914d 34x8 \u5b57\u8282\u7684\u6808\u5e27 # \u6b64\u65f6 sp -> kernel stack sd x1, 1*8(sp) # \u6211\u4eec\u5728\u8fd9\u91cc\u4e5f\u4e0d\u4fdd\u5b58 sp(x2)\uff0c\u56e0\u4e3a\u6211\u4eec\u8981\u57fa\u4e8e\u5b83\u6765\u627e\u5230\u6bcf\u4e2a\u5bc4\u5b58\u5668\u5e94\u8be5\u88ab\u4fdd\u5b58\u5230\u7684\u6b63\u786e\u7684\u4f4d\u7f6e sd x3, 3*8(sp) # tp(x4) \u4e4b\u524d\u8bf4\u660e\u4e86\u539f\u56e0 .set n, 5 .rept 27 # \u7c7b\u4f3c\u5faa\u73af SAVE_GP %n .set n, n+1 .endr # \u4fdd\u5b5832 \u4e2a\u901a\u7528\u5bc4\u5b58\u5668\u7684\u540e 27\u4e2a # \u5728\u6808\u5206\u914d\u4e4b\u540e\uff0c\u53ef\u7528\u4e8e\u4fdd\u5b58Trap\u4e0a\u4e0b\u6587\u7684\u5730\u5740\u533a\u95f4\u4e3a [sp, sp + 8x34] # \u6309\u7167TrapContext\u7684\u5185\u5b58\u5e03\u5c40 # pub struct TrapContext{ # pub x: [usize; 32], # pub sstatus: Sstatus, # pub sepc: usize, # \u57fa\u4e8e\u5185\u6838\u6808\u7684\u4f4d\u7f6e\uff08sp\u6240\u6307\u5730\u5740\uff09\u6765\u4ece\u4f4e\u5730\u5740\u5230\u9ad8\u5730\u5740\u5206\u522b\u6309\u987a\u5e8f\u653e\u7f6e x0~x31\u8fd9\u4e9b\u901a\u7528\u5bc4\u5b58\u5668\uff0c # \u6700\u540e\u662f sstatus \u548c sepc # \u56e0\u6b64\u901a\u7528\u5bc4\u5b58\u5668 xn \u5e94\u8be5\u88ab\u4fdd\u5b58\u5728\u5730\u5740\u533a\u95f4 [sp + 8n, sp + 8(n+1)] } csrr t0, sstatus csrr t1, sepc # \u6307\u4ee4 csrr rd, rs \u7684\u529f\u80fd\u5c31\u662f\u5c06 CSR \u7684\u503c\u8bfb\u5230\u5bc4\u5b58\u5668 rd \u4e2d\u3002 # \u8fd9\u91cc\u6211\u4eec\u4e0d\u7528\u62c5\u5fc3 t0 \u548c t1 \u88ab\u8986\u76d6\uff0c\u56e0\u4e3a\u5b83\u4eec\u521a\u521a\u5df2\u7ecf\u88ab\u4fdd\u5b58\u4e86 sd t0, 32*8(sp) sd t1, 33*8(sp) # \u56e0\u4e3a\u4e0d\u80fd\u76f4\u63a5 \u64cd\u4f5c csr # \u6211\u4eec\u5c06 CSR sstatus \u548c sepc \u7684\u503c\u5206\u522b\u8bfb\u5230\u5bc4\u5b58\u5668 t0 \u548c t1 \u4e2d\u7136\u540e\u4fdd\u5b58\u5230\u5185\u6838\u6808\u5bf9\u5e94\u7684\u4f4d\u7f6e\u4e0a csrr t2, sscratch sd t2, 2*8(sp) # \u9996\u5148\u5c06 sscratch \u7684\u503c\u8bfb\u5230\u5bc4\u5b58\u5668 t2 \u5e76\u4fdd\u5b58\u5230\u5185\u6838\u6808\u4e0a\uff0c # \u6ce8\u610f\uff1a sscratch \u7684\u503c\u662f\u8fdb\u5165 Trap \u4e4b\u524d\u7684 sp \u7684\u503c\uff0c\u6307\u5411\u7528\u6237\u6808\u3002\u800c\u73b0\u5728\u7684 sp \u5219\u6307\u5411\u5185\u6838\u6808 mv a0, sp # sp -> a0 # \u8ba9\u5bc4\u5b58\u5668 a0 \u6307\u5411\u5185\u6838\u6808\u7684\u6808\u6307\u9488\u4e5f\u5c31\u662f\u6211\u4eec\u521a\u521a\u4fdd\u5b58\u7684 Trap \u4e0a\u4e0b\u6587\u7684\u5730\u5740\uff0c # \u8fd9\u662f\u7531\u4e8e\u6211\u4eec\u63a5\u4e0b\u6765\u8981\u8c03\u7528 trap_handler \u8fdb\u884c Trap \u5904\u7406\uff0c\u5b83\u7684\u7b2c\u4e00\u4e2a\u53c2\u6570 cx \u7531\u8c03\u7528\u89c4\u8303\u8981\u4ece a0 \u4e2d\u83b7\u53d6\u3002 # \u800c Trap \u5904\u7406\u51fd\u6570 trap_handler \u9700\u8981 Trap \u4e0a\u4e0b\u6587\u7684\u539f\u56e0\u5728\u4e8e\uff1a\u5b83\u9700\u8981\u77e5\u9053\u5176\u4e2d\u67d0\u4e9b\u5bc4\u5b58\u5668\u7684\u503c\uff0c # \u6bd4\u5982\u5728\u7cfb\u7edf\u8c03\u7528\u7684\u65f6\u5019\u5e94\u7528\u7a0b\u5e8f\u4f20\u8fc7\u6765\u7684 syscall ID \u548c\u5bf9\u5e94\u53c2\u6570\u3002\u6211\u4eec\u4e0d\u80fd\u76f4\u63a5\u4f7f\u7528\u8fd9\u4e9b\u5bc4\u5b58\u5668\u73b0\u5728\u7684\u503c\uff0c # \u56e0\u4e3a\u5b83\u4eec\u53ef\u80fd\u5df2\u7ecf\u88ab\u4fee\u6539\u4e86\uff0c\u56e0\u6b64\u8981\u53bb\u5185\u6838\u6808\u4e0a\u627e\u5df2\u7ecf\u88ab\u4fdd\u5b58\u4e0b\u6765\u7684\u503c call trap_handler # \u8df3\u8f6c\u5230\u7528rust\u7f16\u5199\u7684 trap_handler \u51fd\u6570\u5b8c\u6210trap\u5206\u53d1\u53ca\u5904\u7406 # RISC-V \u4e2d\u8bfb\u5199 CSR \u7684\u6307\u4ee4\u662f\u4e00\u7c7b\u80fd\u4e0d\u4f1a\u88ab\u6253\u65ad\u5730\u5b8c\u6210\u591a\u4e2a\u8bfb\u5199\u64cd\u4f5c\u7684\u6307\u4ee4\u3002 # \u8fd9\u79cd\u4e0d\u4f1a\u88ab\u6253\u65ad\u5730\u5b8c\u6210\u591a\u4e2a\u64cd\u4f5c\u7684\u6307\u4ee4\u88ab\u79f0\u4e3a \u539f\u5b50\u6307\u4ee4 (Atomic Instruction) # RISC-V \u67b6\u6784\u4e2d\u5e38\u89c4\u7684\u6570\u636e\u5904\u7406\u548c\u8bbf\u5b58\u7c7b\u6307\u4ee4\u53ea\u80fd\u64cd\u4f5c\u901a\u7528\u5bc4\u5b58\u5668\u800c\u4e0d\u80fd\u64cd\u4f5c CSR \u3002 # \u56e0\u6b64\uff0c\u5f53\u60f3\u8981\u5bf9 CSR \u8fdb\u884c\u64cd\u4f5c\u65f6\uff0c\u9700\u8981\u5148\u4f7f\u7528\u8bfb\u53d6 CSR \u7684\u6307\u4ee4\u5c06 CSR \u8bfb\u5230\u4e00\u4e2a\u901a\u7528\u5bc4\u5b58\u5668\u4e2d\uff0c # \u800c\u540e\u64cd\u4f5c\u8be5\u901a\u7528\u5bc4\u5b58\u5668\uff0c\u6700\u540e\u518d\u4f7f\u7528\u5199\u5165 CSR \u7684\u6307\u4ee4\u5c06\u8be5\u901a\u7528\u5bc4\u5b58\u5668\u7684\u503c\u5199\u5165\u5230 CSR \u4e2d # trap_handler\u8fd4\u56de \u4f1a\u56de\u5230\u6b64\u5904 __restore: # \u4ece\u4fdd\u5b58\u7684\u5185\u6838\u6808\u4e0a\u7684trap\u4e0a\u4e0b\u6587\u6062\u590d\u5bc4\u5b58\u5668 mv sp, a0 # sp -> kernel stack, sscratch -> user stack ld t0, 32*8(sp) ld t1, 33*8(sp) ld t2, 2*8(sp) csrw sstatus, t0 csrw sepc, t1 csrw sscratch, t2 # CSR\u5bc4\u5b58\u5668\u4e0d\u80fd\u76f4\u63a5\u64cd\u4f5c\uff0c\u8981\u901a\u8fc7\u901a\u7528\u5bc4\u5b58\u5668\u4f5c\u4e3a\u5a92\u4ecb # \u5148\u6062\u590dCSR\uff0c \u518d\u6062\u590d\u901a\u7528\u5bc4\u5b58\u5668\uff0c \u8fd9\u6837\u4e0a\u9762\u4e0a\u4e2a\u4e34\u65f6\u5bc4\u5b58\u5668\u624d\u80fd\u88ab\u6b63\u786e\u6062\u590d ld x1, 1*8(sp) ld x3, 3*8(sp) .set n, 5 .rept 27 LOAD_GP %n .set n, n+1 .endr # sp -> kernel stack(\u8fd9\u662f\u4fdd\u5b58\u5185\u6838\u4e0a\u4e0b\u6587\u4e4b\u540e\u7684\u6808\uff0c \u5373 sp + \u5404\u4e2a\u5bc4\u5b58\u5668\u7684\u7a7a\u95f4), # sscratch -> user stack addi sp, sp, 34*8 # \u5728\u5185\u6838\u6808\u4e0a\u56de\u6536Trap\u4e0a\u4e0b\u6587\u6240\u5360\u7528\u7684\u5185\u5b58 # sp -> kernel stack(trap\u4e4b\u524d\u7684\u5185\u6838\u6808) csrrw sp, sscratch, sp # \u518d\u6b21\u4ea4\u6362sscratch \u548c sp # sp -> \u7528\u6237\u6808\u6808\u9876\uff0c sscratch -> \u4fdd\u5b58\u8fdb\u5165Trap\u4e4b\u524d\u7684\u72b6\u6001\u5e76\u6307\u5411\u5185\u6838\u6808\u6808\u9876 sret # \u6267\u884c sret \u4ece S \u7279\u6743\u7ea7\u5207\u6362\u5230 U \u7279\u6743\u7ea7 # \u56de\u5230\u5e94\u7528\u7a0b\u5e8f\u6267\u884c # sscratch CSR \u7684\u7528\u9014 # \u5728\u7279\u6743\u7ea7\u5207\u6362\u7684\u65f6\u5019\uff0c\u6211\u4eec\u9700\u8981\u5c06 Trap \u4e0a\u4e0b\u6587\u4fdd\u5b58\u5728\u5185\u6838\u6808\u4e0a\uff0c\u56e0\u6b64\u9700\u8981\u4e00\u4e2a\u5bc4\u5b58\u5668\u6682\u5b58\u5185\u6838\u6808\u5730\u5740\uff0c # \u5e76\u4ee5\u5b83\u4f5c\u4e3a\u57fa\u5730\u5740\u6307\u9488\u6765\u4f9d\u6b21\u4fdd\u5b58 Trap \u4e0a\u4e0b\u6587\u7684\u5185\u5bb9\u3002\u4f46\u662f\u6240\u6709\u7684\u901a\u7528\u5bc4\u5b58\u5668\u90fd\u4e0d\u80fd\u591f\u7528\u4f5c\u57fa\u5730\u5740\u6307\u9488\uff0c # \u56e0\u4e3a\u5b83\u4eec\u90fd\u9700\u8981\u88ab\u4fdd\u5b58\uff0c\u5982\u679c\u8986\u76d6\u6389\u5b83\u4eec\uff0c\u5c31\u4f1a\u5f71\u54cd\u540e\u7eed\u5e94\u7528\u63a7\u5236\u6d41\u7684\u6267\u884c\u3002 # \u4e8b\u5b9e\u4e0a\u6211\u4eec\u7f3a\u5c11\u4e86\u4e00\u4e2a\u91cd\u8981\u7684\u4e2d\u8f6c\u5bc4\u5b58\u5668\uff0c\u800c sscratch CSR \u6b63\u662f\u4e3a\u6b64\u800c\u751f\u3002\u4ece\u4e0a\u9762\u7684\u6c47\u7f16\u4ee3\u7801\u4e2d\u53ef\u4ee5\u770b\u51fa\uff0c # \u5728\u4fdd\u5b58 Trap \u4e0a\u4e0b\u6587\u7684\u65f6\u5019\uff0c\u5b83\u8d77\u5230\u4e86\u4e24\u4e2a\u4f5c\u7528\uff1a\u9996\u5148\u662f\u4fdd\u5b58\u4e86\u5185\u6838\u6808\u7684\u5730\u5740\uff0c # \u5176\u6b21\u5b83\u53ef\u4f5c\u4e3a\u4e00\u4e2a\u4e2d\u8f6c\u7ad9\u8ba9 sp \uff08\u76ee\u524d\u6307\u5411\u7684\u7528\u6237\u6808\u7684\u5730\u5740\uff09\u7684\u503c\u53ef\u4ee5\u6682\u65f6\u4fdd\u5b58\u5728 sscratch \u3002 # \u8fd9\u6837\u4ec5\u9700\u4e00\u6761 csrrw sp, sscratch, sp \u6307\u4ee4\uff08\u4ea4\u6362\u5bf9 sp \u548c sscratch \u4e24\u4e2a\u5bc4\u5b58\u5668\u5185\u5bb9\uff09 # \u5c31\u5b8c\u6210\u4e86\u4ece\u7528\u6237\u6808\u5230\u5185\u6838\u6808\u7684\u5207\u6362\uff0c\u8fd9\u662f\u4e00\u79cd\u6781\u5176\u7cbe\u5de7\u7684\u5b9e\u73b0\u3002","title":"os/src/trap/trap.S"},{"location":"ch2%E5%AE%9E%E7%8E%B0%E6%89%B9%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#ossrcsyscallmodrs","text":"const SYSCALL_WRITE: usize = 64; const SYSCALL_EXIT: usize = 93; mod fs; mod process; use fs::*; use process::*; // syscall \u51fd\u6570\u5e76\u4e0d\u4f1a\u5b9e\u9645\u5904\u7406\u7cfb\u7edf\u8c03\u7528\uff0c // \u800c\u53ea\u662f\u6839\u636e syscall ID \u5206\u53d1\u5230\u5177\u4f53\u7684\u5904\u7406\u51fd\u6570 pub fn syscall(syscall_id: usize, args: [usize; 3]) -> isize{ match syscall_id { SYSCALL_WRITE => sys_write(args[0], args[1] as *const u8, args[2]), // \u8fd9\u91cc \u53ea\u662f\u5c06\u4f20\u8fdb\u6765\u7684\u53c2\u6570 args \u8f6c\u5316\u6210\u80fd\u591f\u88ab\u5177\u4f53\u7684\u7cfb\u7edf\u8c03\u7528\u5904\u7406\u51fd\u6570\u63a5\u53d7\u7684\u7c7b\u578b SYSCALL_EXIT => sys_exit(args[0] as i32), _ => panic!(\"Unsupported syscall_id: {}\", syscall_id), } }","title":"os/src/syscall/mod.rs"},{"location":"ch2%E5%AE%9E%E7%8E%B0%E6%89%B9%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#ossrcsyscallfsrs","text":"const FD_STDOUT: usize = 1; pub fn sys_write(fd: usize, buf: *const u8, len: usize) -> isize{ match fd{ FD_STDOUT => { let slice = unsafe{ core::slice::from_raw_parts(buf, len)}; let str = core::str::from_utf8(slice).unwrap(); print!(\"{}\", str); len as isize // sys_write \u6211\u4eec\u5c06\u4f20\u5165\u7684\u4f4d\u4e8e\u5e94\u7528\u7a0b\u5e8f\u5185\u7684\u7f13\u51b2\u533a\u7684\u5f00\u59cb\u5730\u5740\u548c\u957f\u5ea6\u8f6c\u5316\u4e3a\u4e00\u4e2a\u5b57\u7b26\u4e32 &str \uff0c // \u7136\u540e\u4f7f\u7528\u6279\u5904\u7406\u64cd\u4f5c\u7cfb\u7edf\u5df2\u7ecf\u5b9e\u73b0\u7684 print! \u5b8f\u6253\u5370\u51fa\u6765\u3002\u6ce8\u610f\u8fd9\u91cc\u6211\u4eec\u5e76\u6ca1\u6709\u68c0\u67e5\u4f20\u5165\u53c2\u6570\u7684\u5b89\u5168\u6027\uff0c // \u5373\u4f7f\u4f1a\u5728\u51fa\u9519\u4e25\u91cd\u7684\u65f6\u5019 panic\uff0c\u8fd8\u662f\u4f1a\u5b58\u5728\u5b89\u5168\u9690\u60a3\u3002\u8fd9\u91cc\u6211\u4eec\u51fa\u4e8e\u5b9e\u73b0\u65b9\u4fbf\u6682\u4e14\u4e0d\u505a\u4fee\u8865 }, _ => { panic!(\"Unsupported fd in sys_write!\"); } } }","title":"os/src/syscall/fs.rs"},{"location":"ch2%E5%AE%9E%E7%8E%B0%E6%89%B9%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#ossrcsyscallprocessrs","text":"use crate::batch::run_next_app; pub fn sys_exit(xstate: i32) -> !{ println!(\"[kernel Application exited with code {}\", xstate); run_next_app() // sys_exit \u6253\u5370\u9000\u51fa\u7684\u5e94\u7528\u7a0b\u5e8f\u7684\u8fd4\u56de\u503c\u5e76\u540c\u6837\u8c03\u7528 run_next_app \u5207\u6362\u5230\u4e0b\u4e00\u4e2a\u5e94\u7528\u7a0b\u5e8f }","title":"os/src/syscall/process.rs"},{"location":"ch2%E5%AE%9E%E7%8E%B0%E6%89%B9%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#osmakefile","text":"#Building TARGET := riscv64gc-unknown-none-elf MODE := release KERNEL_ELF := target/$(TARGET)/$(MODE)/os KERNEL_BIN := $(KERNEL_ELF).bin DISASM_TMP := target/$(TARGET)/$(MODE)/asm #BOARD BOARD ?= qemu SBI ?= rustsbi BOOTLOADER := ../bootloader/$(SBI)-$(BOARD).bin K210_BOOTLOADER_SIZE := 131072 #KERNEL ENTRY ifeq ($(BOARD), qemu) KERNEL_ENTRY_PA := 0x80200000 else ifeq ($(BOARD), k210) KERNEL_ENTRY_PA := 0x80020000 endif #Run K210 K210-SERIALPORT = /dev/ttyUSB0 K210-BURNER = ../tools/kflash.py #Binutils OBJDUMP := rust-objdump --arch-name=riscv64 OBJCOPY := rust-objcopy --binary-architecture=riscv64 #Disassembly DISASM ?= -x build: env switch-check $(KERNEL_BIN) switch-check: ifeq ($(BOARD), qemu) (which last-qemu) || (rm -f last-k210 && touch last-qemu && make clean) else ifeq ($(BOARD), k210) (which last-k210) || (rm -f last-qemu && touch last-k210 && make clean) endif env: (rustup target list | grep \"riscv64gc-unknown-none-elf (installed)\") || rustup target add $(TARGET) cargo install cargo-binutils --vers =0.3.3 rustup component add rust-src rustup component add llvm-tools-preview $(KERNEL_BIN): kernel @$(OBJCOPY) $(KERNEL_ELF) --strip-all -O binary $@ kernel: @cd ../user && make build @echo Platform: $(BOARD) @cp src/linker-$(BOARD).ld src/linker.ld @cargo build --release @rm src/linker.ld clean: @cargo clean disasm: kernel @$(OBJDUMP) $(DISASM) $(KERNEL_ELF) | less disasm-vim: kernel @$(OBJDUMP) $(DISASM) $(KERNEL_ELF) > $(DISASM_TMP) @vim $(DISASM_TMP) @rm $(DISASM_TMP) run: run-inner run-inner: build ifeq ($(BOARD), qemu) @qemu-system-riscv64 \\ -machine virt \\ -nographic \\ -bios $(BOOTLOADER) \\ -device loader,file=$(KERNEL_BIN),addr=$(KERNEL_ENTRY_PA) else (which $(K210-BURNER)) || (cd .. && git clone https://github.com/sipeed/kflash.py.git && mv kflash.py tools) @cp $(BOOTLOADER) $(BOOTLOADER).copy @dd if=$(KERNEL_BIN) of=$(BOOTLOADER).copy bs=$(K210_BOOTLOADER_SIZE) seek=1 @mv $(BOOTLOADER).copy $(KERNEL_BIN) @sudo chmod 777 $(K210-SERIALPORT) python3 $(K210-BURNER) -p $(K210-SERIALPORT) -b 1500000 $(KERNEL_BIN) python3 -m serial.tools.miniterm --eol LF --dtr 0 --rts 0 --filter direct $(K210-SERIALPORT) 115200 endif debug: build @tmux new-session -d \\ \"qemu-system-riscv64 -machine virt -nographic -bios $(BOOTLOADER) -device loader,file=$(KERNEL_BIN),addr=$(KERNEL_ENTRY_PA) -s -S\" && \\ tmux split-window -h \"riscv64-unknown-elf-gdb -ex 'file $(KERNEL_ELF)' -ex 'set arch riscv64:riscv64' -ex 'target remote localhost:1234'\" && \\ tmux -2 attach-session -d .PHONY: build env kernel clean disasm disasm-vim run-inner switch-check","title":"os/Makefile"},{"location":"ch2%E5%AE%9E%E7%8E%B0%E6%89%B9%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#user","text":"","title":"user \u6587\u4ef6\u5939\u4e0b"},{"location":"ch2%E5%AE%9E%E7%8E%B0%E6%89%B9%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#usercargoconfig","text":"[build] target = \"riscv64gc-unknown-none-elf\" [target.riscv64gc-unknown-none-elf] rustflags = [ \"-Clink-args=-Tsrc/linker.ld\" ]","title":"user/.cargo/config"},{"location":"ch2%E5%AE%9E%E7%8E%B0%E6%89%B9%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#usercargotoml","text":"[package] name = \"user_lib\" version = \"0.1.0\" edition = \"2021\" # \u5c06\u5e93\u7684\u540d\u5b57\u8bbe\u7f6e\u4e3a\uff1a user_lib # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html [dependencies] riscv = { git = \"https://github.com/rcore-os/riscv\", features = [\"inline-asm\"] }","title":"user/Cargo.toml"},{"location":"ch2%E5%AE%9E%E7%8E%B0%E6%89%B9%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#usersrclinkerld","text":"OUTPUT_ARCH(riscv) ENTRY(_start) # \u5728lib.rs \u4e2d\u5b9a\u4e49\u4e86\u7528\u6237\u5e93\u7684\u5165\u5e93\u70b9 _start # \u901a\u8fc7rust\u7684\u5b8f #[link_section = \".text.entry\"] # \u5c06_start\u7684\u90a3\u6bb5\u4ee3\u7801\u7f16\u8bd1\u540e\u7684\u6c47\u7f16\u4ee3\u7801\u653e\u5728\u4e00\u4e2a\u540d\u4e3a .text.entry \u7684\u6bb5\u4e2d BASE_ADDRESS = 0x80400000; # \u7a0b\u5e8f\u7684\u8d77\u59cb\u5730\u5740\u4e3a 0x80400000 SECTIONS{ . = BASE_ADDRESS; .text : { *(.text.entry) # \u5c06 _start \u6240\u5728\u7684 .text.entry \u6bb5\u653e\u5728\u6574\u4e2a\u7a0b\u5e8f\u7684\u5f00\u5934 # \u5373\u653e\u5728 0x80400000\u5904 *(.text .text.*) } .rodata : { *(.rodata .rodata.*) *(.srodata .srodata.*) } .data : { *(.data .data.*) *(.sdata .sdata.*) } .bss : { start_bss = .; *(.bss .bss.*) *(.sbss .sbss.*) end_bss = .; # \u8fdb\u5165\u7528\u6237\u5e93\u5165\u53e3\u4e4b\u540e\uff0c\u8981\u624b\u52a8\u6e05\u7a7a\u9700\u8981\u96f6\u521d\u59cb\u5316\u7684 .bss \u6bb5 # \u7531\u4e8e\u5185\u6838\u76ee\u524d\u8fd8\u6ca1\u6709\u8fd9\u4e2a\u80fd\u529b\uff0c\u53ea\u80fd\u5728\u7528\u6237\u5e93\u4e2d\u5b8c\u6210 # \u8fd9\u91cc\u7684start_bss \u3001 end_bss \u4fbf\u4e8e\u521d\u59cb\u5316 } /DISCARD/ : { *(.eh_frame) *(.debug*) } }","title":"user/src/linker.ld"},{"location":"ch2%E5%AE%9E%E7%8E%B0%E6%89%B9%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#usersrcsyscallrs","text":"// \u5728\u5b50\u6a21\u5757 syscall \u4e2d\u6211\u4eec\u4f5c\u4e3a\u5e94\u7528\u7a0b\u5e8f\u6765\u901a\u8fc7 ecall \u8c03\u7528\u6279\u5904\u7406\u7cfb\u7edf\u63d0\u4f9b\u7684\u63a5\u53e3\uff0c //\u7531\u4e8e\u5e94\u7528\u7a0b\u5e8f\u8fd0\u884c\u5728\u7528\u6237\u6001\uff08\u5373 U \u6a21\u5f0f\uff09\uff0c //ecall \u6307\u4ee4\u4f1a\u89e6\u53d1 \u540d\u4e3a Environment call from U-mode \u7684\u5f02\u5e38\uff0c //\u5e76 Trap \u8fdb\u5165 S \u6a21\u5f0f\u6267\u884c\u6279\u5904\u7406\u7cfb\u7edf\u9488\u5bf9\u8fd9\u4e2a\u5f02\u5e38\u7279\u522b\u63d0\u4f9b\u7684\u670d\u52a1\u4ee3\u7801 //\u6211\u4eec\u77e5\u9053\u7cfb\u7edf\u8c03\u7528\u5b9e\u9645\u4e0a\u662f\u6c47\u7f16\u6307\u4ee4\u7ea7\u7684\u4e8c\u8fdb\u5236\u63a5\u53e3\uff0c\u56e0\u6b64\u8fd9\u91cc\u7ed9\u51fa\u7684\u53ea\u662f\u4f7f\u7528 Rust \u8bed\u8a00\u63cf\u8ff0\u7684 API \u7248\u672c\u3002 //\u5728\u5b9e\u9645\u8c03\u7528\u7684\u65f6\u5019\uff0c\u6211\u4eec\u9700\u8981\u6309\u7167 RISC-V \u8c03\u7528\u89c4\u8303\uff08\u5373ABI\u683c\u5f0f\uff09\u5728\u5408\u9002\u7684\u5bc4\u5b58\u5668\u4e2d\u653e\u7f6e\u7cfb\u7edf\u8c03\u7528\u7684\u53c2\u6570\uff0c //\u7136\u540e\u6267\u884c ecall \u6307\u4ee4\u89e6\u53d1 Trap\u3002\u5728 Trap \u56de\u5230 U \u6a21\u5f0f\u7684\u5e94\u7528\u7a0b\u5e8f\u4ee3\u7801\u4e4b\u540e\uff0c //\u4f1a\u4ece ecall \u7684\u4e0b\u4e00\u6761\u6307\u4ee4\u7ee7\u7eed\u6267\u884c\uff0c\u540c\u65f6\u6211\u4eec\u80fd\u591f\u6309\u7167\u8c03\u7528\u89c4\u8303\u5728\u5408\u9002\u7684\u5bc4\u5b58\u5668\u4e2d\u8bfb\u53d6\u8fd4\u56de\u503c //\u5728 RISC-V \u8c03\u7528\u89c4\u8303\u4e2d\uff0c\u548c\u51fd\u6570\u8c03\u7528\u7684 ABI \u60c5\u5f62\u7c7b\u4f3c\uff0c\u7ea6\u5b9a\u5bc4\u5b58\u5668 a0~a6 \u4fdd\u5b58\u7cfb\u7edf\u8c03\u7528\u7684\u53c2\u6570\uff0c //a0~a1 \u4fdd\u5b58\u7cfb\u7edf\u8c03\u7528\u7684\u8fd4\u56de\u503c\u3002\u6709\u4e9b\u8bb8\u4e0d\u540c\u7684\u662f\u5bc4\u5b58\u5668 a7 \u7528\u6765\u4f20\u9012 syscall ID\uff0c //\u8fd9\u662f\u56e0\u4e3a\u6240\u6709\u7684 syscall \u90fd\u662f\u901a\u8fc7 ecall \u6307\u4ee4\u89e6\u53d1\u7684\uff0c //\u9664\u4e86\u5404\u8f93\u5165\u53c2\u6570\u4e4b\u5916\u6211\u4eec\u8fd8\u989d\u5916\u9700\u8981\u4e00\u4e2a\u5bc4\u5b58\u5668\u6765\u4fdd\u5b58\u8981\u8bf7\u6c42\u54ea\u4e2a\u7cfb\u7edf\u8c03\u7528\u3002 //\u7531\u4e8e\u8fd9\u8d85\u51fa\u4e86 Rust \u8bed\u8a00\u7684\u8868\u8fbe\u80fd\u529b\uff0c //\u6211\u4eec\u9700\u8981\u5728\u4ee3\u7801\u4e2d\u4f7f\u7528\u5185\u5d4c\u6c47\u7f16\u6765\u5b8c\u6210\u53c2\u6570/\u8fd4\u56de\u503c\u7ed1\u5b9a\u548c ecall \u6307\u4ee4\u7684\u63d2\u5165 use core::arch::asm; const SYSCALL_WRITE: usize = 64; const SYSCALL_EXIT: usize = 93; fn syscall(id: usize, args: [usize; 3]) -> isize{ let mut ret: isize; unsafe{ asm!( \"ecall\", inlateout(\"x10\") args[0] => ret, in(\"x11\") args[1], in(\"x12\") args[2], in(\"x17\") id ); } //\u5728\u7b2c\u4e00\u7ae0\u4e2d\uff0c\u6211\u4eec\u66fe\u7ecf\u4f7f\u7528 global_asm! \u5b8f\u6765\u5d4c\u5165\u5168\u5c40\u6c47\u7f16\u4ee3\u7801\uff0c //\u800c\u8fd9\u91cc\u7684 asm! \u5b8f\u53ef\u4ee5\u5c06\u6c47\u7f16\u4ee3\u7801\u5d4c\u5165\u5230\u5c40\u90e8\u7684\u51fd\u6570\u4e0a\u4e0b\u6587\u4e2d\u3002 //\u76f8\u6bd4 global_asm! \uff0c asm! \u5b8f\u53ef\u4ee5\u83b7\u53d6\u4e0a\u4e0b\u6587\u4e2d\u7684\u53d8\u91cf\u4fe1\u606f\u5e76\u5141\u8bb8\u5d4c\u5165\u7684\u6c47\u7f16\u4ee3\u7801\u5bf9\u8fd9\u4e9b\u53d8\u91cf\u8fdb\u884c\u64cd\u4f5c\u3002 //\u7531\u4e8e\u7f16\u8bd1\u5668\u7684\u80fd\u529b\u4e0d\u8db3\u4ee5\u5224\u5b9a\u63d2\u5165\u6c47\u7f16\u4ee3\u7801\u8fd9\u4e2a\u884c\u4e3a\u7684\u5b89\u5168\u6027\uff0c //\u6240\u4ee5\u6211\u4eec\u9700\u8981\u5c06\u5176\u5305\u88f9\u5728 unsafe \u5757\u4e2d\u81ea\u5df1\u6765\u5bf9\u5b83\u8d1f\u8d23 ret } // \u5c31\u662f\u8c03\u7528rustsbi\u63d0\u4f9b\u7684\u7cfb\u7edf\u8c03\u7528 pub fn sys_write(fd: usize, buffer: &[u8]) -> isize{ syscall(SYSCALL_WRITE, [fd, buffer.as_ptr() as usize, buffer.len()]) } pub fn sys_exit(exit_code: i32) -> isize { syscall(SYSCALL_EXIT, [exit_code as usize, 0, 0]) } //\u518d\u8fdb\u884c\u5c01\u88c5\uff0c\u4fbf\u4e8e\u5e94\u7528\u7a0b\u5e8f\u8c03\u7528 /* /// \u529f\u80fd\uff1a\u5c06\u5185\u5b58\u4e2d\u7f13\u51b2\u533a\u4e2d\u7684\u6570\u636e\u5199\u5165\u6587\u4ef6\u3002 /// \u53c2\u6570\uff1a`fd` \u8868\u793a\u5f85\u5199\u5165\u6587\u4ef6\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\uff1b /// `buf` \u8868\u793a\u5185\u5b58\u4e2d\u7f13\u51b2\u533a\u7684\u8d77\u59cb\u5730\u5740\uff1b /// `len` \u8868\u793a\u5185\u5b58\u4e2d\u7f13\u51b2\u533a\u7684\u957f\u5ea6\u3002 /// \u8fd4\u56de\u503c\uff1a\u8fd4\u56de\u6210\u529f\u5199\u5165\u7684\u957f\u5ea6\u3002 /// syscall ID\uff1a64 fn sys_write(fd: usize, buf: *const u8, len: usize) -> isize; /// \u529f\u80fd\uff1a\u9000\u51fa\u5e94\u7528\u7a0b\u5e8f\u5e76\u5c06\u8fd4\u56de\u503c\u544a\u77e5\u6279\u5904\u7406\u7cfb\u7edf\u3002 /// \u53c2\u6570\uff1a`xstate` \u8868\u793a\u5e94\u7528\u7a0b\u5e8f\u7684\u8fd4\u56de\u503c\u3002 /// \u8fd4\u56de\u503c\uff1a\u8be5\u7cfb\u7edf\u8c03\u7528\u4e0d\u5e94\u8be5\u8fd4\u56de\u3002 /// syscall ID\uff1a93 fn sys_exit(xstate: usize) -> !; */","title":"user/src/syscall.rs"},{"location":"ch2%E5%AE%9E%E7%8E%B0%E6%89%B9%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#usersrcconsolers","text":"use core::fmt::{self, Write}; use super::write; struct Stdout; const STDOUT: usize = 1; impl Write for Stdout{ fn write_str(&mut self, s: &str) -> fmt::Result{ write(STDOUT, s.as_bytes()); Ok(()) } //\u6211\u4eec\u628a console \u5b50\u6a21\u5757\u4e2d Stdout::write_str \u6539\u6210\u57fa\u4e8e write \u7684\u5b9e\u73b0\uff0c //\u4e14\u4f20\u5165\u7684 fd \u53c2\u6570\u8bbe\u7f6e\u4e3a 1\uff0c\u5b83\u4ee3\u8868\u6807\u51c6\u8f93\u51fa\uff0c \u4e5f\u5c31\u662f\u8f93\u51fa\u5230\u5c4f\u5e55 } pub fn print(args: fmt::Arguments){ Stdout.write_fmt(args).unwrap(); } #[macro_export] macro_rules! print{ ($fmt: literal $(, $($args: tt)+)?) => { $crate::console::print(format_args!($fmt $(, $($arg)+)?)); } } #[macro_export] macro_rules! println{ ($fmt: literal $(, $($arg: tt)+)?) => { $crate::console::print(format_args!(concat!($fmt, \"\\n\") $(, $($arg)+)?)); } }","title":"user/src/console.rs"},{"location":"ch2%E5%AE%9E%E7%8E%B0%E6%89%B9%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#usersrclang_itemsrs","text":"use crate::println; #[panic_handler] fn panic_handler(panic_info: &core::panic::PanicInfo) -> ! { let err = panic_info.message().unwrap(); if let Some(location) = panic_info.location() { println!(\"Panicked at {}:{}, {}\", location.file(), location.line(), err); } else{ println!(\"Panicked: {}\", err); } loop {} } // \u9664\u4e86\u6ca1\u6709shutdown\uff0c\u6ca1\u6709\u672c\u8d28\u533a\u522b","title":"user/src/lang_items.rs"},{"location":"ch2%E5%AE%9E%E7%8E%B0%E6%89%B9%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#usersrclibrs","text":"#![no_std] #![feature(panic_info_message)] // \u4e3a\u4e86\u83b7\u53d6panic\u7684\u4fe1\u606f #![feature(linkage)] // \u4e3a\u4e86\u652f\u6301\u5f31\u8fde\u63a5 pub mod console; mod syscall; mod lang_items; #[no_mangle] #[link_section = \".text.entry\"] //\u4f7f\u7528 Rust \u7684\u5b8f\u5c06 _start \u8fd9\u6bb5\u4ee3\u7801\u7f16\u8bd1\u540e\u7684\u6c47\u7f16\u4ee3\u7801\u4e2d\u653e\u5728\u4e00\u4e2a\u540d\u4e3a .text.entry \u7684\u4ee3\u7801\u6bb5\u4e2d\uff0c //\u65b9\u4fbf\u6211\u4eec\u5728\u540e\u7eed\u94fe\u63a5\u7684\u65f6\u5019\u8c03\u6574\u5b83\u7684\u4f4d\u7f6e\u4f7f\u5f97\u5b83\u80fd\u591f\u4f5c\u4e3a\u7528\u6237\u5e93\u7684\u5165\u53e3 pub extern \"C\" fn _start() -> ! { clear_bss(); //\u624b\u52a8\u6e05\u7a7a\u9700\u8981\u96f6\u521d\u59cb\u5316\u7684 .bss \u6bb5 exit(main()); panic!(\"unreachable after sys_exit!\"); } //\u6211\u4eec\u4f7f\u7528 Rust \u7684\u5b8f\u5c06\u5176\u51fd\u6570\u7b26\u53f7 main \u6807\u5fd7\u4e3a\u5f31\u94fe\u63a5\u3002\u8fd9\u6837\u5728\u6700\u540e\u94fe\u63a5\u7684\u65f6\u5019\uff0c //\u867d\u7136\u5728 lib.rs \u548c bin \u76ee\u5f55\u4e0b\u7684\u67d0\u4e2a\u5e94\u7528\u7a0b\u5e8f\u90fd\u6709 main \u7b26\u53f7\uff0c //\u4f46\u7531\u4e8e lib.rs \u4e2d\u7684 main \u7b26\u53f7\u662f\u5f31\u94fe\u63a5\uff0c\u94fe\u63a5\u5668\u4f1a\u4f7f\u7528 bin \u76ee\u5f55\u4e0b\u7684\u5e94\u7528\u4e3b\u903b\u8f91\u4f5c\u4e3a main \u3002 //\u8fd9\u91cc\u6211\u4eec\u4e3b\u8981\u662f\u8fdb\u884c\u67d0\u79cd\u7a0b\u5ea6\u4e0a\u7684\u4fdd\u62a4\uff0c\u5982\u679c\u5728 bin \u76ee\u5f55\u4e0b\u627e\u4e0d\u5230\u4efb\u4f55 main \uff0c //\u90a3\u4e48\u7f16\u8bd1\u4e5f\u80fd\u591f\u901a\u8fc7\uff0c\u4f46\u4f1a\u5728\u8fd0\u884c\u65f6\u62a5\u9519\u3002 #[linkage = \"weak\"] #[no_mangle] fn main() -> i32 { panic!(\"Cannot find main\"); } fn clear_bss(){ extern \"C\" { fn start_bss(); fn end_bss(); } (start_bss as usize..end_bss as usize).for_each(|addr|{ unsafe{ (addr as *mut u8).write_volatile(0);} }); } use syscall::*; pub fn write(fd: usize, buf: &[u8]) -> isize {sys_write(fd, buf)} pub fn exit(exit_code: i32) -> isize {sys_exit(exit_code)} // \u8fdb\u4e00\u6b65\u5c01\u88c5\uff0c\u4ece\u800c\u66f4\u52a0\u63a5\u8fd1Linux\u7b49\u5e73\u53f0\u7684\u5b9e\u9645\u7cfb\u7edf\u8c03\u7528\u63a5\u53e3","title":"user/src/lib.rs"},{"location":"ch2%E5%AE%9E%E7%8E%B0%E6%89%B9%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#usersrcbin00hello_worldrs","text":"#![no_std] #![no_main] #[macro_use] extern crate user_lib; // \u5f15\u5165\u5916\u90e8\u5e93 // \u5e93\u540d \u4ee5Cargo\u3002toml \u6587\u4ef6\u89c4\u5b9a\u4e3a\u4e3b #[no_mangle] fn main() -> i32{ println!(\"Hello, world!\"); 0 } Hello, world!","title":"user/src/bin/00hello_world.rs"},{"location":"ch2%E5%AE%9E%E7%8E%B0%E6%89%B9%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#usersrcbin01store_faultrs","text":"#![no_std] #![no_main] #[macro_use] extern crate user_lib; #[no_mangle] fn main() -> i32{ println!(\"Into Test store_fault, we will insert an invalid store operation...\"); println!(\"Kernel should kill this application!\"); unsafe{(0x0 as *mut u8).write_volatile(0);} // \u8bbf\u95ee\u4e00\u4e2a\u975e\u6cd5\u7684\u7269\u7406\u5730\u5740 0 } Into Test store_fault, we will insert an invalid store operation... Kernel should kill this application! Segmentation fault (core dumped)","title":"user/src/bin/01store_fault.rs"},{"location":"ch2%E5%AE%9E%E7%8E%B0%E6%89%B9%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#usersrcbin02priv_instrs","text":"#![no_std] #![no_main] #[macro_use] extern crate user_lib; use core::arch::asm; #[no_mangle] fn main() -> i32{ println!(\"Try to execute privileged instruction in U Mode\"); println!(\"Kernel should kill this application!\"); unsafe{ asm!(\"sret\"); // \u5728\u7528\u6237\u6001\u6267\u884c\u5185\u6838\u6001\u7684\u7279\u6743\u6307\u4ee4 sret } 0 } Try to execute privileged instruction in U Mode Kernel should kill this application! Illegal instruction (core dumped)","title":"user/src/bin/02priv_inst.rs"},{"location":"ch2%E5%AE%9E%E7%8E%B0%E6%89%B9%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#usersrcbin03priv_csrrs","text":"#![no_std] #![no_main] #[macro_use] extern crate user_lib; use riscv::register::sstatus::{self, SPP}; #[no_mangle] fn main() -> i32{ println!(\"Try to access privileged CSR in U Mode\"); println!(\"Kernel should kill this application!\"); unsafe{ sstatus::set_spp(SPP::User); } // \u5728\u7528\u6237\u6001\u4fee\u6539\u5185\u6838\u6001CSR sstatus 0 } Try to access privileged CSR in U Mode Kernel should kill this application! Illegal instruction (core dumped)","title":"user/src/bin/03priv_csr.rs"},{"location":"ch2%E5%AE%9E%E7%8E%B0%E6%89%B9%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#usermakefile","text":"TARGET := riscv64gc-unknown-none-elf MODE := release APP_DIR := src/bin TARGET_DIR := target/$(TARGET)/$(MODE) # target/riscv64gc-unknown-none-elf APPS := $(wildcard $(APP_DIR)/*.rs) # src/bin/*.rs ELFS := $(patsubst $(APP_DIR)/%.rs, $(TARGET_DIR)/%, $(APPS)) # src/bin/*.rs target/riscv64gc-unknown-none-elf/*.rs BINS := $(patsubst $(APP_DIR)/%.rs, $(TARGET_DIR)/%.bin, $(APPS)) # src/bin/*.rs target/riscv64gc-unknown-none-elf/*.bin OBJDUMP := rust-objdump --arch-name=riscv64 OBJCOPY := rust-objcopy --binary-architecture=riscv64 elf: @cargo build --release @echo $(APPS) @echo $(ELFS) @echo $(BINS) binary: elf $(foreach elf, $(ELFS), $(OBJCOPY) $(elf) --strip-all -O binary $(patsubst $(TARGET_DIR)/%, $(TARGET_DIR)/%.bin, $(elf));) build: binary \u53bb\u6389\u5e93\u51fd\u6570\u7684\u5f15\u7528\u4f1a\u600e\u6837 \u8fdb\u5165entr.asm\uff0c\u8bbe\u7f6e\u51fd\u6570\u6808\uff0c\u8df3\u8f6c\u5230 rust_main \u6e05\u96f6\u9664.bss.stack\u4ee5\u5916\u7684.bss\u6bb5 \u8c03\u7528println! -> print -> Stdout.write_fmt \u8c03\u7528 painc! -> println! -> shutdown -> sbi_call(SBI_SHUTDOWN, 0, 0, 0)","title":"user/Makefile"},{"location":"ch2%E5%AE%9E%E7%8E%B0%E6%89%B9%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#_5","text":"os/src/main.rs \u5bfc\u5165 entry.asm \u8bbe\u7f6e\u51fd\u6570\u6808\uff0c \u8df3\u8f6c\u5230rust_main \u5bfc\u5165 link_app.S \u8fd9\u91cc\u5168\u662f\u6570\u636e\u6bb5\uff0c \u53ef\u6267\u884c\u6587\u4ef6\u5728\u90e8\u5206\u6570\u636e\u6bb5\u4e2d \u8c03\u7528 clear_bass \u51fd\u6570\uff0c \u6e05\u9664 \u9664 .bss.stack \u4ee5\u5916\u7684 .bss \u6bb5 \u8c03\u7528 println! \u6253\u5370 [kernel] Hello, world! , \u6b64\u65f6\u5904\u4e8e\u5185\u6838\u6001 \u8c03\u7528 trap::init os/src/trap/mod.rs \u6211\u4eec\u9700\u8981\u4fee\u6539stvec \u5bc4\u5b58\u5668\u6765\u6307\u5411\u6b63\u786e\u7684Trap\u5904\u7406\u5165\u53e3\u70b9 \u5c06stvec\u8bbe\u7f6e\u4e3aDirect\u6a21\u5f0f\u6307\u5411\u5b83\u7684\u5730\u5740 \u6ce8\u610f\uff1a\u7531\u4e8e\u524d\u9762\u6709\u5bfc\u5165 trap.S\uff0c \u6240\u6709\u8fd9\u91cc\u77e5\u9053 Trap\u7684\u5904\u7406\u5165\u53e3 \u5373 __alltraps os/src/main.rs \u8c03\u7528batch::init os/src/batch.rs lazy_static! \u5b8f\u63d0\u4f9b\u4e86\u5168\u5c40\u53d8\u91cf\u7684\u8fd0\u884c\u65f6\u521d\u59cb\u5316\u529f\u80fd\uff0c \u751f\u6210\u4e00\u4e2a AppManager \u7684\u5b9e\u4f8b APP_MANAGER \u627e\u5230 link_app.S \u4e2d\u63d0\u4f9b\u7684\u7b26\u53f7 _num_app \u5e76\u4ece\u8fd9\u91cc\u5f00\u59cb\u89e3\u6790\u51fa\u5e94\u7528\u6570\u91cf\u4ee5\u53ca\u5404\u4e2a\u5e94\u7528\u7684\u8d77\u59cb\u5730\u5740 \u8c03\u7528 print_app_info \u51fd\u6570 prin_app_info \u51fd\u6570\u8c03\u7528 APP_MANAGER \u5b9e\u4f8b\u7684 print_app_info \u51fd\u6570 \u6253\u5370\u51fa \u4efb\u52a1\u6570 \u548c \u6bcf\u4e2a\u4efb\u52a1\u7684\u5730\u5740\u533a\u95f4 os/src/main.rs \u8c03\u7528 batch::run_next_app os/src/batch.rs \u5bf9\u5168\u5c40\u53d8\u91cf APP_MANAGER \u8fdb\u884c\u64cd\u4f5c \u5c06\u5168\u5c40\u53d8\u91cf\u7684 APP_MANAGER \u7684\u6240\u6709\u6743 \u501f\u7ed9\u4e00\u4e2a \u53ef\u53d8\u53d8\u91cf \u8c03\u7528\u5b9e\u4f8b\u7684 get_current_app \u83b7\u53d6\u5f53\u524d\u662f \u7b2c\u51e0\u4e2a \u4efb\u52a1 \u8c03\u7528\u5b9e\u4f8b\u7684 load_app\u52a0\u8f7d\u5f53\u524d\u4efb\u52a1 load_app \u7684\u903b\u8f91 \u5982\u679c \u5f53\u524d\u4efb\u52a1\u7684\u7f16\u53f7 \u5927\u4e8e \u603b\u7684\u4efb\u52a1\u6570\uff0c\u76f4\u63a5 panic \uff0c \u800c panic \u4e2d\u4f1a\u8c03\u7528 shutdown\uff0c \u6240\u4ee5\u4f1a\u76f4\u63a5\u5173\u673a \u5982\u679c\u6ca1\u8d85\u8fc7\u4efb\u52a1\u6570\uff0c\u6253\u5370\u5f53\u524d\u4efb\u52a1\u7f16\u53f7 \u8c03\u7528\u6c47\u7f16\u6307\u4ee4 fence.i \u6765\u6e05\u7406 i-cache \u5c06\u52a0\u8f7d\u5e94\u7528\u7a0b\u5e8f\u7684\u5730\u5740 [0x80400000 ~ 0x80400000 + 0x20000] \u75280\u586b\u5145 \u4ece AppManger \u7684\u5b9e\u4f8b\u4e2d\u83b7\u53d6\u5f53\u524d\u4efb\u52a1\u7684 \u5730\u5740\u533a\u95f4 \u6b64\u65f6\u7684\u5730\u5740\u4e3a \u8ddf\u7740\u5185\u6838\u52a0\u8f7d\u5230\u7684 .data \u6bb5\u4e2d\u7684\u5730\u5740 \u751f\u6210\u5f85\u653e\u7f6e\u5e94\u7528\u7684 \u5730\u5740\u533a\u95f4 \uff0c\u5373 0x80400000 ~ 0x8040000 + len \u8c03\u7528 copy_from_slice , \u5c06\u5e94\u7528\u590d\u5236\u8fc7\u53bb \u8c03\u7528 AppManager \u5b9e\u4f8b\u7684 move_to_next_app \u51fd\u6570 \u5c31\u662f\u5c06\u5f53\u524d\u4efb\u52a1\u7684\u7f16\u53f7 + 1 \u8c03\u7528drop\u51fd\u6570\uff0c \u5373\u6790\u6784\u51fd\u6570\uff0c \u9500\u6bc1\u8fd9\u4e2a\u53ef\u53d8\u53d8\u91cf \u83b7\u53d6 __restore \u7684\u5730\u5740\uff0c __restore \u5728 Trap.S \u91cc \u5c06 __restore \u53d8\u6210\u4e00\u4e2a\u9700\u8981 \u4e00\u4e2a\u53c2\u6570 \u7684\u51fd\u6570 \u5728\u8fd9\u4e2a\u6587\u4ef6\u5f00\u5934\u5b9a\u4e49\u4e86\u4e24\u4e2a\u9759\u6001\u53d8\u91cf\uff0c \u4ed6\u4eec\u662f\u7ed3\u6784\u4f53\u7c7b\u578b\uff0c\u7ed3\u6784\u4f53\u90fd\u662f \u4e00\u4e2a u8 \u6570\u7ec4 \u521d\u59cb\u5316\u7684\u53c2\u6570\u4e3a 0 \u6570\u7ec4\uff0c\u7ed3\u6784\u4f53\u7684\u6570\u7ec4\u5927\u5c0f\u4e3a 4096 * 2 \u7528\u4e8e\u5b58\u653e trap \u7684\u4e0a\u4e0b\u6587 \u8c03\u7528 KERNEL_STACK \u8fd9\u4e2a KernelStack \u7ed3\u6784\u4f53\u7684\u5b9e\u4f8b \u7684\u51fd\u6570 push_context \u5c06\u83b7\u53d6\u5230\u7684 trap \u4e0a\u4e0b\u6587\u4f5c\u4e3a\u53c2\u6570 \u4f20\u5165 \u8fd4\u56de\u4e00\u4e2atrap\u4e0a\u4e0b\u6587 \u8c03\u7528 TrapContext \u7684 app_init_context \u4f20\u5165\u5e94\u7528\u7a0b\u5e8f\u7684\u5730\u5740 APP_BASE_ADDRESS \uff0c\u5373 0x80400000 \u4f20\u5165 \u7528\u6237\u6808 USER_STACK \u7684 sp\uff0c\u5373\u7528\u6237\u6808\u7684\u6808\u9876\uff0c USER_STACK \u662f\u4e00\u4e2a\u7528\u4e8e\u5b58\u653e trap\u4e0a\u4e0b\u6587\u7684 u8\u6570\u7ec4, \u7528\u4e8e\u5b58\u653e\u4e00\u4e2a\u7528\u6237\u6808 os/src/trap/context.rs \u8c03\u7528TrapContext \u7ed3\u6784\u7684 app_init_context \u65b9\u6cd5 app_init_context \u903b\u8f91 \u4f20\u5165 \u5165\u53e3\u5730\u5740\uff0c\u5373\u5e94\u7528\u7a0b\u5e8f\u7684\u5165\u53e3\u5730\u5740\uff0c 0x80400000 \u548c\u7528\u6237\u6808 \u7684 \u6808\u9876 sp \u6ce8\u610f\uff1a\u8fd9\u4e2a\u7528\u6237\u6808\u662f\u901a\u8fc7USER_STACK\u8fd9\u4e2a\u5b9e\u4f8b\u7684 get_sp \u65b9\u6cd5\u5f97\u5230\u7684 \u4f46\u8fd9\u4e2a\u65b9\u6cd5\u4e2d \u7684\u7528\u6237\u6808\u7684\u8d77\u59cb\u4f4d\u7f6e\u662f\u4e0d\u786e\u5b9a\u7684\uff0c\u6211\u4eec\u53ea\u80fd\u77e5\u9053\u6808\u7684\u5927\u5c0f \u6240\u4ee5\u7528\u6237\u6808\u7684\u5730\u5740\u662f\u52a8\u6001\u968f\u673a\u7684 \u83b7\u53d6 sstatus, \u5c06sstatus \u7684 SPP\u5b57\u6bb5 \u8bbe\u4e3a User \u521b\u5efa\u4e00\u4e2aTrapContext \u7684 \u7ed3\u6784 cx\uff0c \u5c0632 \u4e2a\u901a\u7528\u5bc4\u5b58\u5668\u7684\u503c \u7f6e0 \u5c06 \u521a\u521a\u83b7\u53d6\u5e76\u6539\u53d8SPP\u5b57\u6bb5\u7684 sstatus \u5bc4\u5b58\u5668 \u7684\u503c\u5199\u5165\u7ed3\u6784 cx \u7684sstatus\u4e2d \u5c06 sepc \u5b57\u6bb5 \u8bbe\u4e3a \u5e94\u7528\u7a0b\u5e8f\u7684\u5165\u53e3\u5730\u5740 \u5c06sp \u6539\u4e3a \u4f20\u5165\u7684\u5e94\u7528\u7a0b\u5e8f\u7684 \u7528\u6237\u6808\u6bb5 \u8fd4\u56de\u8fd9\u4e2a\u7ed3\u6784 cx\uff0c \u5373\u4e00\u4e2atrap\u4e0a\u4e0b\u6587\u7684\u7ed3\u6784 os/src/batch.rs \u83b7\u5f97\u8fd9\u4e2atrap\u4e0a\u4e0b\u6587\u7684\u7ed3\u6784\u540e\uff0c\u5c06\u5176\u4f20\u5165\u5230 push_context \u4e2d \u521b\u5efa\u4e00\u4e2a\u53ef\u53d8\u7684 TrapContext \u7ed3\u6784\u4f53\u7684\u6307\u9488 \u8fd9\u4e2a\u6307\u9488\u6307\u5411\u7684\u662f\u8ddd\u79bb\u5185\u6838\u6808\u6808\u9876\u4e00\u4e2aTrap\u4e0a\u4e0b\u6587\u5927\u5c0f\u7684 \u5730\u5740\u5904 \u5728\u8fd9\u4e2a\u5730\u5740\u5904\u5f00\u59cb\u5b58\u653e cx \u7684\u7ed3\u6784 \u6ce8\u610f\uff1ariscv\u4e2d\u6808\u662f\u5411\u4e0b\u589e\u957f\u7684 \u4f46\u5411\u6808\u4e2d\u5b58\u653e\u6570\u636e\u65f6\u662f\u4ecesp\u5904\u5f00\u59cb\u5411\u4e0a\u5b58\u653e\uff0c\u6211\u4eec\u6839\u636e\u8981\u5b58\u653e\u7684\u6570\u636e\u7684\u5927\u5c0f\u5c06sp\u5411\u4e0b\u79fb\u7684\uff0c\u6570\u636e\u4e0d\u4f1a\u8d8a\u754c \u76f8\u5f53\u4e8e\u5c06 \u8fd9\u4e2aTrap\u4e0a\u4e0b\u6587 push \u5230 \u5185\u6838\u6808 \u540c\u65f6\u8fd4\u56de\u8fd9\u4e2a\u5728\u6307\u9488\u7684 \u89e3\u5f15\u7528 \u5373\u6307\u9488\u6240\u6307\u7684\u5730\u5740\u7684\u503c\uff0c\u5373trap\u4e0a\u4e0b\u6587 \u7684\u5730\u5740\uff0c\u5c31\u662f\u5185\u6838\u6808\u7684\u79bb\u6808\u9876\u4e00\u4e2aTrapContext \u7ed3\u6784\u5927\u5c0f\u7684\u5730\u65b9 \u5c06\u8fd4\u56de\u5185\u6838\u6808\u7684\u79bb\u6808\u9876\u4e00\u4e2aTrapContext \u7ed3\u6784\u5927\u5c0f\u7684\u5730\u5740\u4f5c\u4e3a\u53c2\u6570\uff0c\u4f20\u9012\u7ed9 __restore \u51fd\u6570 \u6700\u7ec8\uff0c\u7528\u6237\u6808\u7684\u4e0a\u4e0b\u6587\u5b58\u653e\u5728\u5185\u6838\u6808\u4e2d os/src/trap.S \u4f20\u5165\u7684\u53c2\u6570 a0, \u5373 \u5185\u6838\u6808\u7684\u79bb\u6808\u9876\u4e00\u4e2aTrapContext \u7ed3\u6784\u5927\u5c0f\u7684\u5730\u5740 \u5c06\u8fd9\u4e2a\u5730\u5740\u4f20\u4e2a sp\uff0c sp -> \u5185\u6838\u6808\uff0c \u800c\u8fd9\u4e2a\u5185\u6838\u6808\u4e2d\u7684\u5185\u5bb9\u662f \u7528\u6237\u6808\u7684\u4e0a\u4e0b\u6587 \u9996\u5148\u6062\u590dsstatus, sepc \u548c sscratch \u5bc4\u5b58\u5668 \u5176\u5b9e\u4e5f\u4e0d\u53eb\u6062\u590d\uff0c\u800c\u662f\u5c06\u7528\u6237\u6808\u7684\u4e0a\u4e0b\u6587 \u7ed9 \u901a\u7528\u5bc4\u5b58\u5668 \u548c CSR \u5c06sp+34*8\uff0c\u5373pop\u5185\u6838\u6808\uff0c\u56de\u6536\u4e86\u5185\u6838\u4e0a\u5b58\u653e\u7684\u7528\u6237\u6808\u7684\u4e0a\u4e0b\u6587 \u5c06 sp -> user stack, sret, \u8df3\u8f6c\u5230\u7528\u6237\u6808\uff0c\u6267\u884c\u7528\u6237\u7a0b\u5e8f user/lib.rs \u518d\u8f6c\u5230\u7528\u6237\u7a0b\u5e8f\u7684\u903b\u8f91\u91cc rust \u7528cargo\u751f\u6210 --bin \u9879\u76ee\u53ea\u4f1a \u6709\u4e00\u4e2a\u53ef\u6267\u884c\u7a0b\u5e8f\u751f\u6210 \u5c31main.rs --lib \u9879\u76ee\uff0c\u53ea\u8981\u4e00\u4e2a\u6587\u4ef6\u4e2d\u6709\u4e14\u4ec5\u6709\u4e00\u4e2a main \u51fd\u6570\uff0c\u8fd9\u4e2a\u6587\u4ef6\u5c31\u53ef\u4ee5\u751f\u6210\u5bf9\u5e94\u7684\u53ef\u6267\u884c\u7a0b\u5e8f \u5728\u8fd9\u4e2auser\u9879\u76ee\u4e0b\uff0c\u6bcf\u4e2a\u5e94\u7528\u7a0b\u5e8f\u90fd\u5bfc\u5165\u4e86\u5916\u90e8\u94fe\u63a5\uff0c\u90a3\u5916\u90e8\u7684\u6574\u4e2a\u7a0b\u5e8f\u90fd\u4f1a\u88ab\u7f16\u8bd1\u5728\u4e00\u8d77 \u7531\u4e8e\u6211\u4eec\u6709linker.ld\u6587\u4ef6\uff0c\u800c\u4e14\u5c06 _start \u51fd\u6570\u5206\u914d\u5728 .text.entry \u6bb5\u4e2d\uff0c\u6240\u4ee5\u6bcf\u4e2a\u53ef\u6267\u884c\u6587\u4ef6\u4e2d\u8fd8\u662f\u4f1a\u5148\u8fd0\u884c _start \u51fd\u6570\uff0c\u5728 _start \u51fd\u6570\u4e2d\u8df3\u8f6c\u5230 main \u51fd\u6570\u4e2d \u6267\u884c _start \u51fd\u6570 \u8c03\u7528 clear_bss \u51fd\u6570\uff0c\u6ce8\u610f\uff0c\u6b64\u5904\u6ca1\u6709 .bss.stack \u6bb5 \u6240\u4ee5\u76f4\u63a5\u5c06\u6574\u4e2a .bss \u6bb5\u6e05\u96f6 \u5148\u6267\u884c main \u51fd\u6570 \u5c31\u4e00\u4e2a\u7b80\u5355\u7684\u6253\u5370 hello world, \u8fd4\u56de0 \u5c06main\u51fd\u6570\u7684\u8fd4\u56de\u503c\u4f5c\u4e3a\u53c2\u6570 \u4f20\u5165\u5230 exit\u51fd\u6570\u4e2d exit \u8c03\u7528 sys_exit user/syscall.rs sys_exit \u8c03\u7528 syscall syscall \u5c06 SYSCALL_EXIT \u548c main\u51fd\u6570\u8fd4\u56de\u503c0 \u4f5c\u4e3a\u53c2\u6570 \u8fdb\u884c trap \u9677\u5165\uff0c\u5373\u8c03\u7528 ecall os/src/trap/trap.S \u7531\u4e8e trap::init \u5c06 stvec \u6307\u5411\u4e86 __alltraps, \u90a3\u8fdb\u5165 __alltraps \u4e2d \u5c06\u5f53\u524d\u8fd9\u4e2a \u7528\u6237\u4e0a\u4e0b\u6587 \u5b58\u5165\u5230 \u5185\u6838\u6808\u4e0a \u5c06\u8fd9\u4e2a\u5185\u6838\u6808\u7684 \u6808\u6307\u9488\u5b58\u5165\u5230 a0 \u5bc4\u5b58\u5668\u4e2d \u8c03\u7528 trap_handler \u51fd\u6570 os/src/trap/mod.rs trap_handler \u51fd\u6570\u7684\u903b\u8f91 \u5c06 a0 \u5bc4\u5b58\u5668\u7684\u503c \u5373trap\u4e0a\u4e0b\u6587\u7684\u5730\u5740 \u4f5c\u4e3a\u53c2\u6570\u4f20\u5165 \u76f4\u63a5\u83b7\u53d6\u5f53\u524d scause \u548c stval \u4e24\u4e2a \u63a7\u5236\u5bc4\u5b58\u5668\u7684 \u503c \u7531\u4e8e\u521a\u624d\u53ea\u662f\u4fdd\u5b58 trap\u4e0a\u4e0b\u6587\uff0c \u6ca1\u6709\u6539\u53d8\u8fc7 scause \u548c stval , \u6240\u6709\u53ef\u4ee5\u76f4\u63a5\u4f7f\u7528 \u901a\u8fc7 scause.cause \u5224\u65ad trap\u7684\u539f\u56e0 \u7b2c\u4e00\u4e2a\u539f\u56e0\u662f\u7cfb\u7edf\u8c03\u7528 \u4e00\u4e2a\u7531 ecall \u6307\u4ee4\u89e6\u53d1\u7684\u7cfb\u7edf\u8c03\u7528\uff0c\u5728\u8fdb\u5165 Trap \u7684\u65f6\u5019\uff0c \u786c\u4ef6\u4f1a\u5c06 sepc \u8bbe\u7f6e\u4e3a\u8fd9\u6761 ecall \u6307\u4ee4\u6240\u5728\u7684\u5730\u5740 sepc + 4 \uff0c\u8ba9\u5176\u6307\u5411 ecall \u7684\u4e0b\u4e00\u6761\u6307\u4ee4 \uff08\u4e0d\u8fc7\u8fd9\u91cc\u662f\u4e0d\u4f1a\u6267\u884c\u5230 ecall\u7684\u4e0b\u4e00\u6761\u6307\u4ee4\u7684) \u6839\u636e \u4f20\u5165\u7684\u7cfb\u7edf\u8c03\u7528\u7684\u7c7b\u578b\u548c\u53c2\u6570\u503c(\u8fd9\u91cc\u4fdd\u5b58\u5728\u901a\u7528\u5bc4\u5b58\u5668\u4e2d)\u8fdb\u884c\u5185\u6838\u7684\u7cfb\u7edf\u8c03\u7528 os/src/syscall/mod.rs \u6839\u636e\u4f20\u5165\u7684\u7cfb\u7edf\u8c03\u7528\u7684 id \u548c \u53c2\u6570\u503c\uff0c\u8f6c\u5230\u5bf9\u5e94\u7684\u7cfb\u7edf\u8c03\u7528\u7684\u6267\u884c\u51fd\u6570\u4e2d os/src/syscall/process.rs \u6253\u5370\u9000\u51fa\u7801 \u8c03\u7528 run_next_app \u52a0\u8f7d\u7b2c\u4e8c\u4e2a\u5e94\u7528\u7a0b\u5e8f \u51fa\u73b0\u975e\u6cd5\u6307\u4ee4\uff0c \u8df3\u5230 __alltraps, \u4fdd\u5b58\u4e0a\u4e0b\u6587\uff0c call trap_handler trap_handler \u53d1\u73b0\u662f StoreFault \u6253\u5370 \u9519\u8bef\u539f\u56e0 \u8df3\u8f6c\u5230\u4e0b\u4e00\u4e2a \u5e94\u7528\u7a0b\u5e8f \u52a0\u8f7d\u7b2c\u4e09\u4e2a \u5e94\u7528\u7a0b\u5e8f \u6b63\u5e38\u6267\u884c\uff0c\u548c\u7b2c\u4e00\u4e2a\u4e00\u6837\u6b63\u5e38\u9000\u51fa \u52a0\u8f7d\u7b2c\u56db\u4e2a \u51fa\u73b0\u975e\u6cd5\u6307\u4ee4\uff0c \u6253\u5370\u9519\u8bef \u8df3\u8f6c\u5230\u4e0b\u4e00\u4e2a\u5e94\u7528\u7a0b\u5e8f \u52a0\u8f7d\u7b2c\u4e94\u4e2a \u51fa\u73b0\u975e\u6cd5\u6307\u4ee4\uff0c \u6253\u5370\u9519\u8bef \u8df3\u8f6c\u5230\u4e0b\u4e00\u4e2a\u5e94\u7528\u7a0b\u5e8f load_app \u65f6\u53d1\u73b0 app_id \u5df2\u7ecf\u5927\u4e8e num_app\uff0c \u76f4\u63a5\u8c03\u7528 panic \uff0c\u6253\u5370\u540e \u8c03\u7528 shutdown \u6b63\u5e38\u5173\u673a","title":"\u6267\u884c\u6d41\u7a0b"},{"location":"ch2%E7%94%9F%E6%88%90%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/","text":"\u751f\u6210\u80fd\u88ab\u5185\u6838\u8bc6\u522b\u7684\u5e94\u7528\u7a0b\u5e8f \u7b2c\u4e8c\u7ae0\u4ee3\u7801\u6811 ./os/src Rust 13 Files 372 Lines Assembly 2 Files 58 Lines \u251c\u2500\u2500 bootloader \u2502 \u251c\u2500\u2500 rustsbi-k210.bin \u2502 \u2514\u2500\u2500 rustsbi-qemu.bin \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 os \u2502 \u251c\u2500\u2500 build.rs(\u65b0\u589e\uff1a\u751f\u6210 link_app.S \u5c06\u5e94\u7528\u4f5c\u4e3a\u4e00\u4e2a\u6570\u636e\u6bb5\u94fe\u63a5\u5230\u5185\u6838) \u2502 \u251c\u2500\u2500 Cargo.toml \u2502 \u251c\u2500\u2500 Makefile(\u4fee\u6539\uff1a\u6784\u5efa\u5185\u6838\u4e4b\u524d\u5148\u6784\u5efa\u5e94\u7528) \u2502 \u2514\u2500\u2500 src \u2502 \u251c\u2500\u2500 batch.rs(\u65b0\u589e\uff1a\u5b9e\u73b0\u4e86\u4e00\u4e2a\u7b80\u5355\u7684\u6279\u5904\u7406\u7cfb\u7edf) \u2502 \u251c\u2500\u2500 console.rs \u2502 \u251c\u2500\u2500 entry.asm \u2502 \u251c\u2500\u2500 lang_items.rs \u2502 \u251c\u2500\u2500 link_app.S(\u6784\u5efa\u4ea7\u7269\uff0c\u7531 os/build.rs \u8f93\u51fa) \u2502 \u251c\u2500\u2500 linker-k210.ld \u2502 \u251c\u2500\u2500 linker-qemu.ld \u2502 \u251c\u2500\u2500 main.rs(\u4fee\u6539\uff1a\u4e3b\u51fd\u6570\u4e2d\u9700\u8981\u521d\u59cb\u5316 Trap \u5904\u7406\u5e76\u52a0\u8f7d\u548c\u6267\u884c\u5e94\u7528) \u2502 \u251c\u2500\u2500 sbi.rs \u2502 \u251c\u2500\u2500 sync(\u65b0\u589e\uff1a\u540c\u6b65\u5b50\u6a21\u5757 sync \uff0c\u76ee\u524d\u552f\u4e00\u529f\u80fd\u662f\u63d0\u4f9b UPSafeCell) \u2502 \u2502 \u251c\u2500\u2500 mod.rs \u2502 \u2502 \u2514\u2500\u2500 up.rs(\u5305\u542b UPSafeCell\uff0c\u5b83\u53ef\u4ee5\u5e2e\u52a9\u6211\u4eec\u4ee5\u66f4 Rust \u7684\u65b9\u5f0f\u4f7f\u7528\u5168\u5c40\u53d8\u91cf) \u2502 \u251c\u2500\u2500 syscall(\u65b0\u589e\uff1a\u7cfb\u7edf\u8c03\u7528\u5b50\u6a21\u5757 syscall) \u2502 \u2502 \u251c\u2500\u2500 fs.rs(\u5305\u542b\u6587\u4ef6 I/O \u76f8\u5173\u7684 syscall) \u2502 \u2502 \u251c\u2500\u2500 mod.rs(\u63d0\u4f9b syscall \u65b9\u6cd5\u6839\u636e syscall ID \u8fdb\u884c\u5206\u53d1\u5904\u7406) \u2502 \u2502 \u2514\u2500\u2500 process.rs(\u5305\u542b\u4efb\u52a1\u5904\u7406\u76f8\u5173\u7684 syscall) \u2502 \u2514\u2500\u2500 trap(\u65b0\u589e\uff1aTrap \u76f8\u5173\u5b50\u6a21\u5757 trap) \u2502 \u251c\u2500\u2500 context.rs(\u5305\u542b Trap \u4e0a\u4e0b\u6587 TrapContext) \u2502 \u251c\u2500\u2500 mod.rs(\u5305\u542b Trap \u5904\u7406\u5165\u53e3 trap_handler) \u2502 \u2514\u2500\u2500 trap.S(\u5305\u542b Trap \u4e0a\u4e0b\u6587\u4fdd\u5b58\u4e0e\u6062\u590d\u7684\u6c47\u7f16\u4ee3\u7801) \u251c\u2500\u2500 README.md \u251c\u2500\u2500 rust-toolchain \u251c\u2500\u2500 tools \u2502 \u251c\u2500\u2500 kflash.py \u2502 \u251c\u2500\u2500 LICENSE \u2502 \u251c\u2500\u2500 package.json \u2502 \u251c\u2500\u2500 README.rst \u2502 \u2514\u2500\u2500 setup.py \u2514\u2500\u2500 user(\u65b0\u589e\uff1a\u5e94\u7528\u6d4b\u4f8b\u4fdd\u5b58\u5728 user \u76ee\u5f55\u4e0b) \u251c\u2500\u2500 Cargo.toml \u251c\u2500\u2500 Makefile \u2514\u2500\u2500 src \u251c\u2500\u2500 bin(\u57fa\u4e8e\u7528\u6237\u5e93 user_lib \u5f00\u53d1\u7684\u5e94\u7528\uff0c\u6bcf\u4e2a\u5e94\u7528\u653e\u5728\u4e00\u4e2a\u6e90\u6587\u4ef6\u4e2d) \u2502 \u251c\u2500\u2500 00hello_world.rs \u2502 \u251c\u2500\u2500 01store_fault.rs \u2502 \u251c\u2500\u2500 02power.rs \u2502 \u251c\u2500\u2500 03priv_inst.rs \u2502 \u2514\u2500\u2500 04priv_csr.rs \u251c\u2500\u2500 console.rs \u251c\u2500\u2500 lang_items.rs \u251c\u2500\u2500 lib.rs(\u7528\u6237\u5e93 user_lib) \u251c\u2500\u2500 linker.ld(\u5e94\u7528\u7684\u94fe\u63a5\u811a\u672c) \u2514\u2500\u2500 syscall.rs(\u5305\u542b syscall \u65b9\u6cd5\u751f\u6210\u5b9e\u9645\u7528\u4e8e\u7cfb\u7edf\u8c03\u7528\u7684\u6c47\u7f16\u6307\u4ee4\uff0c \u5404\u4e2a\u5177\u4f53\u7684 syscall \u90fd\u662f\u901a\u8fc7 syscall \u6765\u5b9e\u73b0\u7684) \u672c\u8282\u6587\u4ef6\u89e3\u6790 \u672c\u8282\u5b9e\u73b0\u7684\u662f\u80fd\u591f\u88ab\u5185\u6838\u8bc6\u522b\u5e76\u9010\u4e2a\u52a0\u8f7d\u8fd0\u884c\u7684\u5e94\u7528\u7a0b\u5e8f \u8981\u4fdd\u8bc1\u5e94\u7528\u7a0b\u5e8f\u5728\u7528\u6237\u6001\u6b63\u5e38\u8fd0\u884c\uff0c\u80fd\u591f\u88abqemu-riscv64\u7528\u6237\u6001\u6a21\u62df\u5668 \u8bc6\u522b\u5e76\u6267\u884c \u6240\u4ee5\u672c\u8282\u7684\u4ee3\u7801\u90fd\u5728user\u76ee\u5f55\u4e0b user/.cargo/config [build] target = \"riscv64gc-unknown-none-elf\" [target.riscv64gc-unknown-none-elf] rustflags = [ \"-Clink-args=-Tsrc/linker.ld\" ] user/Cargo.toml [package] name = \"user_lib\" version = \"0.1.0\" edition = \"2021\" # \u5c06\u5e93\u7684\u540d\u5b57\u8bbe\u7f6e\u4e3a\uff1a user_lib # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html [dependencies] riscv = { git = \"https://github.com/rcore-os/riscv\", features = [\"inline-asm\"] } user/src/linker.ld OUTPUT_ARCH(riscv) ENTRY(_start) # \u5728lib.rs \u4e2d\u5b9a\u4e49\u4e86\u7528\u6237\u5e93\u7684\u5165\u5e93\u70b9 _start # \u901a\u8fc7rust\u7684\u5b8f #[link_section = \".text.entry\"] # \u5c06_start\u7684\u90a3\u6bb5\u4ee3\u7801\u7f16\u8bd1\u540e\u7684\u6c47\u7f16\u4ee3\u7801\u653e\u5728\u4e00\u4e2a\u540d\u4e3a .text.entry \u7684\u6bb5\u4e2d BASE_ADDRESS = 0x80400000; # \u7a0b\u5e8f\u7684\u8d77\u59cb\u5730\u5740\u4e3a 0x80400000 SECTIONS{ . = BASE_ADDRESS; .text : { *(.text.entry) # \u5c06 _start \u6240\u5728\u7684 .text.entry \u6bb5\u653e\u5728\u6574\u4e2a\u7a0b\u5e8f\u7684\u5f00\u5934 # \u5373\u653e\u5728 0x80400000\u5904 *(.text .text.*) } .rodata : { *(.rodata .rodata.*) *(.srodata .srodata.*) } .data : { *(.data .data.*) *(.sdata .sdata.*) } .bss : { start_bss = .; *(.bss .bss.*) *(.sbss .sbss.*) end_bss = .; # \u8fdb\u5165\u7528\u6237\u5e93\u5165\u53e3\u4e4b\u540e\uff0c\u8981\u624b\u52a8\u6e05\u7a7a\u9700\u8981\u96f6\u521d\u59cb\u5316\u7684 .bss \u6bb5 # \u7531\u4e8e\u5185\u6838\u76ee\u524d\u8fd8\u6ca1\u6709\u8fd9\u4e2a\u80fd\u529b\uff0c\u53ea\u80fd\u5728\u7528\u6237\u5e93\u4e2d\u5b8c\u6210 # \u8fd9\u91cc\u7684start_bss \u3001 end_bss \u4fbf\u4e8e\u521d\u59cb\u5316 } /DISCARD/ : { *(.eh_frame) *(.debug*) } } user/src/syscall.rs // \u5728\u5b50\u6a21\u5757 syscall \u4e2d\u6211\u4eec\u4f5c\u4e3a\u5e94\u7528\u7a0b\u5e8f\u6765\u901a\u8fc7 ecall \u8c03\u7528\u6279\u5904\u7406\u7cfb\u7edf\u63d0\u4f9b\u7684\u63a5\u53e3\uff0c //\u7531\u4e8e\u5e94\u7528\u7a0b\u5e8f\u8fd0\u884c\u5728\u7528\u6237\u6001\uff08\u5373 U \u6a21\u5f0f\uff09\uff0c //ecall \u6307\u4ee4\u4f1a\u89e6\u53d1 \u540d\u4e3a Environment call from U-mode \u7684\u5f02\u5e38\uff0c //\u5e76 Trap \u8fdb\u5165 S \u6a21\u5f0f\u6267\u884c\u6279\u5904\u7406\u7cfb\u7edf\u9488\u5bf9\u8fd9\u4e2a\u5f02\u5e38\u7279\u522b\u63d0\u4f9b\u7684\u670d\u52a1\u4ee3\u7801 //\u6211\u4eec\u77e5\u9053\u7cfb\u7edf\u8c03\u7528\u5b9e\u9645\u4e0a\u662f\u6c47\u7f16\u6307\u4ee4\u7ea7\u7684\u4e8c\u8fdb\u5236\u63a5\u53e3\uff0c\u56e0\u6b64\u8fd9\u91cc\u7ed9\u51fa\u7684\u53ea\u662f\u4f7f\u7528 Rust \u8bed\u8a00\u63cf\u8ff0\u7684 API \u7248\u672c\u3002 //\u5728\u5b9e\u9645\u8c03\u7528\u7684\u65f6\u5019\uff0c\u6211\u4eec\u9700\u8981\u6309\u7167 RISC-V \u8c03\u7528\u89c4\u8303\uff08\u5373ABI\u683c\u5f0f\uff09\u5728\u5408\u9002\u7684\u5bc4\u5b58\u5668\u4e2d\u653e\u7f6e\u7cfb\u7edf\u8c03\u7528\u7684\u53c2\u6570\uff0c //\u7136\u540e\u6267\u884c ecall \u6307\u4ee4\u89e6\u53d1 Trap\u3002\u5728 Trap \u56de\u5230 U \u6a21\u5f0f\u7684\u5e94\u7528\u7a0b\u5e8f\u4ee3\u7801\u4e4b\u540e\uff0c //\u4f1a\u4ece ecall \u7684\u4e0b\u4e00\u6761\u6307\u4ee4\u7ee7\u7eed\u6267\u884c\uff0c\u540c\u65f6\u6211\u4eec\u80fd\u591f\u6309\u7167\u8c03\u7528\u89c4\u8303\u5728\u5408\u9002\u7684\u5bc4\u5b58\u5668\u4e2d\u8bfb\u53d6\u8fd4\u56de\u503c //\u5728 RISC-V \u8c03\u7528\u89c4\u8303\u4e2d\uff0c\u548c\u51fd\u6570\u8c03\u7528\u7684 ABI \u60c5\u5f62\u7c7b\u4f3c\uff0c\u7ea6\u5b9a\u5bc4\u5b58\u5668 a0~a6 \u4fdd\u5b58\u7cfb\u7edf\u8c03\u7528\u7684\u53c2\u6570\uff0c //a0~a1 \u4fdd\u5b58\u7cfb\u7edf\u8c03\u7528\u7684\u8fd4\u56de\u503c\u3002\u6709\u4e9b\u8bb8\u4e0d\u540c\u7684\u662f\u5bc4\u5b58\u5668 a7 \u7528\u6765\u4f20\u9012 syscall ID\uff0c //\u8fd9\u662f\u56e0\u4e3a\u6240\u6709\u7684 syscall \u90fd\u662f\u901a\u8fc7 ecall \u6307\u4ee4\u89e6\u53d1\u7684\uff0c //\u9664\u4e86\u5404\u8f93\u5165\u53c2\u6570\u4e4b\u5916\u6211\u4eec\u8fd8\u989d\u5916\u9700\u8981\u4e00\u4e2a\u5bc4\u5b58\u5668\u6765\u4fdd\u5b58\u8981\u8bf7\u6c42\u54ea\u4e2a\u7cfb\u7edf\u8c03\u7528\u3002 //\u7531\u4e8e\u8fd9\u8d85\u51fa\u4e86 Rust \u8bed\u8a00\u7684\u8868\u8fbe\u80fd\u529b\uff0c //\u6211\u4eec\u9700\u8981\u5728\u4ee3\u7801\u4e2d\u4f7f\u7528\u5185\u5d4c\u6c47\u7f16\u6765\u5b8c\u6210\u53c2\u6570/\u8fd4\u56de\u503c\u7ed1\u5b9a\u548c ecall \u6307\u4ee4\u7684\u63d2\u5165 use core::arch::asm; const SYSCALL_WRITE: usize = 64; const SYSCALL_EXIT: usize = 93; fn syscall(id: usize, args: [usize; 3]) -> isize{ let mut ret: isize; unsafe{ asm!( \"ecall\", inlateout(\"x10\") args[0] => ret, in(\"x11\") args[1], in(\"x12\") args[2], in(\"x17\") id ); } //\u5728\u7b2c\u4e00\u7ae0\u4e2d\uff0c\u6211\u4eec\u66fe\u7ecf\u4f7f\u7528 global_asm! \u5b8f\u6765\u5d4c\u5165\u5168\u5c40\u6c47\u7f16\u4ee3\u7801\uff0c //\u800c\u8fd9\u91cc\u7684 asm! \u5b8f\u53ef\u4ee5\u5c06\u6c47\u7f16\u4ee3\u7801\u5d4c\u5165\u5230\u5c40\u90e8\u7684\u51fd\u6570\u4e0a\u4e0b\u6587\u4e2d\u3002 //\u76f8\u6bd4 global_asm! \uff0c asm! \u5b8f\u53ef\u4ee5\u83b7\u53d6\u4e0a\u4e0b\u6587\u4e2d\u7684\u53d8\u91cf\u4fe1\u606f\u5e76\u5141\u8bb8\u5d4c\u5165\u7684\u6c47\u7f16\u4ee3\u7801\u5bf9\u8fd9\u4e9b\u53d8\u91cf\u8fdb\u884c\u64cd\u4f5c\u3002 //\u7531\u4e8e\u7f16\u8bd1\u5668\u7684\u80fd\u529b\u4e0d\u8db3\u4ee5\u5224\u5b9a\u63d2\u5165\u6c47\u7f16\u4ee3\u7801\u8fd9\u4e2a\u884c\u4e3a\u7684\u5b89\u5168\u6027\uff0c //\u6240\u4ee5\u6211\u4eec\u9700\u8981\u5c06\u5176\u5305\u88f9\u5728 unsafe \u5757\u4e2d\u81ea\u5df1\u6765\u5bf9\u5b83\u8d1f\u8d23 ret } // \u5c31\u662f\u8c03\u7528rustsbi\u63d0\u4f9b\u7684\u7cfb\u7edf\u8c03\u7528 pub fn sys_write(fd: usize, buffer: &[u8]) -> isize{ syscall(SYSCALL_WRITE, [fd, buffer.as_ptr() as usize, buffer.len()]) } pub fn sys_exit(exit_code: i32) -> isize { syscall(SYSCALL_EXIT, [exit_code as usize, 0, 0]) } //\u518d\u8fdb\u884c\u5c01\u88c5\uff0c\u4fbf\u4e8e\u5e94\u7528\u7a0b\u5e8f\u8c03\u7528 /* /// \u529f\u80fd\uff1a\u5c06\u5185\u5b58\u4e2d\u7f13\u51b2\u533a\u4e2d\u7684\u6570\u636e\u5199\u5165\u6587\u4ef6\u3002 /// \u53c2\u6570\uff1a`fd` \u8868\u793a\u5f85\u5199\u5165\u6587\u4ef6\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\uff1b /// `buf` \u8868\u793a\u5185\u5b58\u4e2d\u7f13\u51b2\u533a\u7684\u8d77\u59cb\u5730\u5740\uff1b /// `len` \u8868\u793a\u5185\u5b58\u4e2d\u7f13\u51b2\u533a\u7684\u957f\u5ea6\u3002 /// \u8fd4\u56de\u503c\uff1a\u8fd4\u56de\u6210\u529f\u5199\u5165\u7684\u957f\u5ea6\u3002 /// syscall ID\uff1a64 fn sys_write(fd: usize, buf: *const u8, len: usize) -> isize; /// \u529f\u80fd\uff1a\u9000\u51fa\u5e94\u7528\u7a0b\u5e8f\u5e76\u5c06\u8fd4\u56de\u503c\u544a\u77e5\u6279\u5904\u7406\u7cfb\u7edf\u3002 /// \u53c2\u6570\uff1a`xstate` \u8868\u793a\u5e94\u7528\u7a0b\u5e8f\u7684\u8fd4\u56de\u503c\u3002 /// \u8fd4\u56de\u503c\uff1a\u8be5\u7cfb\u7edf\u8c03\u7528\u4e0d\u5e94\u8be5\u8fd4\u56de\u3002 /// syscall ID\uff1a93 fn sys_exit(xstate: usize) -> !; */ user/src/console.rs use core::fmt::{self, Write}; use super::write; struct Stdout; const STDOUT: usize = 1; impl Write for Stdout{ fn write_str(&mut self, s: &str) -> fmt::Result{ write(STDOUT, s.as_bytes()); Ok(()) } //\u6211\u4eec\u628a console \u5b50\u6a21\u5757\u4e2d Stdout::write_str \u6539\u6210\u57fa\u4e8e write \u7684\u5b9e\u73b0\uff0c //\u4e14\u4f20\u5165\u7684 fd \u53c2\u6570\u8bbe\u7f6e\u4e3a 1\uff0c\u5b83\u4ee3\u8868\u6807\u51c6\u8f93\u51fa\uff0c \u4e5f\u5c31\u662f\u8f93\u51fa\u5230\u5c4f\u5e55 } pub fn print(args: fmt::Arguments){ Stdout.write_fmt(args).unwrap(); } #[macro_export] macro_rules! print{ ($fmt: literal $(, $($args: tt)+)?) => { $crate::console::print(format_args!($fmt $(, $($arg)+)?)); } } #[macro_export] macro_rules! println{ ($fmt: literal $(, $($arg: tt)+)?) => { $crate::console::print(format_args!(concat!($fmt, \"\\n\") $(, $($arg)+)?)); } } user/src/lang_items.rs use crate::println; #[panic_handler] fn panic_handler(panic_info: &core::panic::PanicInfo) -> ! { let err = panic_info.message().unwrap(); if let Some(location) = panic_info.location() { println!(\"Panicked at {}:{}, {}\", location.file(), location.line(), err); } else{ println!(\"Panicked: {}\", err); } loop {} } // \u9664\u4e86\u6ca1\u6709shutdown\uff0c\u6ca1\u6709\u672c\u8d28\u533a\u522b user/src/lib.rs #![no_std] #![feature(panic_info_message)] // \u4e3a\u4e86\u83b7\u53d6panic\u7684\u4fe1\u606f #![feature(linkage)] // \u4e3a\u4e86\u652f\u6301\u5f31\u8fde\u63a5 pub mod console; mod syscall; mod lang_items; #[no_mangle] #[link_section = \".text.entry\"] //\u4f7f\u7528 Rust \u7684\u5b8f\u5c06 _start \u8fd9\u6bb5\u4ee3\u7801\u7f16\u8bd1\u540e\u7684\u6c47\u7f16\u4ee3\u7801\u4e2d\u653e\u5728\u4e00\u4e2a\u540d\u4e3a .text.entry \u7684\u4ee3\u7801\u6bb5\u4e2d\uff0c //\u65b9\u4fbf\u6211\u4eec\u5728\u540e\u7eed\u94fe\u63a5\u7684\u65f6\u5019\u8c03\u6574\u5b83\u7684\u4f4d\u7f6e\u4f7f\u5f97\u5b83\u80fd\u591f\u4f5c\u4e3a\u7528\u6237\u5e93\u7684\u5165\u53e3 pub extern \"C\" fn _start() -> ! { clear_bss(); //\u624b\u52a8\u6e05\u7a7a\u9700\u8981\u96f6\u521d\u59cb\u5316\u7684 .bss \u6bb5 exit(main()); panic!(\"unreachable after sys_exit!\"); } //\u6211\u4eec\u4f7f\u7528 Rust \u7684\u5b8f\u5c06\u5176\u51fd\u6570\u7b26\u53f7 main \u6807\u5fd7\u4e3a\u5f31\u94fe\u63a5\u3002\u8fd9\u6837\u5728\u6700\u540e\u94fe\u63a5\u7684\u65f6\u5019\uff0c //\u867d\u7136\u5728 lib.rs \u548c bin \u76ee\u5f55\u4e0b\u7684\u67d0\u4e2a\u5e94\u7528\u7a0b\u5e8f\u90fd\u6709 main \u7b26\u53f7\uff0c //\u4f46\u7531\u4e8e lib.rs \u4e2d\u7684 main \u7b26\u53f7\u662f\u5f31\u94fe\u63a5\uff0c\u94fe\u63a5\u5668\u4f1a\u4f7f\u7528 bin \u76ee\u5f55\u4e0b\u7684\u5e94\u7528\u4e3b\u903b\u8f91\u4f5c\u4e3a main \u3002 //\u8fd9\u91cc\u6211\u4eec\u4e3b\u8981\u662f\u8fdb\u884c\u67d0\u79cd\u7a0b\u5ea6\u4e0a\u7684\u4fdd\u62a4\uff0c\u5982\u679c\u5728 bin \u76ee\u5f55\u4e0b\u627e\u4e0d\u5230\u4efb\u4f55 main \uff0c //\u90a3\u4e48\u7f16\u8bd1\u4e5f\u80fd\u591f\u901a\u8fc7\uff0c\u4f46\u4f1a\u5728\u8fd0\u884c\u65f6\u62a5\u9519\u3002 #[linkage = \"weak\"] #[no_mangle] fn main() -> i32 { panic!(\"Cannot find main\"); } fn clear_bss(){ extern \"C\" { fn start_bss(); fn end_bss(); } (start_bss as usize..end_bss as usize).for_each(|addr|{ unsafe{ (addr as *mut u8).write_volatile(0);} }); } use syscall::*; pub fn write(fd: usize, buf: &[u8]) -> isize {sys_write(fd, buf)} pub fn exit(exit_code: i32) -> isize {sys_exit(exit_code)} // \u8fdb\u4e00\u6b65\u5c01\u88c5\uff0c\u4ece\u800c\u66f4\u52a0\u63a5\u8fd1Linux\u7b49\u5e73\u53f0\u7684\u5b9e\u9645\u7cfb\u7edf\u8c03\u7528\u63a5\u53e3 user/src/bin/00hello_world.rs #![no_std] #![no_main] #[macro_use] extern crate user_lib; // \u5f15\u5165\u5916\u90e8\u5e93 // \u5e93\u540d \u4ee5Cargo\u3002toml \u6587\u4ef6\u89c4\u5b9a\u4e3a\u4e3b #[no_mangle] fn main() -> i32{ println!(\"Hello, world!\"); 0 } Hello, world! user/src/bin/01store_fault.rs #![no_std] #![no_main] #[macro_use] extern crate user_lib; #[no_mangle] fn main() -> i32{ println!(\"Into Test store_fault, we will insert an invalid store operation...\"); println!(\"Kernel should kill this application!\"); unsafe{(0x0 as *mut u8).write_volatile(0);} // \u8bbf\u95ee\u4e00\u4e2a\u975e\u6cd5\u7684\u7269\u7406\u5730\u5740 0 } Into Test store_fault, we will insert an invalid store operation... Kernel should kill this application! Segmentation fault (core dumped) user/src/bin/02priv_inst.rs #![no_std] #![no_main] #[macro_use] extern crate user_lib; use core::arch::asm; #[no_mangle] fn main() -> i32{ println!(\"Try to execute privileged instruction in U Mode\"); println!(\"Kernel should kill this application!\"); unsafe{ asm!(\"sret\"); // \u5728\u7528\u6237\u6001\u6267\u884c\u5185\u6838\u6001\u7684\u7279\u6743\u6307\u4ee4 sret } 0 } Try to execute privileged instruction in U Mode Kernel should kill this application! Illegal instruction (core dumped) user/src/bin/03priv_csr.rs #![no_std] #![no_main] #[macro_use] extern crate user_lib; use riscv::register::sstatus::{self, SPP}; #[no_mangle] fn main() -> i32{ println!(\"Try to access privileged CSR in U Mode\"); println!(\"Kernel should kill this application!\"); unsafe{ sstatus::set_spp(SPP::User); } // \u5728\u7528\u6237\u6001\u4fee\u6539\u5185\u6838\u6001CSR sstatus 0 } Try to access privileged CSR in U Mode Kernel should kill this application! Illegal instruction (core dumped) user/Makefile TARGET := riscv64gc-unknown-none-elf MODE := release APP_DIR := src/bin TARGET_DIR := target/$(TARGET)/$(MODE) APPS := $(wildcard $(APP_DIR)/*.rs) ELFS := $(patsubst $(APP_DIR)/%.rs, $(TARGET_DIR)/%, $(APPS)) BINS := $(patsubst $(APP_DIR)/%.rs, $(TARGET_DIR)/%.bin, $(APPS)) OBJDUMP := rust-objdump --arch-name=riscv64 OBJCOPY := rust-objcopy --binary-architecture=riscv64 elf: @cargo build --release @echo $(APPS) @echo $(ELFS) @echo $(BINS) binary: elf $(foreach elf, $(ELFS), $(OBJCOPY) $(elf) --strip-all -O binary $(patsubst $(TARGET_DIR)/%, $(TARGET_DIR)/%.bin, $(elf));) build: binary \u53bb\u6389\u5e93\u51fd\u6570\u7684\u5f15\u7528\u4f1a\u600e\u6837 \u56e0\u4e3a #![no_std] println! \u90fd\u5f97\u81ea\u5df1\u5b9e\u73b0\uff0c\u6240\u4ee5\u4e0d\u80fd\u53bb\u6389 \u6267\u884c\u6d41\u7a0b _start -> clear_bss -> main -> exit","title":"\u751f\u6210\u5e94\u7528\u7a0b\u5e8f"},{"location":"ch2%E7%94%9F%E6%88%90%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/#_1","text":"","title":"\u751f\u6210\u80fd\u88ab\u5185\u6838\u8bc6\u522b\u7684\u5e94\u7528\u7a0b\u5e8f"},{"location":"ch2%E7%94%9F%E6%88%90%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/#_2","text":"./os/src Rust 13 Files 372 Lines Assembly 2 Files 58 Lines \u251c\u2500\u2500 bootloader \u2502 \u251c\u2500\u2500 rustsbi-k210.bin \u2502 \u2514\u2500\u2500 rustsbi-qemu.bin \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 os \u2502 \u251c\u2500\u2500 build.rs(\u65b0\u589e\uff1a\u751f\u6210 link_app.S \u5c06\u5e94\u7528\u4f5c\u4e3a\u4e00\u4e2a\u6570\u636e\u6bb5\u94fe\u63a5\u5230\u5185\u6838) \u2502 \u251c\u2500\u2500 Cargo.toml \u2502 \u251c\u2500\u2500 Makefile(\u4fee\u6539\uff1a\u6784\u5efa\u5185\u6838\u4e4b\u524d\u5148\u6784\u5efa\u5e94\u7528) \u2502 \u2514\u2500\u2500 src \u2502 \u251c\u2500\u2500 batch.rs(\u65b0\u589e\uff1a\u5b9e\u73b0\u4e86\u4e00\u4e2a\u7b80\u5355\u7684\u6279\u5904\u7406\u7cfb\u7edf) \u2502 \u251c\u2500\u2500 console.rs \u2502 \u251c\u2500\u2500 entry.asm \u2502 \u251c\u2500\u2500 lang_items.rs \u2502 \u251c\u2500\u2500 link_app.S(\u6784\u5efa\u4ea7\u7269\uff0c\u7531 os/build.rs \u8f93\u51fa) \u2502 \u251c\u2500\u2500 linker-k210.ld \u2502 \u251c\u2500\u2500 linker-qemu.ld \u2502 \u251c\u2500\u2500 main.rs(\u4fee\u6539\uff1a\u4e3b\u51fd\u6570\u4e2d\u9700\u8981\u521d\u59cb\u5316 Trap \u5904\u7406\u5e76\u52a0\u8f7d\u548c\u6267\u884c\u5e94\u7528) \u2502 \u251c\u2500\u2500 sbi.rs \u2502 \u251c\u2500\u2500 sync(\u65b0\u589e\uff1a\u540c\u6b65\u5b50\u6a21\u5757 sync \uff0c\u76ee\u524d\u552f\u4e00\u529f\u80fd\u662f\u63d0\u4f9b UPSafeCell) \u2502 \u2502 \u251c\u2500\u2500 mod.rs \u2502 \u2502 \u2514\u2500\u2500 up.rs(\u5305\u542b UPSafeCell\uff0c\u5b83\u53ef\u4ee5\u5e2e\u52a9\u6211\u4eec\u4ee5\u66f4 Rust \u7684\u65b9\u5f0f\u4f7f\u7528\u5168\u5c40\u53d8\u91cf) \u2502 \u251c\u2500\u2500 syscall(\u65b0\u589e\uff1a\u7cfb\u7edf\u8c03\u7528\u5b50\u6a21\u5757 syscall) \u2502 \u2502 \u251c\u2500\u2500 fs.rs(\u5305\u542b\u6587\u4ef6 I/O \u76f8\u5173\u7684 syscall) \u2502 \u2502 \u251c\u2500\u2500 mod.rs(\u63d0\u4f9b syscall \u65b9\u6cd5\u6839\u636e syscall ID \u8fdb\u884c\u5206\u53d1\u5904\u7406) \u2502 \u2502 \u2514\u2500\u2500 process.rs(\u5305\u542b\u4efb\u52a1\u5904\u7406\u76f8\u5173\u7684 syscall) \u2502 \u2514\u2500\u2500 trap(\u65b0\u589e\uff1aTrap \u76f8\u5173\u5b50\u6a21\u5757 trap) \u2502 \u251c\u2500\u2500 context.rs(\u5305\u542b Trap \u4e0a\u4e0b\u6587 TrapContext) \u2502 \u251c\u2500\u2500 mod.rs(\u5305\u542b Trap \u5904\u7406\u5165\u53e3 trap_handler) \u2502 \u2514\u2500\u2500 trap.S(\u5305\u542b Trap \u4e0a\u4e0b\u6587\u4fdd\u5b58\u4e0e\u6062\u590d\u7684\u6c47\u7f16\u4ee3\u7801) \u251c\u2500\u2500 README.md \u251c\u2500\u2500 rust-toolchain \u251c\u2500\u2500 tools \u2502 \u251c\u2500\u2500 kflash.py \u2502 \u251c\u2500\u2500 LICENSE \u2502 \u251c\u2500\u2500 package.json \u2502 \u251c\u2500\u2500 README.rst \u2502 \u2514\u2500\u2500 setup.py \u2514\u2500\u2500 user(\u65b0\u589e\uff1a\u5e94\u7528\u6d4b\u4f8b\u4fdd\u5b58\u5728 user \u76ee\u5f55\u4e0b) \u251c\u2500\u2500 Cargo.toml \u251c\u2500\u2500 Makefile \u2514\u2500\u2500 src \u251c\u2500\u2500 bin(\u57fa\u4e8e\u7528\u6237\u5e93 user_lib \u5f00\u53d1\u7684\u5e94\u7528\uff0c\u6bcf\u4e2a\u5e94\u7528\u653e\u5728\u4e00\u4e2a\u6e90\u6587\u4ef6\u4e2d) \u2502 \u251c\u2500\u2500 00hello_world.rs \u2502 \u251c\u2500\u2500 01store_fault.rs \u2502 \u251c\u2500\u2500 02power.rs \u2502 \u251c\u2500\u2500 03priv_inst.rs \u2502 \u2514\u2500\u2500 04priv_csr.rs \u251c\u2500\u2500 console.rs \u251c\u2500\u2500 lang_items.rs \u251c\u2500\u2500 lib.rs(\u7528\u6237\u5e93 user_lib) \u251c\u2500\u2500 linker.ld(\u5e94\u7528\u7684\u94fe\u63a5\u811a\u672c) \u2514\u2500\u2500 syscall.rs(\u5305\u542b syscall \u65b9\u6cd5\u751f\u6210\u5b9e\u9645\u7528\u4e8e\u7cfb\u7edf\u8c03\u7528\u7684\u6c47\u7f16\u6307\u4ee4\uff0c \u5404\u4e2a\u5177\u4f53\u7684 syscall \u90fd\u662f\u901a\u8fc7 syscall \u6765\u5b9e\u73b0\u7684)","title":"\u7b2c\u4e8c\u7ae0\u4ee3\u7801\u6811"},{"location":"ch2%E7%94%9F%E6%88%90%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/#_3","text":"\u672c\u8282\u5b9e\u73b0\u7684\u662f\u80fd\u591f\u88ab\u5185\u6838\u8bc6\u522b\u5e76\u9010\u4e2a\u52a0\u8f7d\u8fd0\u884c\u7684\u5e94\u7528\u7a0b\u5e8f \u8981\u4fdd\u8bc1\u5e94\u7528\u7a0b\u5e8f\u5728\u7528\u6237\u6001\u6b63\u5e38\u8fd0\u884c\uff0c\u80fd\u591f\u88abqemu-riscv64\u7528\u6237\u6001\u6a21\u62df\u5668 \u8bc6\u522b\u5e76\u6267\u884c \u6240\u4ee5\u672c\u8282\u7684\u4ee3\u7801\u90fd\u5728user\u76ee\u5f55\u4e0b","title":"\u672c\u8282\u6587\u4ef6\u89e3\u6790"},{"location":"ch2%E7%94%9F%E6%88%90%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/#usercargoconfig","text":"[build] target = \"riscv64gc-unknown-none-elf\" [target.riscv64gc-unknown-none-elf] rustflags = [ \"-Clink-args=-Tsrc/linker.ld\" ]","title":"user/.cargo/config"},{"location":"ch2%E7%94%9F%E6%88%90%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/#usercargotoml","text":"[package] name = \"user_lib\" version = \"0.1.0\" edition = \"2021\" # \u5c06\u5e93\u7684\u540d\u5b57\u8bbe\u7f6e\u4e3a\uff1a user_lib # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html [dependencies] riscv = { git = \"https://github.com/rcore-os/riscv\", features = [\"inline-asm\"] }","title":"user/Cargo.toml"},{"location":"ch2%E7%94%9F%E6%88%90%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/#usersrclinkerld","text":"OUTPUT_ARCH(riscv) ENTRY(_start) # \u5728lib.rs \u4e2d\u5b9a\u4e49\u4e86\u7528\u6237\u5e93\u7684\u5165\u5e93\u70b9 _start # \u901a\u8fc7rust\u7684\u5b8f #[link_section = \".text.entry\"] # \u5c06_start\u7684\u90a3\u6bb5\u4ee3\u7801\u7f16\u8bd1\u540e\u7684\u6c47\u7f16\u4ee3\u7801\u653e\u5728\u4e00\u4e2a\u540d\u4e3a .text.entry \u7684\u6bb5\u4e2d BASE_ADDRESS = 0x80400000; # \u7a0b\u5e8f\u7684\u8d77\u59cb\u5730\u5740\u4e3a 0x80400000 SECTIONS{ . = BASE_ADDRESS; .text : { *(.text.entry) # \u5c06 _start \u6240\u5728\u7684 .text.entry \u6bb5\u653e\u5728\u6574\u4e2a\u7a0b\u5e8f\u7684\u5f00\u5934 # \u5373\u653e\u5728 0x80400000\u5904 *(.text .text.*) } .rodata : { *(.rodata .rodata.*) *(.srodata .srodata.*) } .data : { *(.data .data.*) *(.sdata .sdata.*) } .bss : { start_bss = .; *(.bss .bss.*) *(.sbss .sbss.*) end_bss = .; # \u8fdb\u5165\u7528\u6237\u5e93\u5165\u53e3\u4e4b\u540e\uff0c\u8981\u624b\u52a8\u6e05\u7a7a\u9700\u8981\u96f6\u521d\u59cb\u5316\u7684 .bss \u6bb5 # \u7531\u4e8e\u5185\u6838\u76ee\u524d\u8fd8\u6ca1\u6709\u8fd9\u4e2a\u80fd\u529b\uff0c\u53ea\u80fd\u5728\u7528\u6237\u5e93\u4e2d\u5b8c\u6210 # \u8fd9\u91cc\u7684start_bss \u3001 end_bss \u4fbf\u4e8e\u521d\u59cb\u5316 } /DISCARD/ : { *(.eh_frame) *(.debug*) } }","title":"user/src/linker.ld"},{"location":"ch2%E7%94%9F%E6%88%90%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/#usersrcsyscallrs","text":"// \u5728\u5b50\u6a21\u5757 syscall \u4e2d\u6211\u4eec\u4f5c\u4e3a\u5e94\u7528\u7a0b\u5e8f\u6765\u901a\u8fc7 ecall \u8c03\u7528\u6279\u5904\u7406\u7cfb\u7edf\u63d0\u4f9b\u7684\u63a5\u53e3\uff0c //\u7531\u4e8e\u5e94\u7528\u7a0b\u5e8f\u8fd0\u884c\u5728\u7528\u6237\u6001\uff08\u5373 U \u6a21\u5f0f\uff09\uff0c //ecall \u6307\u4ee4\u4f1a\u89e6\u53d1 \u540d\u4e3a Environment call from U-mode \u7684\u5f02\u5e38\uff0c //\u5e76 Trap \u8fdb\u5165 S \u6a21\u5f0f\u6267\u884c\u6279\u5904\u7406\u7cfb\u7edf\u9488\u5bf9\u8fd9\u4e2a\u5f02\u5e38\u7279\u522b\u63d0\u4f9b\u7684\u670d\u52a1\u4ee3\u7801 //\u6211\u4eec\u77e5\u9053\u7cfb\u7edf\u8c03\u7528\u5b9e\u9645\u4e0a\u662f\u6c47\u7f16\u6307\u4ee4\u7ea7\u7684\u4e8c\u8fdb\u5236\u63a5\u53e3\uff0c\u56e0\u6b64\u8fd9\u91cc\u7ed9\u51fa\u7684\u53ea\u662f\u4f7f\u7528 Rust \u8bed\u8a00\u63cf\u8ff0\u7684 API \u7248\u672c\u3002 //\u5728\u5b9e\u9645\u8c03\u7528\u7684\u65f6\u5019\uff0c\u6211\u4eec\u9700\u8981\u6309\u7167 RISC-V \u8c03\u7528\u89c4\u8303\uff08\u5373ABI\u683c\u5f0f\uff09\u5728\u5408\u9002\u7684\u5bc4\u5b58\u5668\u4e2d\u653e\u7f6e\u7cfb\u7edf\u8c03\u7528\u7684\u53c2\u6570\uff0c //\u7136\u540e\u6267\u884c ecall \u6307\u4ee4\u89e6\u53d1 Trap\u3002\u5728 Trap \u56de\u5230 U \u6a21\u5f0f\u7684\u5e94\u7528\u7a0b\u5e8f\u4ee3\u7801\u4e4b\u540e\uff0c //\u4f1a\u4ece ecall \u7684\u4e0b\u4e00\u6761\u6307\u4ee4\u7ee7\u7eed\u6267\u884c\uff0c\u540c\u65f6\u6211\u4eec\u80fd\u591f\u6309\u7167\u8c03\u7528\u89c4\u8303\u5728\u5408\u9002\u7684\u5bc4\u5b58\u5668\u4e2d\u8bfb\u53d6\u8fd4\u56de\u503c //\u5728 RISC-V \u8c03\u7528\u89c4\u8303\u4e2d\uff0c\u548c\u51fd\u6570\u8c03\u7528\u7684 ABI \u60c5\u5f62\u7c7b\u4f3c\uff0c\u7ea6\u5b9a\u5bc4\u5b58\u5668 a0~a6 \u4fdd\u5b58\u7cfb\u7edf\u8c03\u7528\u7684\u53c2\u6570\uff0c //a0~a1 \u4fdd\u5b58\u7cfb\u7edf\u8c03\u7528\u7684\u8fd4\u56de\u503c\u3002\u6709\u4e9b\u8bb8\u4e0d\u540c\u7684\u662f\u5bc4\u5b58\u5668 a7 \u7528\u6765\u4f20\u9012 syscall ID\uff0c //\u8fd9\u662f\u56e0\u4e3a\u6240\u6709\u7684 syscall \u90fd\u662f\u901a\u8fc7 ecall \u6307\u4ee4\u89e6\u53d1\u7684\uff0c //\u9664\u4e86\u5404\u8f93\u5165\u53c2\u6570\u4e4b\u5916\u6211\u4eec\u8fd8\u989d\u5916\u9700\u8981\u4e00\u4e2a\u5bc4\u5b58\u5668\u6765\u4fdd\u5b58\u8981\u8bf7\u6c42\u54ea\u4e2a\u7cfb\u7edf\u8c03\u7528\u3002 //\u7531\u4e8e\u8fd9\u8d85\u51fa\u4e86 Rust \u8bed\u8a00\u7684\u8868\u8fbe\u80fd\u529b\uff0c //\u6211\u4eec\u9700\u8981\u5728\u4ee3\u7801\u4e2d\u4f7f\u7528\u5185\u5d4c\u6c47\u7f16\u6765\u5b8c\u6210\u53c2\u6570/\u8fd4\u56de\u503c\u7ed1\u5b9a\u548c ecall \u6307\u4ee4\u7684\u63d2\u5165 use core::arch::asm; const SYSCALL_WRITE: usize = 64; const SYSCALL_EXIT: usize = 93; fn syscall(id: usize, args: [usize; 3]) -> isize{ let mut ret: isize; unsafe{ asm!( \"ecall\", inlateout(\"x10\") args[0] => ret, in(\"x11\") args[1], in(\"x12\") args[2], in(\"x17\") id ); } //\u5728\u7b2c\u4e00\u7ae0\u4e2d\uff0c\u6211\u4eec\u66fe\u7ecf\u4f7f\u7528 global_asm! \u5b8f\u6765\u5d4c\u5165\u5168\u5c40\u6c47\u7f16\u4ee3\u7801\uff0c //\u800c\u8fd9\u91cc\u7684 asm! \u5b8f\u53ef\u4ee5\u5c06\u6c47\u7f16\u4ee3\u7801\u5d4c\u5165\u5230\u5c40\u90e8\u7684\u51fd\u6570\u4e0a\u4e0b\u6587\u4e2d\u3002 //\u76f8\u6bd4 global_asm! \uff0c asm! \u5b8f\u53ef\u4ee5\u83b7\u53d6\u4e0a\u4e0b\u6587\u4e2d\u7684\u53d8\u91cf\u4fe1\u606f\u5e76\u5141\u8bb8\u5d4c\u5165\u7684\u6c47\u7f16\u4ee3\u7801\u5bf9\u8fd9\u4e9b\u53d8\u91cf\u8fdb\u884c\u64cd\u4f5c\u3002 //\u7531\u4e8e\u7f16\u8bd1\u5668\u7684\u80fd\u529b\u4e0d\u8db3\u4ee5\u5224\u5b9a\u63d2\u5165\u6c47\u7f16\u4ee3\u7801\u8fd9\u4e2a\u884c\u4e3a\u7684\u5b89\u5168\u6027\uff0c //\u6240\u4ee5\u6211\u4eec\u9700\u8981\u5c06\u5176\u5305\u88f9\u5728 unsafe \u5757\u4e2d\u81ea\u5df1\u6765\u5bf9\u5b83\u8d1f\u8d23 ret } // \u5c31\u662f\u8c03\u7528rustsbi\u63d0\u4f9b\u7684\u7cfb\u7edf\u8c03\u7528 pub fn sys_write(fd: usize, buffer: &[u8]) -> isize{ syscall(SYSCALL_WRITE, [fd, buffer.as_ptr() as usize, buffer.len()]) } pub fn sys_exit(exit_code: i32) -> isize { syscall(SYSCALL_EXIT, [exit_code as usize, 0, 0]) } //\u518d\u8fdb\u884c\u5c01\u88c5\uff0c\u4fbf\u4e8e\u5e94\u7528\u7a0b\u5e8f\u8c03\u7528 /* /// \u529f\u80fd\uff1a\u5c06\u5185\u5b58\u4e2d\u7f13\u51b2\u533a\u4e2d\u7684\u6570\u636e\u5199\u5165\u6587\u4ef6\u3002 /// \u53c2\u6570\uff1a`fd` \u8868\u793a\u5f85\u5199\u5165\u6587\u4ef6\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\uff1b /// `buf` \u8868\u793a\u5185\u5b58\u4e2d\u7f13\u51b2\u533a\u7684\u8d77\u59cb\u5730\u5740\uff1b /// `len` \u8868\u793a\u5185\u5b58\u4e2d\u7f13\u51b2\u533a\u7684\u957f\u5ea6\u3002 /// \u8fd4\u56de\u503c\uff1a\u8fd4\u56de\u6210\u529f\u5199\u5165\u7684\u957f\u5ea6\u3002 /// syscall ID\uff1a64 fn sys_write(fd: usize, buf: *const u8, len: usize) -> isize; /// \u529f\u80fd\uff1a\u9000\u51fa\u5e94\u7528\u7a0b\u5e8f\u5e76\u5c06\u8fd4\u56de\u503c\u544a\u77e5\u6279\u5904\u7406\u7cfb\u7edf\u3002 /// \u53c2\u6570\uff1a`xstate` \u8868\u793a\u5e94\u7528\u7a0b\u5e8f\u7684\u8fd4\u56de\u503c\u3002 /// \u8fd4\u56de\u503c\uff1a\u8be5\u7cfb\u7edf\u8c03\u7528\u4e0d\u5e94\u8be5\u8fd4\u56de\u3002 /// syscall ID\uff1a93 fn sys_exit(xstate: usize) -> !; */","title":"user/src/syscall.rs"},{"location":"ch2%E7%94%9F%E6%88%90%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/#usersrcconsolers","text":"use core::fmt::{self, Write}; use super::write; struct Stdout; const STDOUT: usize = 1; impl Write for Stdout{ fn write_str(&mut self, s: &str) -> fmt::Result{ write(STDOUT, s.as_bytes()); Ok(()) } //\u6211\u4eec\u628a console \u5b50\u6a21\u5757\u4e2d Stdout::write_str \u6539\u6210\u57fa\u4e8e write \u7684\u5b9e\u73b0\uff0c //\u4e14\u4f20\u5165\u7684 fd \u53c2\u6570\u8bbe\u7f6e\u4e3a 1\uff0c\u5b83\u4ee3\u8868\u6807\u51c6\u8f93\u51fa\uff0c \u4e5f\u5c31\u662f\u8f93\u51fa\u5230\u5c4f\u5e55 } pub fn print(args: fmt::Arguments){ Stdout.write_fmt(args).unwrap(); } #[macro_export] macro_rules! print{ ($fmt: literal $(, $($args: tt)+)?) => { $crate::console::print(format_args!($fmt $(, $($arg)+)?)); } } #[macro_export] macro_rules! println{ ($fmt: literal $(, $($arg: tt)+)?) => { $crate::console::print(format_args!(concat!($fmt, \"\\n\") $(, $($arg)+)?)); } }","title":"user/src/console.rs"},{"location":"ch2%E7%94%9F%E6%88%90%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/#usersrclang_itemsrs","text":"use crate::println; #[panic_handler] fn panic_handler(panic_info: &core::panic::PanicInfo) -> ! { let err = panic_info.message().unwrap(); if let Some(location) = panic_info.location() { println!(\"Panicked at {}:{}, {}\", location.file(), location.line(), err); } else{ println!(\"Panicked: {}\", err); } loop {} } // \u9664\u4e86\u6ca1\u6709shutdown\uff0c\u6ca1\u6709\u672c\u8d28\u533a\u522b","title":"user/src/lang_items.rs"},{"location":"ch2%E7%94%9F%E6%88%90%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/#usersrclibrs","text":"#![no_std] #![feature(panic_info_message)] // \u4e3a\u4e86\u83b7\u53d6panic\u7684\u4fe1\u606f #![feature(linkage)] // \u4e3a\u4e86\u652f\u6301\u5f31\u8fde\u63a5 pub mod console; mod syscall; mod lang_items; #[no_mangle] #[link_section = \".text.entry\"] //\u4f7f\u7528 Rust \u7684\u5b8f\u5c06 _start \u8fd9\u6bb5\u4ee3\u7801\u7f16\u8bd1\u540e\u7684\u6c47\u7f16\u4ee3\u7801\u4e2d\u653e\u5728\u4e00\u4e2a\u540d\u4e3a .text.entry \u7684\u4ee3\u7801\u6bb5\u4e2d\uff0c //\u65b9\u4fbf\u6211\u4eec\u5728\u540e\u7eed\u94fe\u63a5\u7684\u65f6\u5019\u8c03\u6574\u5b83\u7684\u4f4d\u7f6e\u4f7f\u5f97\u5b83\u80fd\u591f\u4f5c\u4e3a\u7528\u6237\u5e93\u7684\u5165\u53e3 pub extern \"C\" fn _start() -> ! { clear_bss(); //\u624b\u52a8\u6e05\u7a7a\u9700\u8981\u96f6\u521d\u59cb\u5316\u7684 .bss \u6bb5 exit(main()); panic!(\"unreachable after sys_exit!\"); } //\u6211\u4eec\u4f7f\u7528 Rust \u7684\u5b8f\u5c06\u5176\u51fd\u6570\u7b26\u53f7 main \u6807\u5fd7\u4e3a\u5f31\u94fe\u63a5\u3002\u8fd9\u6837\u5728\u6700\u540e\u94fe\u63a5\u7684\u65f6\u5019\uff0c //\u867d\u7136\u5728 lib.rs \u548c bin \u76ee\u5f55\u4e0b\u7684\u67d0\u4e2a\u5e94\u7528\u7a0b\u5e8f\u90fd\u6709 main \u7b26\u53f7\uff0c //\u4f46\u7531\u4e8e lib.rs \u4e2d\u7684 main \u7b26\u53f7\u662f\u5f31\u94fe\u63a5\uff0c\u94fe\u63a5\u5668\u4f1a\u4f7f\u7528 bin \u76ee\u5f55\u4e0b\u7684\u5e94\u7528\u4e3b\u903b\u8f91\u4f5c\u4e3a main \u3002 //\u8fd9\u91cc\u6211\u4eec\u4e3b\u8981\u662f\u8fdb\u884c\u67d0\u79cd\u7a0b\u5ea6\u4e0a\u7684\u4fdd\u62a4\uff0c\u5982\u679c\u5728 bin \u76ee\u5f55\u4e0b\u627e\u4e0d\u5230\u4efb\u4f55 main \uff0c //\u90a3\u4e48\u7f16\u8bd1\u4e5f\u80fd\u591f\u901a\u8fc7\uff0c\u4f46\u4f1a\u5728\u8fd0\u884c\u65f6\u62a5\u9519\u3002 #[linkage = \"weak\"] #[no_mangle] fn main() -> i32 { panic!(\"Cannot find main\"); } fn clear_bss(){ extern \"C\" { fn start_bss(); fn end_bss(); } (start_bss as usize..end_bss as usize).for_each(|addr|{ unsafe{ (addr as *mut u8).write_volatile(0);} }); } use syscall::*; pub fn write(fd: usize, buf: &[u8]) -> isize {sys_write(fd, buf)} pub fn exit(exit_code: i32) -> isize {sys_exit(exit_code)} // \u8fdb\u4e00\u6b65\u5c01\u88c5\uff0c\u4ece\u800c\u66f4\u52a0\u63a5\u8fd1Linux\u7b49\u5e73\u53f0\u7684\u5b9e\u9645\u7cfb\u7edf\u8c03\u7528\u63a5\u53e3","title":"user/src/lib.rs"},{"location":"ch2%E7%94%9F%E6%88%90%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/#usersrcbin00hello_worldrs","text":"#![no_std] #![no_main] #[macro_use] extern crate user_lib; // \u5f15\u5165\u5916\u90e8\u5e93 // \u5e93\u540d \u4ee5Cargo\u3002toml \u6587\u4ef6\u89c4\u5b9a\u4e3a\u4e3b #[no_mangle] fn main() -> i32{ println!(\"Hello, world!\"); 0 } Hello, world!","title":"user/src/bin/00hello_world.rs"},{"location":"ch2%E7%94%9F%E6%88%90%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/#usersrcbin01store_faultrs","text":"#![no_std] #![no_main] #[macro_use] extern crate user_lib; #[no_mangle] fn main() -> i32{ println!(\"Into Test store_fault, we will insert an invalid store operation...\"); println!(\"Kernel should kill this application!\"); unsafe{(0x0 as *mut u8).write_volatile(0);} // \u8bbf\u95ee\u4e00\u4e2a\u975e\u6cd5\u7684\u7269\u7406\u5730\u5740 0 } Into Test store_fault, we will insert an invalid store operation... Kernel should kill this application! Segmentation fault (core dumped)","title":"user/src/bin/01store_fault.rs"},{"location":"ch2%E7%94%9F%E6%88%90%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/#usersrcbin02priv_instrs","text":"#![no_std] #![no_main] #[macro_use] extern crate user_lib; use core::arch::asm; #[no_mangle] fn main() -> i32{ println!(\"Try to execute privileged instruction in U Mode\"); println!(\"Kernel should kill this application!\"); unsafe{ asm!(\"sret\"); // \u5728\u7528\u6237\u6001\u6267\u884c\u5185\u6838\u6001\u7684\u7279\u6743\u6307\u4ee4 sret } 0 } Try to execute privileged instruction in U Mode Kernel should kill this application! Illegal instruction (core dumped)","title":"user/src/bin/02priv_inst.rs"},{"location":"ch2%E7%94%9F%E6%88%90%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/#usersrcbin03priv_csrrs","text":"#![no_std] #![no_main] #[macro_use] extern crate user_lib; use riscv::register::sstatus::{self, SPP}; #[no_mangle] fn main() -> i32{ println!(\"Try to access privileged CSR in U Mode\"); println!(\"Kernel should kill this application!\"); unsafe{ sstatus::set_spp(SPP::User); } // \u5728\u7528\u6237\u6001\u4fee\u6539\u5185\u6838\u6001CSR sstatus 0 } Try to access privileged CSR in U Mode Kernel should kill this application! Illegal instruction (core dumped)","title":"user/src/bin/03priv_csr.rs"},{"location":"ch2%E7%94%9F%E6%88%90%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/#usermakefile","text":"TARGET := riscv64gc-unknown-none-elf MODE := release APP_DIR := src/bin TARGET_DIR := target/$(TARGET)/$(MODE) APPS := $(wildcard $(APP_DIR)/*.rs) ELFS := $(patsubst $(APP_DIR)/%.rs, $(TARGET_DIR)/%, $(APPS)) BINS := $(patsubst $(APP_DIR)/%.rs, $(TARGET_DIR)/%.bin, $(APPS)) OBJDUMP := rust-objdump --arch-name=riscv64 OBJCOPY := rust-objcopy --binary-architecture=riscv64 elf: @cargo build --release @echo $(APPS) @echo $(ELFS) @echo $(BINS) binary: elf $(foreach elf, $(ELFS), $(OBJCOPY) $(elf) --strip-all -O binary $(patsubst $(TARGET_DIR)/%, $(TARGET_DIR)/%.bin, $(elf));) build: binary \u53bb\u6389\u5e93\u51fd\u6570\u7684\u5f15\u7528\u4f1a\u600e\u6837 \u56e0\u4e3a #![no_std] println! \u90fd\u5f97\u81ea\u5df1\u5b9e\u73b0\uff0c\u6240\u4ee5\u4e0d\u80fd\u53bb\u6389","title":"user/Makefile"},{"location":"ch2%E7%94%9F%E6%88%90%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/#_4","text":"_start -> clear_bss -> main -> exit","title":"\u6267\u884c\u6d41\u7a0b"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/","text":"\u5b9e\u73b0\u5206\u65f6\u591a\u4efb\u52a1\u7cfb\u7edf\u4e0e\u62a2\u5360\u5f0f\u8c03\u7528 \u7b2c\u4e09\u7ae0\u4ee3\u7801\u6811 \u5206\u65f6\u591a\u4efb\u52a1\u7684\u4e3a\u4f8b ./os/src Rust 18 Files 511 Lines Assembly 3 Files 82 Lines \u251c\u2500\u2500 bootloader \u2502 \u251c\u2500\u2500 rustsbi-k210.bin \u2502 \u2514\u2500\u2500 rustsbi-qemu.bin \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 os \u2502 \u251c\u2500\u2500 build.rs \u2502 \u251c\u2500\u2500 Cargo.toml \u2502 \u251c\u2500\u2500 Makefile \u2502 \u2514\u2500\u2500 src \u2502 \u251c\u2500\u2500 batch.rs(\u79fb\u9664\uff1a\u529f\u80fd\u5206\u522b\u62c6\u5206\u5230 loader \u548c task \u4e24\u4e2a\u5b50\u6a21\u5757) \u2502 \u251c\u2500\u2500 config.rs(\u65b0\u589e\uff1a\u4fdd\u5b58\u5185\u6838\u7684\u4e00\u4e9b\u914d\u7f6e) \u2502 \u251c\u2500\u2500 console.rs \u2502 \u251c\u2500\u2500 entry.asm \u2502 \u251c\u2500\u2500 lang_items.rs \u2502 \u251c\u2500\u2500 link_app.S \u2502 \u251c\u2500\u2500 linker-k210.ld \u2502 \u251c\u2500\u2500 linker-qemu.ld \u2502 \u251c\u2500\u2500 loader.rs(\u65b0\u589e\uff1a\u5c06\u5e94\u7528\u52a0\u8f7d\u5230\u5185\u5b58\u5e76\u8fdb\u884c\u7ba1\u7406) \u2502 \u251c\u2500\u2500 main.rs(\u4fee\u6539\uff1a\u4e3b\u51fd\u6570\u8fdb\u884c\u4e86\u4fee\u6539) \u2502 \u251c\u2500\u2500 sbi.rs(\u4fee\u6539\uff1a\u5f15\u5165\u65b0\u7684 sbi call set_timer) \u2502 \u251c\u2500\u2500 sync \u2502 \u2502 \u251c\u2500\u2500 mod.rs \u2502 \u2502 \u2514\u2500\u2500 up.rs \u2502 \u251c\u2500\u2500 syscall(\u4fee\u6539\uff1a\u65b0\u589e\u82e5\u5e72 syscall) \u2502 \u2502 \u251c\u2500\u2500 fs.rs \u2502 \u2502 \u251c\u2500\u2500 mod.rs \u2502 \u2502 \u2514\u2500\u2500 process.rs \u2502 \u251c\u2500\u2500 task(\u65b0\u589e\uff1atask \u5b50\u6a21\u5757\uff0c\u4e3b\u8981\u8d1f\u8d23\u4efb\u52a1\u7ba1\u7406) \u2502 \u2502 \u251c\u2500\u2500 context.rs(\u5f15\u5165 Task \u4e0a\u4e0b\u6587 TaskContext) \u2502 \u2502 \u251c\u2500\u2500 mod.rs(\u5168\u5c40\u4efb\u52a1\u7ba1\u7406\u5668\u548c\u63d0\u4f9b\u7ed9\u5176\u4ed6\u6a21\u5757\u7684\u63a5\u53e3) \u2502 \u2502 \u251c\u2500\u2500 switch.rs(\u5c06\u4efb\u52a1\u5207\u6362\u7684\u6c47\u7f16\u4ee3\u7801\u89e3\u91ca\u4e3a Rust \u63a5\u53e3 __switch) \u2502 \u2502 \u251c\u2500\u2500 switch.S(\u4efb\u52a1\u5207\u6362\u7684\u6c47\u7f16\u4ee3\u7801) \u2502 \u2502 \u2514\u2500\u2500 task.rs(\u4efb\u52a1\u63a7\u5236\u5757 TaskControlBlock \u548c\u4efb\u52a1\u72b6\u6001 TaskStatus \u7684\u5b9a\u4e49) \u2502 \u251c\u2500\u2500 timer.rs(\u65b0\u589e\uff1a\u8ba1\u65f6\u5668\u76f8\u5173) \u2502 \u2514\u2500\u2500 trap \u2502 \u251c\u2500\u2500 context.rs \u2502 \u251c\u2500\u2500 mod.rs(\u4fee\u6539\uff1a\u65f6\u949f\u4e2d\u65ad\u76f8\u5e94\u5904\u7406) \u2502 \u2514\u2500\u2500 trap.S \u251c\u2500\u2500 README.md \u251c\u2500\u2500 rust-toolchain \u251c\u2500\u2500 tools \u2502 \u251c\u2500\u2500 kflash.py \u2502 \u251c\u2500\u2500 LICENSE \u2502 \u251c\u2500\u2500 package.json \u2502 \u251c\u2500\u2500 README.rst \u2502 \u2514\u2500\u2500 setup.py \u2514\u2500\u2500 user \u251c\u2500\u2500 build.py(\u65b0\u589e\uff1a\u4f7f\u7528 build.py \u6784\u5efa\u5e94\u7528\u4f7f\u5f97\u5b83\u4eec\u5360\u7528\u7684\u7269\u7406\u5730\u5740\u533a\u95f4\u4e0d\u76f8\u4ea4) \u251c\u2500\u2500 Cargo.toml \u251c\u2500\u2500 Makefile(\u4fee\u6539\uff1a\u4f7f\u7528 build.py \u6784\u5efa\u5e94\u7528) \u2514\u2500\u2500 src \u251c\u2500\u2500 bin(\u4fee\u6539\uff1a\u6362\u6210\u7b2c\u4e09\u7ae0\u6d4b\u4f8b) \u2502 \u251c\u2500\u2500 00power_3.rs \u2502 \u251c\u2500\u2500 01power_5.rs \u2502 \u251c\u2500\u2500 02power_7.rs \u2502 \u2514\u2500\u2500 03sleep.rs \u251c\u2500\u2500 console.rs \u251c\u2500\u2500 lang_items.rs \u251c\u2500\u2500 lib.rs \u251c\u2500\u2500 linker.ld \u2514\u2500\u2500 syscall.rs \u672c\u8282\u7684\u4efb\u52a1 \u672c\u8282\u5b9e\u73b0\u4e00\u4e2a\u652f\u6301 \u5bf9\u4e2d\u65ad\u7684\u5904\u7406\u548c\u5bf9\u5e94\u7528\u7a0b\u5e8f\u7684\u62a2\u5360\uff0c\u8bbe\u8ba1\u5b9e\u73b0\u66f4\u52a0\u516c\u5e73\u548c\u9ad8\u6548\u4ea4\u4e92\u7684\u62a2\u5360\u5f0f\u64cd\u4f5c\u7cfb\u7edf \u5f53\u5916\u8bbe\u60f3\u8981\u89e6\u53d1\u4e2d\u65ad\u7684\u65f6\u5019\u5219\u8f93\u5165\u4e00\u4e2a\u9ad8\u7535\u5e73\u6216\u6b63\u8fb9\u6cbf\uff0c\u5904\u7406\u5668\u4f1a\u5728\u6bcf\u6267\u884c\u5b8c\u4e00\u6761\u6307\u4ee4\u4e4b\u540e\u68c0\u67e5\u4e00\u4e0b\u8fd9\u6839\u7ebf\uff0c\u770b\u60c5\u51b5\u51b3\u5b9a\u662f\u7ee7\u7eed\u6267\u884c\u63a5\u4e0b\u6765\u7684\u6307\u4ee4\u8fd8\u662f\u8fdb\u5165\u4e2d\u65ad\u5904\u7406\u6d41\u7a0b \u672c\u7ae0\u7684\u64cd\u4f5c\u7cfb\u7edf\u652f\u6301\u628a\u591a\u4e2a\u5e94\u7528\u7684\u4ee3\u7801\u548c\u6570\u636e\u653e\u7f6e\u5230\u5185\u5b58\u4e2d\uff1b\u5e76\u80fd\u591f\u6267\u884c\u6bcf\u4e2a\u5e94\u7528\uff1b\u5728\u5e94\u7528\u7a0b\u5e8f\u53d1\u51fa sys_yeild \u7cfb\u7edf\u8c03\u7528\u65f6\uff0c\u534f\u4f5c\u5f0f\u5730\u5207\u6362\u5e94\u7528\uff1b\u5e76\u80fd\u901a\u8fc7\u65f6\u949f\u4e2d\u65ad\u6765\u5b9e\u73b0\u62a2\u5360\u5f0f\u8c03\u5ea6\u5e76\u5f3a\u884c\u5207\u6362\u5e94\u7528\uff0c\u4ece\u800c\u63d0\u9ad8\u4e86\u5e94\u7528\u6267\u884c\u7684\u7075\u6d3b\u6027\u3001\u516c\u5e73\u6027\u548c\u4ea4\u4e92\u6548\u7387\u3002 \u672c\u8282\u6587\u4ef6\u89e3\u6790 \u5728bootloader \u6587\u4ef6\u5939\u4e0b rustsbi-qemu.bin \u5728 os \u6587\u4ef6\u5939\u4e0b os/.cargo/config [build] target = \"riscv64gc-unknown-none-elf\" [target.riscv64gc-unknown-none-elf] rustflags = [ \"-Clink-arg=-Tsrc/linker.ld\", \"-Cforce-frame-pointers=yes\" ] os/build.rs use std::io::{Result, Write}; use std::fs::{File, read_dir}; fn main() { println!(\"cargo:rerun-if-changed=../user/src/\"); println!(\"cargo:rerun-if-changed={}\", TARGET_PATH); insert_app_data().unwrap(); } static TARGET_PATH: &str = \"../user/target/riscv64gc-unknown-none-elf/release/\"; fn insert_app_data() -> Result<()> { let mut f = File::create(\"src/link_app.S\").unwrap(); let mut apps: Vec<_> = read_dir(\"../user/src/bin\") .unwrap() .into_iter() .map(|dir_entry| { let mut name_with_ext = dir_entry.unwrap().file_name().into_string().unwrap(); name_with_ext.drain(name_with_ext.find('.').unwrap()..name_with_ext.len()); name_with_ext }) .collect(); apps.sort(); writeln!(f, r#\" .align 3 .section .data .global _num_app _num_app: .quad {}\"#, apps.len())?; for i in 0..apps.len() { writeln!(f, r#\" .quad app_{}_start\"#, i)?; } writeln!(f, r#\" .quad app_{}_end\"#, apps.len() - 1)?; for (idx, app) in apps.iter().enumerate() { println!(\"app_{}: {}\", idx, app); writeln!(f, r#\" .section .data .global app_{0}_start .global app_{0}_end app_{0}_start: .incbin \"{2}{1}.bin\" app_{0}_end:\"#, idx, app, TARGET_PATH)?; } Ok(()) } os/Cargo.toml [package] name = \"os\" version = \"0.1.0\" edition = \"2021\" # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html [dependencies] riscv = {git = \"https://github.com/rcore-os/riscv\", features = [\"inline-asm\"]} lazy_static = {version = \"1.4.0\", features = [\"spin_no_std\"]} [features] board_qemu = [] board_k210 = [] os/src/config.rs pub const USER_STACK_SIZE: usize = 4096 * 2; pub const KERNEL_STACK_SIZE: usize = 4096 * 2; pub const MAX_APP_NUM: usize = 4; pub const APP_BASE_ADDRESS: usize = 0x80400000; pub const APP_SIZE_LIMIT: usize = 0x20000; #[cfg(feature = \"board_k210\")] pub const CLOCK_FREQ: usize = 403000000 / 62; #[cfg(feature = \"board_qemu\")] pub const CLOCK_FREQ: usize = 12500000; os/src/console.rs use core::fmt::{self, Write}; use crate::sbi::console_putchar; struct Stdout; impl Write for Stdout { fn write_str(&mut self, s: &str) -> fmt::Result { for c in s.chars() { console_putchar(c as usize); } Ok(()) } } pub fn print(args: fmt::Arguments) { Stdout.write_fmt(args).unwrap(); } #[macro_export] macro_rules! print { ($fmt: literal $(, $($arg: tt)+)?) => { $crate::console::print(format_args!($fmt $(, $($arg)+)?)); } } #[macro_export] macro_rules! println { ($fmt: literal $(, $($arg: tt)+)?) => { $crate::console::print(format_args!(concat!($fmt, \"\\n\") $(, $($arg)+)?)); } } os/src/entry.asm .section .text.entry .globl _start _start: la sp, boot_stack_top call rust_main .section .bss.stack .globl boot_stack boot_stack: .space 4096 * 16 .globl boot_stack_top boot_stack_top: os/src/lang_items.rs use core::panic::PanicInfo; use crate::sbi::shutdown; #[panic_handler] fn panic(info: &PanicInfo) -> ! { if let Some(location) = info.location() { println!(\"[kernel] Panicked at {}:{} {}\", location.file(), location.line(), info.message().unwrap()); } else { println!(\"[kernel] Panicked: {}\", info.message().unwrap()); } shutdown() } os/src/link_app.S .align 3 .section .data .global _num_app _num_app: .quad 3 .quad app_0_start .quad app_1_start .quad app_2_start .quad app_2_end .section .data .global app_0_start .global app_0_end app_0_start: .incbin \"../user/target/riscv64gc-unknown-none-elf/release/00write_a.bin\" app_0_end: .section .data .global app_1_start .global app_1_end app_1_start: .incbin \"../user/target/riscv64gc-unknown-none-elf/release/01write_b.bin\" app_1_end: .section .data .global app_2_start .global app_2_end app_2_start: .incbin \"../user/target/riscv64gc-unknown-none-elf/release/02write_c.bin\" app_2_end: os/src/linker-qemu.ld OUTPUT_ARCH(riscv) ENTRY(_start) BASE_ADDRESS = 0x80200000; SECTIONS { . = BASE_ADDRESS; skernel = .; stext = .; .text : { *(.text.entry) *(.text .text.*) } . = ALIGN(4K); etext = .; srodata = .; .rodata : { *(.rodata .rodata.*) *(.srodata .srodata.*) } . = ALIGN(4K); erodata = .; sdata = .; .data : { *(.data .data.*) *(.sdata .sdata.*) } . = ALIGN(4K); edata = .; .bss : { *(.bss.stack) sbss = .; *(.bss .bss.*) *(.sbss .sbss.*) } . = ALIGN(4K); ebss = .; ekernel = .; /DISCARD/ : { *(.eh_frame) } } os/src/sbi.rs #![allow(unused)] const SBI_SET_TIMER:usize = 0; const SBI_CONSOLE_PUTCHAR:usize = 1; const SBI_CONSOLE_GETCHAR:usize = 2; const SBI_CLEAR_IPI:usize = 3; const SBI_SEND_IPI:usize = 4; const SBI_REMOTE_FENCE_I:usize = 5; const SBI_REMOTE_SFENCE_VMA:usize = 6; const SBI_REMOTE_SFENCE_VMA_ASID:usize = 7; const SBI_SHUTDOWN:usize = 8; use core::arch::asm; #[inline(always)] fn sbi_call(which:usize, arg0:usize, arg1:usize, arg2: usize) -> usize{ let mut ret; unsafe{ asm!( \"ecall\", inlateout(\"x10\") arg0 => ret, in(\"x11\") arg1, in(\"x12\") arg2, in(\"x17\") which, ); } ret } pub fn console_putchar(c:usize){ sbi_call(SBI_CONSOLE_PUTCHAR, c, 0, 0); } pub fn console_getchar() -> usize { sbi_call(SBI_CONSOLE_GETCHAR, 0, 0, 0) } pub fn shutdown() -> ! { sbi_call(SBI_SHUTDOWN, 0, 0, 0); panic!(\"It should shutdown!\"); } pub fn set_timer(timer: usize) { sbi_call(SBI_SET_TIMER, timer, 0, 0); } // sbi \u5b50\u6a21\u5757\u6709\u4e00\u4e2a set_timer \u8c03\u7528\uff0c\u662f\u4e00\u4e2a\u7531 SEE \u63d0\u4f9b\u7684\u6807\u51c6 SBI \u63a5\u53e3\u51fd\u6570\uff0c\u5b83\u53ef\u4ee5\u7528\u6765\u8bbe\u7f6e mtimecmp \u7684\u503c\u3002 os/src/timer.rs use riscv::register::time; use crate::sbi::set_timer; pub fn get_time() -> usize{ time::read() } // timer \u5b50\u6a21\u5757\u7684 get_time \u51fd\u6570\u53ef\u4ee5\u53d6\u5f97\u5f53\u524d mtime \u8ba1\u6570\u5668\u7684\u503c\uff1b use crate::config::CLOCK_FREQ; const TICKS_PER_SEC: usize = 100; pub fn set_next_trigger() { set_timer(get_time() + CLOCK_FREQ / TICKS_PER_SEC); } // timer \u5b50\u6a21\u5757\u7684 set_next_trigger \u51fd\u6570\u5bf9 set_timer \u8fdb\u884c\u4e86\u5c01\u88c5\uff0c // \u5b83\u9996\u5148\u8bfb\u53d6\u5f53\u524d mtime \u7684\u503c\uff0c\u7136\u540e\u8ba1\u7b97\u51fa 10ms \u4e4b\u5185\u8ba1\u6570\u5668\u7684\u589e\u91cf\uff0c // \u518d\u5c06 mtimecmp \u8bbe\u7f6e\u4e3a\u4e8c\u8005\u7684\u548c\u3002\u8fd9\u6837\uff0c10ms \u4e4b\u540e\u4e00\u4e2a S \u7279\u6743\u7ea7\u65f6\u949f\u4e2d\u65ad\u5c31\u4f1a\u88ab\u89e6\u53d1\u3002 // \u81f3\u4e8e\u589e\u91cf\u7684\u8ba1\u7b97\u65b9\u5f0f\uff0c\u5e38\u6570 CLOCK_FREQ \u662f\u4e00\u4e2a\u9884\u5148\u83b7\u53d6\u5230\u7684\u5404\u5e73\u53f0\u4e0d\u540c\u7684\u65f6\u949f\u9891\u7387\uff0c // \u5355\u4f4d\u4e3a\u8d6b\u5179\uff0c\u4e5f\u5c31\u662f\u4e00\u79d2\u949f\u4e4b\u5185\u8ba1\u6570\u5668\u7684\u589e\u91cf\u3002\u5b83\u53ef\u4ee5\u5728 config \u5b50\u6a21\u5757\u4e2d\u627e\u5230\u3002 // CLOCK_FREQ \u9664\u4ee5\u5e38\u6570 TICKS_PER_SEC \u5373\u662f\u4e0b\u4e00\u6b21\u65f6\u949f\u4e2d\u65ad\u7684\u8ba1\u6570\u5668\u589e\u91cf\u503c\u3002 const MICRO_PRE_SEC: usize = 1_000_000; pub fn get_time_ms() -> usize { time::read() / (CLOCK_FREQ / MICRO_PRE_SEC) } // timer \u5b50\u6a21\u5757\u7684 get_time_us \u4ee5\u5fae\u79d2\u4e3a\u5355\u4f4d\u8fd4\u56de\u5f53\u524d\u8ba1\u6570\u5668\u7684\u503c\uff0c\u8fd9\u8ba9\u6211\u4eec\u7ec8\u4e8e\u80fd\u5bf9\u65f6\u95f4\u6709\u4e00\u4e2a\u5177\u4f53\u6982\u5ff5\u4e86 os/src/sync/mod.rs mod up; pub use up::UPSafeCell; os/src/sync/up.rs use core::cell::{RefCell, RefMut}; /// Wrap a static data structure inside it so that we are /// able to access it without any `unsafe`. /// /// We should only use it in uniprocessor. /// /// In order to get mutable reference of inner data, call /// `exclusive_access`. pub struct UPSafeCell<T> { /// inner data inner: RefCell<T>, } unsafe impl<T> Sync for UPSafeCell<T> {} impl<T> UPSafeCell<T> { /// User is responsible to guarantee that inner struct is only used in /// uniprocessor. pub unsafe fn new(value: T) -> Self { Self { inner: RefCell::new(value) } } /// Panic if the data has been borrowed. pub fn exclusive_access(&self) -> RefMut<'_, T> { self.inner.borrow_mut() } } os/src/syscall/fs.rs const FD_STDOUT: usize = 1; pub fn sys_write(fd: usize, buf: *const u8, len: usize) -> isize { match fd { FD_STDOUT => { let slice = unsafe { core::slice::from_raw_parts(buf, len) }; let str = core::str::from_utf8(slice).unwrap(); print!(\"{}\", str); len as isize }, _ => { panic!(\"Unsupported fd in sys_write!\"); } } } os/src/syscall/mod.rs const SYSCALL_WRITE: usize = 64; const SYSCALL_EXIT: usize = 93; const SYSCALL_YIELD: usize = 124; const SYSCALL_GET_TIME: usize = 169; mod fs; mod process; use fs::*; use process::*; pub fn syscall(syscall_id: usize, args: [usize; 3]) -> isize{ match syscall_id { SYSCALL_WRITE => sys_write(args[0], args[1] as *const u8, args[2]), SYSCALL_EXIT => sys_exit(args[0] as i32), SYSCALL_YIELD => sys_yield(), SYSCALL_GET_TIME => sys_get_time(), _ => panic!(\"Unsupported syscall_id: {}\", syscall_id), } } os/src/syscall/process.rs use crate::task::{ suspend_current_and_run_next, exit_current_and_run_next, }; pub fn sys_exit(exit_code: i32) -> ! { println!(\"[kernel] Application exited with code {}\", exit_code); // \u5728\u8c03\u7528\u5b83\u4e4b\u524d\u6211\u4eec\u6253\u5370\u5e94\u7528\u7684\u9000\u51fa\u4fe1\u606f\u5e76\u8f93\u51fa\u5b83\u7684\u9000\u51fa\u7801 exit_current_and_run_next(); // \u57fa\u4e8e task \u5b50\u6a21\u5757\u63d0\u4f9b\u7684 exit_current_and_run_next \u63a5\u53e3 panic!(\"Unreachable in sys_exit!\"); } pub fn sys_yield() -> isize { suspend_current_and_run_next(); // task \u5b50\u6a21\u5757\u63d0\u4f9b\u7684 suspend_current_and_run_next \u63a5\u53e3 0 } // sys_yield \u8868\u793a\u5e94\u7528\u81ea\u5df1\u6682\u65f6\u653e\u5f03\u5bf9CPU\u7684\u5f53\u524d\u4f7f\u7528\u6743\uff0c\u8fdb\u5165 Ready \u72b6\u6001 use crate::timer::get_time_ms; pub fn sys_get_time() -> isize { get_time_ms() as isize } os/src/task/context.rs #[derive(Copy, Clone)] #[repr(C)] pub struct TaskContext { ra: usize, // \u8bb0\u5f55__switch \u51fd\u6570\u8fd4\u56de\u4e4b\u540e\u5e94\u8be5\u8df3\u8f6c\u5230\u54ea\u91cc\u7ee7\u7eed\u6267\u884c // \u4ece\u800c\u5728\u4efb\u52a1\u5207\u6362\u5b8c\u6210\u5e76 ret \u4e4b\u540e\u80fd\u5230\u6b63\u786e\u7684\u4f4d\u7f6e sp: usize, s: [usize; 12], // \u5bf9\u4e8e\u4e00\u822c\u7684\u51fd\u6570\u800c\u8a00\uff0cRust/C \u7f16\u8bd1\u5668\u4f1a\u5728\u51fd\u6570\u7684\u8d77\u59cb\u4f4d\u7f6e\u81ea\u52a8\u751f\u6210\u4ee3\u7801\u6765\u4fdd\u5b58 s0~s11 \u8fd9\u4e9b\u88ab\u8c03\u7528\u8005\u4fdd\u5b58\u7684\u5bc4\u5b58\u5668\u3002 // \u4f46 __switch \u662f\u4e00\u4e2a\u7528\u6c47\u7f16\u4ee3\u7801\u5199\u7684\u7279\u6b8a\u51fd\u6570\uff0c\u5b83\u4e0d\u4f1a\u88ab Rust/C \u7f16\u8bd1\u5668\u5904\u7406\uff0c // \u6240\u4ee5\u6211\u4eec\u9700\u8981\u5728 __switch \u4e2d\u624b\u52a8\u7f16\u5199\u4fdd\u5b58 s0~s11 \u7684\u6c47\u7f16\u4ee3\u7801 // \u4e0d\u7528\u4fdd\u5b58\u5176\u5b83\u5bc4\u5b58\u5668\u662f\u56e0\u4e3a\uff1a\u5176\u5b83\u5bc4\u5b58\u5668\u4e2d\uff0c // \u5c5e\u4e8e\u8c03\u7528\u8005\u4fdd\u5b58\u7684\u5bc4\u5b58\u5668\u662f\u7531\u7f16\u8bd1\u5668\u5728\u9ad8\u7ea7\u8bed\u8a00\u7f16\u5199\u7684\u8c03\u7528\u51fd\u6570\u4e2d\u81ea\u52a8\u751f\u6210\u7684\u4ee3\u7801\u6765\u5b8c\u6210\u4fdd\u5b58\u7684\uff1b // \u8fd8\u6709\u4e00\u4e9b\u5bc4\u5b58\u5668\u5c5e\u4e8e\u4e34\u65f6\u5bc4\u5b58\u5668\uff0c\u4e0d\u9700\u8981\u4fdd\u5b58\u548c\u6062\u590d\u3002 } impl TaskContext { pub fn zero_init() -> Self { Self { ra: 0, sp: 0, s: [0; 12], } } pub fn goto_restore(kstack_ptr: usize) -> Self { // \u6784\u9020\u6bcf\u4e2a\u4efb\u52a1\u4fdd\u5b58\u5728\u4efb\u52a1\u63a7\u5236\u5757\u4e2d\u7684\u4efb\u52a1\u4e0a\u4e0b\u6587 extern \"C\" { fn __restore(); } Self { ra: __restore as usize, // \u5b83\u8bbe\u7f6e\u4efb\u52a1\u4e0a\u4e0b\u6587\u4e2d\u7684\u5185\u6838\u6808\u6307\u9488\u5c06\u4efb\u52a1\u4e0a\u4e0b\u6587\u7684 ra \u5bc4\u5b58\u5668\u8bbe\u7f6e\u4e3a __restore \u7684\u5165\u53e3\u5730\u5740 // \u8fd9\u6837\uff0c\u5728 __switch \u4ece\u5b83\u4e0a\u9762\u6062\u590d\u5e76\u8fd4\u56de\u4e4b\u540e\u5c31\u4f1a\u76f4\u63a5\u8df3\u8f6c\u5230 __restore \uff0c // \u6b64\u65f6\u6808\u9876\u662f\u4e00\u4e2a\u6211\u4eec\u6784\u9020\u51fa\u6765\u7b2c\u4e00\u6b21\u8fdb\u5165\u7528\u6237\u6001\u6267\u884c\u7684 Trap \u4e0a\u4e0b\u6587 sp: kstack_ptr, s: [0; 12], } } } os/src/task/switch.rs use super::TaskContext; use core::arch::global_asm; global_asm!(include_str!(\"switch.S\")); extern \"C\" { pub fn __switch( current_task_cx_ptr: *mut TaskContext, next_task_cx_ptr: *const TaskContext ); // \u6211\u4eec\u4f1a\u5c06\u8fd9\u6bb5\u6c47\u7f16\u4ee3\u7801\u4e2d\u7684\u5168\u5c40\u7b26\u53f7 __switch \u89e3\u91ca\u4e3a\u4e00\u4e2a Rust \u51fd\u6570 // \u6211\u4eec\u4f1a\u8c03\u7528\u8be5\u51fd\u6570\u6765\u5b8c\u6210\u5207\u6362\u529f\u80fd\u800c\u4e0d\u662f\u76f4\u63a5\u8df3\u8f6c\u5230\u7b26\u53f7 __switch \u7684\u5730\u5740\u3002 // \u56e0\u6b64\u5728\u8c03\u7528\u524d\u540e Rust \u7f16\u8bd1\u5668\u4f1a\u81ea\u52a8\u5e2e\u52a9\u6211\u4eec\u63d2\u5165\u4fdd\u5b58/\u6062\u590d\u8c03\u7528\u8005\u4fdd\u5b58\u5bc4\u5b58\u5668\u7684\u6c47\u7f16\u4ee3\u7801 } os/src/task/switch.S .altmacro .macro SAVE_SN n sd s\\n, (\\n+2)*8(a0) .endm .macro LOAD_SN n ld s\\n, (\\n+2)*8(a1) .endm .section .text .globl __switch __switch: # __switch( # current_task_cx_ptr: *mut TaskContext, # next_task_cx_ptr: *const TaskContext # ) # \u51fd\u6570\u539f\u578b\u4e2d\u7684\u4e24\u4e2a\u53c2\u6570\u5206\u522b\u662f\u5f53\u524d A \u4efb\u52a1\u4e0a\u4e0b\u6587\u6307\u9488 next_task_cx_ptr # \u548c\u5373\u5c06\u88ab\u5207\u6362\u5230\u7684 B \u4efb\u52a1\u4e0a\u4e0b\u6587\u6307\u9488 next_task_cx_ptr \uff0c # \u4ece RISC-V \u8c03\u7528\u89c4\u8303 \u53ef\u4ee5\u77e5\u9053\u5b83\u4eec\u5206\u522b\u901a\u8fc7\u5bc4\u5b58\u5668 a0/a1 \u4f20\u5165 # save kernel stack of current task # \u4fdd\u5b58\u5f53\u524d\u4efb\u52a1\u7684\u6808\u6bb5 sd sp, 8(a0) # save ra & s0~s11 of current execution # \u4fdd\u5b58\u5f53\u524d \u4efb\u52a1\u4e0a\u4e0b\u6587 sd ra, 0(a0) .set n, 0 .rept 12 SAVE_SN %n .set n, n + 1 .endr # restore ra & s0~s11 of next execution # \u6062\u590d\u4e0b\u4e00\u4e2a\u4efb\u52a1\u7684\u4e0a\u4e0b\u6587 ld ra, 0(a1) .set n, 0 .rept 12 LOAD_SN %n .set n, n + 1 .endr # restore kernel stack of next task # \u6062\u590d\u4e0a\u4e00\u4e2a\u4efb\u52a1\u7684 \u6808\u6bb5 ld sp, 8(a1) ret os/src/task.rs use super::TaskContext; #[derive(Copy, Clone)] // \u901a\u8fc7 #[derive(...)] \u53ef\u4ee5\u8ba9\u7f16\u8bd1\u5668\u4e3a\u4f60\u7684\u7c7b\u578b\u63d0\u4f9b\u4e00\u4e9b Trait \u7684\u9ed8\u8ba4\u5b9e\u73b0\u3002 // \u5b9e\u73b0\u4e86 Clone Trait \u4e4b\u540e\u5c31\u53ef\u4ee5\u8c03\u7528 clone \u51fd\u6570\u5b8c\u6210\u62f7\u8d1d\uff1b // \u5b9e\u73b0\u4e86 PartialEq Trait \u4e4b\u540e\u5c31\u53ef\u4ee5\u4f7f\u7528 == \u8fd0\u7b97\u7b26\u6bd4\u8f83\u8be5\u7c7b\u578b\u7684\u4e24\u4e2a\u5b9e\u4f8b\uff0c // \u4ece\u903b\u8f91\u4e0a\u8bf4\u53ea\u6709 \u4e24\u4e2a\u76f8\u7b49\u7684\u5e94\u7528\u6267\u884c\u72b6\u6001\u624d\u4f1a\u88ab\u5224\u4e3a\u76f8\u7b49\uff0c\u800c\u4e8b\u5b9e\u4e0a\u4e5f\u786e\u5b9e\u5982\u6b64\u3002 // Copy \u662f\u4e00\u4e2a\u6807\u8bb0 Trait\uff0c\u51b3\u5b9a\u8be5\u7c7b\u578b\u5728\u6309\u503c\u4f20\u53c2/\u8d4b\u503c\u7684\u65f6\u5019\u91c7\u7528\u79fb\u52a8\u8bed\u4e49\u8fd8\u662f\u590d\u5236\u8bed\u4e49\u3002 pub struct TaskControlBlock { // \u4efb\u52a1\u63a7\u5236\u5757 pub task_status: TaskStatus, // \u4efb\u52a1 \u8fd0\u884c\u72b6\u6001 pub task_cx: TaskContext, // \u4efb\u52a1\u4e0a\u4e0b\u6587 } #[derive(Copy, Clone, PartialEq)] pub enum TaskStatus { UnInit, // \u672a\u521d\u59cb\u5316 Ready, // \u51c6\u5907\u8fd0\u884c Running, // \u6b63\u5728\u8fd0\u884c Exited, // \u5df2\u9000\u51fa } os/src/task/mod.rs mod context; mod switch; mod task; use crate::config::MAX_APP_NUM; use crate::loader::{get_num_app, init_app_cx}; use lazy_static::*; use switch::__switch; use task::{TaskControlBlock, TaskStatus}; use crate::sync::UPSafeCell; pub use context::TaskContext; // \u5168\u5c40\u7684\u4efb\u52a1\u7ba1\u7406\u5668 pub struct TaskManager { num_app: usize, // \u4efb\u52a1\u7ba1\u7406\u5668\u7ba1\u7406\u7684\u5e94\u7528\u7684\u6570\u76ee // \u5b83\u5728 TaskManager \u521d\u59cb\u5316\u4e4b\u540e\u5c31\u4e0d\u4f1a\u53d1\u751f\u53d8\u5316 inner: UPSafeCell<TaskManagerInner>, // \u800c\u5305\u88f9\u5728 TaskManagerInner \u5185\u7684\u4efb\u52a1\u63a7\u5236\u5757\u6570\u7ec4 tasks // \u4ee5\u53ca\u8868\u793a CPU \u6b63\u5728\u6267\u884c\u7684\u5e94\u7528\u7f16\u53f7 current_task \u4f1a\u5728\u6267\u884c\u5e94\u7528\u7684\u8fc7\u7a0b\u4e2d\u53d1\u751f\u53d8\u5316\uff1a // \u6bcf\u4e2a\u5e94\u7528\u7684\u8fd0\u884c\u72b6\u6001\u90fd\u4f1a\u53d1\u751f\u53d8\u5316\uff0c\u800c CPU \u6267\u884c\u7684\u5e94\u7528\u4e5f\u5728\u4e0d\u65ad\u5207\u6362\u3002 // \u56e0\u6b64\u6211\u4eec\u9700\u8981\u5c06 TaskManagerInner \u5305\u88f9\u5728 UPSafeCell \u5185 // \u4ee5\u83b7\u53d6\u5176\u5185\u90e8\u53ef\u53d8\u6027\u4ee5\u53ca\u5355\u6838\u4e0a\u5b89\u5168\u7684\u8fd0\u884c\u65f6\u501f\u7528\u68c0\u67e5\u80fd\u529b } struct TaskManagerInner { tasks: [TaskControlBlock; MAX_APP_NUM], current_task: usize, // \u53ea\u80fd\u901a\u8fc7\u5b83\u77e5\u9053 CPU\u6b63\u5728\u6267\u884c\u54ea\u4e2a\u5e94\u7528\uff0c\u800c\u4e0d\u80fd\u63a8\u6d4b\u51fa\u5176\u4ed6\u5e94\u7528\u7684\u4efb\u4f55\u4fe1\u606f } lazy_static! { pub static ref TASK_MANAGER: TaskManager = { let num_app = get_num_app(); // \u8c03\u7528 loader \u5b50\u6a21\u5757\u63d0\u4f9b\u7684 get_num_app \u63a5\u53e3\u83b7\u53d6\u94fe\u63a5\u5230\u5185\u6838\u7684\u5e94\u7528\u603b\u6570 let mut tasks = [ TaskControlBlock { task_cx: TaskContext::zero_init(), task_status: TaskStatus::UnInit }; MAX_APP_NUM ]; // \u521b\u5efa\u4e00\u4e2a\u521d\u59cb\u5316\u7684 tasks \u6570\u7ec4\uff0c\u5176\u4e2d\u7684\u6bcf\u4e2a\u4efb\u52a1\u63a7\u5236\u5757\u7684\u8fd0\u884c\u72b6\u6001\u90fd\u662f UnInit \uff1a\u8868\u793a\u5c1a\u672a\u521d\u59cb\u5316 for i in 0..num_app { tasks[i].task_cx = TaskContext::goto_restore(init_app_cx(i)); // \u5bf9\u4e8e\u6bcf\u4e2a\u4efb\u52a1\uff0c\u6211\u4eec\u5148\u8c03\u7528 init_app_cx \u6784\u9020\u8be5\u4efb\u52a1\u7684 Trap \u4e0a\u4e0b\u6587 // \uff08\u5305\u62ec\u5e94\u7528\u5165\u53e3\u5730\u5740\u548c\u7528\u6237\u6808\u6307\u9488\uff09\u5e76\u5c06\u5176\u538b\u5165\u5230\u5185\u6838\u6808\u9876 // \u63a5\u7740\u8c03\u7528 TaskContext::goto_restore \u6765\u6784\u9020\u6bcf\u4e2a\u4efb\u52a1\u4fdd\u5b58\u5728\u4efb\u52a1\u63a7\u5236\u5757\u4e2d\u7684\u4efb\u52a1\u4e0a\u4e0b\u6587\u3002 // \u5b83\u8bbe\u7f6e\u4efb\u52a1\u4e0a\u4e0b\u6587\u4e2d\u7684\u5185\u6838\u6808\u6307\u9488\u5c06\u4efb\u52a1\u4e0a\u4e0b\u6587\u7684 ra \u5bc4\u5b58\u5668\u8bbe\u7f6e\u4e3a __restore \u7684\u5165\u53e3\u5730\u5740 // \u8fd9\u6837\uff0c\u5728 __switch \u4ece\u5b83\u4e0a\u9762\u6062\u590d\u5e76\u8fd4\u56de\u4e4b\u540e\u5c31\u4f1a\u76f4\u63a5\u8df3\u8f6c\u5230 __restore \uff0c // \u6b64\u65f6\u6808\u9876\u662f\u4e00\u4e2a\u6211\u4eec\u6784\u9020\u51fa\u6765\u7b2c\u4e00\u6b21\u8fdb\u5165\u7528\u6237\u6001\u6267\u884c\u7684 Trap \u4e0a\u4e0b\u6587 tasks[i].task_status = TaskStatus::Ready; } // \u4f9d\u6b21\u5bf9\u6bcf\u4e2a\u4efb\u52a1\u63a7\u5236\u5757\u8fdb\u884c\u521d\u59cb\u5316\uff0c\u5c06\u5176\u8fd0\u884c\u72b6\u6001\u8bbe\u7f6e\u4e3a Ready \uff1a\u8868\u793a\u53ef\u4ee5\u8fd0\u884c\uff0c // \u5e76\u521d\u59cb\u5316\u5b83\u7684 \u4efb\u52a1\u4e0a\u4e0b\u6587 TaskManager { num_app, inner: unsafe { UPSafeCell::new(TaskManagerInner { tasks, current_task: 0, })}, } // \u521b\u5efa TaskManager \u5b9e\u4f8b\u5e76\u8fd4\u56de }; } //\u6ce8\u610f\u6211\u4eec\u65e0\u9700\u548c\u7b2c\u4e8c\u7ae0\u4e00\u6837\u5c06 TaskManager \u6807\u8bb0\u4e3a Sync \uff0c // \u56e0\u4e3a\u7f16\u8bd1\u5668\u53ef\u4ee5\u6839\u636e TaskManager \u5b57\u6bb5\u7684\u60c5\u51b5\u81ea\u52a8\u63a8\u5bfc\u51fa TaskManager \u662f Sync \u7684 impl TaskManager { fn run_first_task(&self) -> ! { let mut inner = self.inner.exclusive_access(); let task0 = &mut inner.tasks[0]; // \u6211\u4eec\u53d6\u51fa\u5373\u5c06\u6700\u5148\u6267\u884c\u7684\u7f16\u53f7\u4e3a 0 \u7684\u5e94\u7528\u7684\u4efb\u52a1\u4e0a\u4e0b\u6587\u6307\u9488 next_task_cx_ptr \u5e76\u5e0c\u671b\u80fd\u591f\u5207\u6362\u8fc7\u53bb\u3002\u6ce8\u610f __switch \u6709\u4e24\u4e2a\u53c2\u6570\u5206\u522b\u8868\u793a\u5f53\u524d\u5e94\u7528\u548c\u5373\u5c06\u5207\u6362\u5230\u7684\u5e94\u7528\u7684\u4efb\u52a1\u4e0a\u4e0b\u6587\u6307\u9488\uff0c\u5176\u7b2c\u4e00\u4e2a\u53c2\u6570\u5b58\u5728\u7684\u610f\u4e49\u662f\u8bb0\u5f55\u5f53\u524d\u5e94\u7528\u7684\u4efb\u52a1\u4e0a\u4e0b\u6587\u88ab\u4fdd\u5b58\u5728\u54ea\u91cc\uff0c\u4e5f\u5c31\u662f\u5f53\u524d\u5e94\u7528\u5185\u6838\u6808\u7684\u6808\u9876\uff0c\u8fd9\u6837\u4e4b\u540e\u624d\u80fd\u7ee7\u7eed\u6267\u884c\u8be5\u5e94\u7528\u3002\u4f46\u5728 run_first_task \u7684\u65f6\u5019\uff0c\u6211\u4eec\u5e76\u6ca1\u6709\u6267\u884c\u4efb\u4f55\u5e94\u7528\uff0c __switch \u524d\u534a\u90e8\u5206\u7684\u4fdd\u5b58\u4ec5\u4ec5\u662f\u5728\u542f\u52a8\u6808\u4e0a\u4fdd\u5b58\u4e86\u4e00\u4e9b\u4e4b\u540e\u4e0d\u4f1a\u7528\u5230\u7684\u6570\u636e\uff0c\u81ea\u7136\u4e5f\u65e0\u9700\u8bb0\u5f55\u542f\u52a8\u6808\u6808\u9876\u7684\u4f4d\u7f6e\u3002 // \u56e0\u6b64\uff0c\u6211\u4eec\u663e\u5f0f\u5728\u542f\u52a8\u6808\u4e0a\u5206\u914d\u4e86\u4e00\u4e2a\u540d\u4e3a _unused \u7684\u4efb\u52a1\u4e0a\u4e0b\u6587\uff0c\u5e76\u5c06\u5b83\u7684\u5730\u5740\u4f5c\u4e3a\u7b2c\u4e00\u4e2a\u53c2\u6570\u4f20\u7ed9 __switch \uff0c\u8fd9\u6837\u4fdd\u5b58\u4e00\u4e9b\u5bc4\u5b58\u5668\u4e4b\u540e\u7684\u542f\u52a8\u6808\u6808\u9876\u7684\u4f4d\u7f6e\u5c06\u4f1a\u4fdd\u5b58\u5728\u6b64\u53d8\u91cf\u4e2d\u3002\u7136\u800c\u65e0\u8bba\u662f\u6b64\u53d8\u91cf\u8fd8\u662f\u542f\u52a8\u6808\u6211\u4eec\u4e4b\u540e\u5747\u4e0d\u4f1a\u6d89\u53ca\u5230\uff0c\u4e00\u65e6\u5e94\u7528\u5f00\u59cb\u8fd0\u884c\uff0c\u6211\u4eec\u5c31\u5f00\u59cb\u5728\u5e94\u7528\u7684\u7528\u6237\u6808\u548c\u5185\u6838\u6808\u4e4b\u95f4\u5f00\u59cb\u5207\u6362\u4e86\u3002\u8fd9\u91cc\u58f0\u660e\u6b64\u53d8\u91cf\u7684\u610f\u4e49\u4ec5\u4ec5\u662f\u4e3a\u4e86\u907f\u514d\u8986\u76d6\u5230\u5176\u4ed6\u6570\u636e task0.task_status = TaskStatus::Running; let next_task_cx_ptr = &task0.task_cx as *const TaskContext; // \u5c06\u7f16\u53f7\u4e3a0 \u7684\u4efb\u52a1 \u6807\u8bb0\u4e3a\u4e0b\u4e00\u4e2a\u8981\u5207\u6362\u5230\u7684\u4efb\u52a1 drop(inner); let mut _unused = TaskContext::zero_init(); // \u521d\u59cb\u5316\u521b\u5efa\u4e00\u4e2a\u4e0d\u4f1a\u7528\u7684\u7684 \u4efb\u52a1\u4e0a\u4e0b\u6587 \u4f5c\u4e3a\u5f53\u524d\u4efb\u52a1\u4e0a\u4e0b\u6587 // \u7531\u4e8e\u4e4b\u540e\u5207\u6362\u65f6 \u627e\u4e0d\u5230\u5b83\u7684 ID\uff0c\u6240\u6709\u4e0d\u7528\u5f53\u5fc3\u5b83\u5bf9\u540e\u7eed\u7a0b\u5e8f\u8fd0\u884c\u7684\u5f71\u54cd // before this, we should drop local variables that must be dropped manually unsafe { __switch( &mut _unused as *mut TaskContext, next_task_cx_ptr, ); } panic!(\"unreachable in run_first_task!\"); } fn mark_current_suspended(&self) { let mut inner = self.inner.exclusive_access(); let current = inner.current_task; inner.tasks[current].task_status = TaskStatus::Ready; // \u5176\u4e2d\uff0c\u9996\u5148\u83b7\u5f97\u91cc\u5c42 TaskManagerInner \u7684\u53ef\u53d8\u5f15\u7528\uff0c // \u901a\u8fc7 sync/up.rs \u91cc UPSafeCell\u7ed3\u6784\u4f53\u7684\u65b9\u6cd5 exclusive_access \u83b7\u53d6 // \u7136\u540e\u6839\u636e\u5176\u4e2d\u8bb0\u5f55\u7684\u5f53\u524d\u6b63\u5728\u6267\u884c\u7684\u5e94\u7528 ID \u5bf9\u5e94\u5728\u4efb\u52a1\u63a7\u5236\u5757\u6570\u7ec4 tasks \u4e2d\u4fee\u6539\u72b6\u6001 } fn mark_current_exited(&self) { let mut inner = self.inner.exclusive_access(); let current = inner.current_task; inner.tasks[current].task_status = TaskStatus::Exited; // \u5176\u4e2d\uff0c\u9996\u5148\u83b7\u5f97\u91cc\u5c42 TaskManagerInner \u7684\u53ef\u53d8\u5f15\u7528\uff0c // \u901a\u8fc7 sync/up.rs \u91cc UPSafeCell\u7ed3\u6784\u4f53\u7684\u65b9\u6cd5 exclusive_access \u83b7\u53d6 // \u7136\u540e\u6839\u636e\u5176\u4e2d\u8bb0\u5f55\u7684\u5f53\u524d\u6b63\u5728\u6267\u884c\u7684\u5e94\u7528 ID \u5bf9\u5e94\u5728\u4efb\u52a1\u63a7\u5236\u5757\u6570\u7ec4 tasks \u4e2d\u4fee\u6539\u72b6\u6001 } fn find_next_task(&self) -> Option<usize> { let inner = self.inner.exclusive_access(); let current = inner.current_task; (current + 1..current + self.num_app + 1) .map(|id| id % self.num_app) .find(|id| { inner.tasks[*id].task_status == TaskStatus::Ready }) // TaskManagerInner \u7684 tasks \u662f\u4e00\u4e2a\u56fa\u5b9a\u7684\u4efb\u52a1\u63a7\u5236\u5757\u7ec4\u6210\u7684\u8868\uff0c\u957f\u5ea6\u4e3a num_app \uff0c // \u53ef\u4ee5\u7528\u4e0b\u6807 0~num_app-1 \u6765\u8bbf\u95ee\u5f97\u5230\u6bcf\u4e2a\u5e94\u7528\u7684\u63a7\u5236\u72b6\u6001\u3002 // \u6211\u4eec\u7684\u4efb\u52a1\u5c31\u662f\u627e\u5230 current_task \u540e\u9762\u7b2c\u4e00\u4e2a\u72b6\u6001\u4e3a Ready \u7684\u5e94\u7528\u3002 // \u56e0\u6b64\u4ece current_task + 1 \u5f00\u59cb\u5faa\u73af\u4e00\u5708\uff0c\u9700\u8981\u9996\u5148\u5bf9 num_app \u53d6\u6a21\u5f97\u5230\u5b9e\u9645\u7684\u4e0b\u6807\uff0c // \u7136\u540e\u68c0\u67e5\u5b83\u7684\u8fd0\u884c\u72b6\u6001 } fn run_next_task(&self) { if let Some(next) = self.find_next_task() { // \u5b83\u4f1a\u8c03\u7528 find_next_task \u65b9\u6cd5\u5c1d\u8bd5\u5bfb\u627e\u4e00\u4e2a\u8fd0\u884c\u72b6\u6001\u4e3a Ready \u7684\u5e94\u7528\u5e76\u8fd4\u56de\u5176 ID let mut inner = self.inner.exclusive_access(); // \u83b7\u53d6\u5168\u5c40\u4efb\u52a1\u7ba1\u7406\u5668\u7684 struct TaskManagerInner { // tasks: [TaskControlBlock; MAX_APP_NUM], // current_task: usize, // } let current = inner.current_task; // \u83b7\u53d6\u5f53\u524d\u4efb\u52a1\u7684 ID inner.tasks[next].task_status = TaskStatus::Running; // \u5c06\u4e0b\u4e00\u4e2a\u4efb\u52a1\u7684\u72b6\u6001\u6807\u6ce8\u4e3a Running inner.current_task = next; // \u5c06\u5f53\u524d\u4efb\u52a1 \u6807\u6ce8\u4e3a\u4e0b\u4e00\u4e2a\u4efb\u52a1\u7684 ID let current_task_cx_ptr = &mut inner.tasks[current].task_cx as *mut TaskContext; // \u83b7\u53d6\u5b58\u653e\u5f53\u524d\u4efb\u52a1\u4e0a\u4e0b\u6587\u7684 \u5730\u5740 let next_task_cx_ptr = &inner.tasks[next].task_cx as *const TaskContext; // \u83b7\u53d6\u5b58\u653e\u4e0b\u4e00\u4e2a\u4efb\u52a1\u4e0a\u4e0b\u6587\u7684 \u5730\u5740 drop(inner); // \u5728\u5b9e\u9645\u5207\u6362\u4e4b\u524d\u6211\u4eec\u9700\u8981\u624b\u52a8 drop \u6389\u6211\u4eec\u83b7\u53d6\u5230\u7684 TaskManagerInner // \u7684\u6765\u81ea UPSafeCell \u7684\u501f\u7528\u6807\u8bb0\u3002 // \u56e0\u4e3a\u4e00\u822c\u60c5\u51b5\u4e0b\u5b83\u662f\u5728\u51fd\u6570\u9000\u51fa\u4e4b\u540e\u624d\u4f1a\u88ab\u81ea\u52a8\u91ca\u653e\uff0c\u4ece\u800c TASK_MANAGER // \u7684 inner \u5b57\u6bb5\u5f97\u4ee5\u56de\u5f52\u5230\u672a\u88ab\u501f\u7528\u7684\u72b6\u6001\uff0c // \u4e4b\u540e\u53ef\u4ee5\u518d\u501f\u7528\u3002\u5982\u679c\u4e0d\u624b\u52a8 drop \u7684\u8bdd\uff0c\u7f16\u8bd1\u5668\u4f1a\u5728 __switch \u8fd4\u56de\u65f6\uff0c // \u4e5f\u5c31\u662f\u5f53\u524d\u5e94\u7528\u88ab\u5207\u6362\u56de\u6765\u7684\u65f6\u5019\u624d drop\uff0c\u8fd9\u671f\u95f4\u6211\u4eec\u90fd\u4e0d\u80fd\u4fee\u6539 TaskManagerInner \uff0c // \u751a\u81f3\u4e0d\u80fd\u8bfb\uff08\u56e0\u4e3a\u4e4b\u524d\u662f\u53ef\u53d8\u501f\u7528\uff09\uff0c\u4f1a\u5bfc\u81f4\u5185\u6838 panic \u62a5\u9519\u9000\u51fa\u3002 // \u6b63\u56e0\u5982\u6b64\uff0c\u6211\u4eec\u9700\u8981\u5728 __switch \u524d\u63d0\u65e9\u624b\u52a8 drop \u6389 inner // before this, we should drop local variables that must be dropped manually unsafe { __switch( current_task_cx_ptr, next_task_cx_ptr, ); } // \u5982\u679c\u80fd\u591f\u627e\u5230\u4e0b\u4e00\u4e2a\u53ef\u8fd0\u884c\u7684\u5e94\u7528\u7684\u8bdd\uff0c // \u6211\u4eec\u5c31\u53ef\u4ee5\u5206\u522b\u62ff\u5230\u5f53\u524d\u5e94\u7528 current_task_cx_ptr // \u548c\u5373\u5c06\u88ab\u5207\u6362\u5230\u7684\u5e94\u7528 next_task_cx_ptr \u7684\u4efb\u52a1\u4e0a\u4e0b\u6587\u6307\u9488\uff0c // \u7136\u540e\u8c03\u7528 __switch \u63a5\u53e3\u8fdb\u884c\u5207\u6362 // go back to user mode } else { // \u627e\u4e0d\u5230\u5c31 panic\uff0c\u6b64\u65f6 panic \u540e\u5c31\u4f1a\u9000\u51fa panic!(\"All applications completed!\"); } } } pub fn run_first_task() { TASK_MANAGER.run_first_task(); // \u5b83\u8c03\u7528\u4e86\u5168\u5c40\u4efb\u52a1\u7ba1\u7406\u5668 TASK_MANAGER \u7684 run_first_task \u65b9\u6cd5\u3002 } fn run_next_task() { TASK_MANAGER.run_next_task(); // \u5b83\u8c03\u7528\u4e86\u5168\u5c40\u4efb\u52a1\u7ba1\u7406\u5668 TASK_MANAGER \u7684 run_next_task \u65b9\u6cd5\u3002 } fn mark_current_suspended() { TASK_MANAGER.mark_current_suspended(); // \u5b83\u8c03\u7528\u4e86\u5168\u5c40\u4efb\u52a1\u7ba1\u7406\u5668 TASK_MANAGER \u7684 mark_current_suspended \u65b9\u6cd5\u3002 } fn mark_current_exited() { TASK_MANAGER.mark_current_exited(); // \u5b83\u8c03\u7528\u4e86\u5168\u5c40\u4efb\u52a1\u7ba1\u7406\u5668 TASK_MANAGER \u7684 mark_current_exited \u65b9\u6cd5\u3002 } pub fn suspend_current_and_run_next() { mark_current_suspended(); // \u5148\u4fee\u6539\u5f53\u524d\u5e94\u7528\u7684\u8fd0\u884c\u72b6\u6001 run_next_task(); // \u7136\u540e\u5c1d\u8bd5\u5207\u6362\u5230\u4e0b\u4e00\u4e2a\u5e94\u7528 } pub fn exit_current_and_run_next() { mark_current_exited(); // \u5148\u4fee\u6539\u5f53\u524d\u5e94\u7528\u7684\u8fd0\u884c\u72b6\u6001 run_next_task(); // \u7136\u540e\u5c1d\u8bd5\u5207\u6362\u5230\u4e0b\u4e00\u4e2a\u5e94\u7528 } os/src/trap/context.rs use riscv::register::sstatus::{Sstatus, self, SPP}; #[repr(C)] pub struct TrapContext { pub x: [usize; 32], pub sstatus: Sstatus, pub sepc: usize, } impl TrapContext { pub fn set_sp(&mut self, sp: usize) { self.x[2] = sp; } pub fn app_init_context(entry: usize, sp: usize) -> Self { let mut sstatus = sstatus::read(); sstatus.set_spp(SPP::User); let mut cx = Self { x: [0; 32], sstatus, sepc: entry, }; cx.set_sp(sp); cx } } os/src/trap/mod.rs mod context; use riscv::register::{ mtvec::TrapMode, stvec, scause::{ self, Trap, Exception, Interrupt, }, stval, sie, }; use crate::syscall::syscall; // use crate::batch::run_next_app; use core::arch::global_asm; use crate::task::{ exit_current_and_run_next, suspend_current_and_run_next, }; use crate::timer::set_next_trigger; global_asm!(include_str!(\"trap.S\")); pub fn init(){ extern \"C\" {fn __alltraps();} unsafe{ stvec::write(__alltraps as usize, TrapMode::Direct); } } #[no_mangle] pub fn trap_handler(cx: &mut TrapContext) -> &mut TrapContext{ let scause = scause::read(); let stval = stval::read(); match scause.cause(){ Trap::Exception(Exception::UserEnvCall) => { cx.sepc += 4; cx.x[10] = syscall(cx.x[17], [cx.x[10], cx.x[11], cx.x[12]]) as usize; } Trap::Exception(Exception::StoreFault) | Trap::Exception(Exception::StorePageFault) => { println!(\"[kernel] PageFault in application, bad addr = {:#x}, bad instruction = {:#x}, kernel killed it.\", stval, cx.sepc); exit_current_and_run_next(); } Trap::Exception(Exception::IllegalInstruction) => { println!(\"[kernel] IllegalInstruction in application, kernel killed it.\"); exit_current_and_run_next(); } Trap::Interrupt(Interrupt::SupervisorTimer) => { set_next_trigger(); suspend_current_and_run_next(); } // \u5f53\u53d1\u73b0\u89e6\u53d1\u4e86\u4e00\u4e2a S \u7279\u6743\u7ea7\u65f6\u949f\u4e2d\u65ad\u7684\u65f6\u5019\uff0c\u9996\u5148\u91cd\u65b0\u8bbe\u7f6e\u4e00\u4e2a 10ms \u7684\u8ba1\u65f6\u5668\uff0c // \u7136\u540e\u8c03\u7528\u4e0a\u4e00\u5c0f\u8282\u63d0\u5230\u7684 suspend_current_and_run_next \u51fd\u6570\u6682\u505c\u5f53\u524d\u5e94\u7528\u5e76\u5207\u6362\u5230\u4e0b\u4e00\u4e2a _ => { panic!(\"Unsupported trap {:?}, stval = {:#x}!\", scause.cause(), stval); } } cx } pub use context::TrapContext; // use riscv::register::sie; pub fn enable_timer_interrupt() { unsafe { sie::set_stimer(); } } os/src/trap/trap.S .altmacro .macro SAVE_GP n sd x\\n, \\n*8(sp) .endm .macro LOAD_GP n ld x\\n, \\n*8(sp) .endm .section .text .globl __alltraps .globl __restore .align 2 __alltraps: csrrw sp, sscratch, sp # now sp->kernel stack, sscratch->user stack # allocate a TrapContext on kernel stack addi sp, sp, -34*8 # save general-purpose registers sd x1, 1*8(sp) # skip sp(x2), we will save it later sd x3, 3*8(sp) # skip tp(x4), application does not use it # save x5~x31 .set n, 5 .rept 27 SAVE_GP %n .set n, n+1 .endr # we can use t0/t1/t2 freely, because they were saved on kernel stack csrr t0, sstatus csrr t1, sepc sd t0, 32*8(sp) sd t1, 33*8(sp) # read user stack from sscratch and save it on the kernel stack csrr t2, sscratch sd t2, 2*8(sp) # set input argument of trap_handler(cx: &mut TrapContext) mv a0, sp call trap_handler __restore: # now sp->kernel stack(after allocated), sscratch->user stack # restore sstatus/sepc # \u5b83 \u4e0d\u518d\u9700\u8981 \u5728\u5f00\u5934 mv sp, a0 \u4e86\u3002\u56e0\u4e3a\u5728 __switch \u4e4b\u540e\uff0c # sp \u5c31\u5df2\u7ecf\u6b63\u786e\u6307\u5411\u4e86\u6211\u4eec\u9700\u8981\u7684 Trap \u4e0a\u4e0b\u6587\u5730\u5740 ld t0, 32*8(sp) ld t1, 33*8(sp) ld t2, 2*8(sp) csrw sstatus, t0 csrw sepc, t1 csrw sscratch, t2 # restore general-purpuse registers except sp/tp ld x1, 1*8(sp) ld x3, 3*8(sp) .set n, 5 .rept 27 LOAD_GP %n .set n, n+1 .endr # release TrapContext on kernel stack addi sp, sp, 34*8 # now sp->kernel stack, sscratch->user stack csrrw sp, sscratch, sp sret os/src/loader.rs use crate::trap::TrapContext; use crate::config::*; use core::arch::asm; #[repr(align(4096))] #[derive(Copy, Clone)] struct KernelStack { data: [u8; KERNEL_STACK_SIZE], } #[repr(align(4096))] #[derive(Copy, Clone)] struct UserStack { data: [u8; USER_STACK_SIZE], } static KERNEL_STACK: [KernelStack; MAX_APP_NUM] = [ KernelStack { data: [0; KERNEL_STACK_SIZE], }; MAX_APP_NUM ]; static USER_STACK: [UserStack; MAX_APP_NUM] = [ UserStack { data: [0; USER_STACK_SIZE], }; MAX_APP_NUM ]; impl KernelStack { fn get_sp(&self) -> usize { self.data.as_ptr() as usize + KERNEL_STACK_SIZE } pub fn push_context(&self, trap_cx: TrapContext) -> usize { let trap_cx_ptr = (self.get_sp() - core::mem::size_of::<TrapContext>()) as *mut TrapContext; unsafe { *trap_cx_ptr = trap_cx; } trap_cx_ptr as usize } } impl UserStack { fn get_sp(&self) -> usize { self.data.as_ptr() as usize + USER_STACK_SIZE } } fn get_base_i(app_id: usize) -> usize { APP_BASE_ADDRESS + app_id * APP_SIZE_LIMIT } // \u83b7\u53d6\u7b2c i \u4e2a\u5e94\u7528\u7684\u8d77\u59cb\u5730\u5740 pub fn get_num_app() -> usize { extern \"C\" { fn _num_app(); } unsafe { (_num_app as usize as *const usize).read_volatile() } } // \u83b7\u53d6 _num_app, \u5373\u5e94\u7528\u7684\u4e2a\u6570 pub fn load_apps() { extern \"C\" { fn _num_app(); } let num_app_ptr = _num_app as usize as *const usize; let num_app = get_num_app(); let app_start = unsafe { core::slice::from_raw_parts(num_app_ptr.add(1), num_app + 1) }; // clear i-cache first unsafe { asm!(\"fence.i\"); } // load apps for i in 0..num_app { let base_i = get_base_i(i); // \u83b7\u53d6\u7b2c i \u4e2a\u5e94\u7528\u7684\u8d77\u59cb\u5730\u5740 (base_i..base_i + APP_SIZE_LIMIT).for_each(|addr| unsafe { (addr as *mut u8).write_volatile(0) }); // \u5c06\u7528\u4e8e\u5b58\u653e\u7b2c i \u4e2a\u5e94\u7528\u7684\u5730\u5740\u533a\u95f4 \u7528 0 \u586b\u5145 let src = unsafe { core::slice::from_raw_parts(app_start[i] as *const u8, app_start[i + 1] - app_start[i]) }; // \u83b7\u53d6\u7b2c i \u4e2a\u5e94\u7528\u5728 .data \u6bb5\u4e2d\u7684\u8d77\u59cb\u5730\u5740 \u548c \u957f\u5ea6 let dst = unsafe { core::slice::from_raw_parts_mut(base_i as *mut u8, src.len()) }; // \u5c06\u521a\u624d\u7528 0 \u586b\u5145\u7684\u8d77\u59cb\u5730\u5740 \u548c \u5e94\u7528\u7684\u957f\u5ea6\u5c01\u88c5\u8d77\u6765 dst.copy_from_slice(src); // \u5c06\u7b2c i \u4e2a\u5e94\u7528 \u4ece .data \u6bb5\u52a0\u8f7d\u5230 \u4e0a\u9762\u5bf9\u5e94\u7684\u5730\u5740\u7a7a\u95f4 } } pub fn init_app_cx(app_id: usize) -> usize { // \u6784\u9020\u8be5\u4efb\u52a1\u7684 Trap \u4e0a\u4e0b\u6587\uff08\u5305\u62ec\u5e94\u7528\u5165\u53e3\u5730\u5740\u548c\u7528\u6237\u6808\u6307\u9488\uff09\u5e76\u5c06\u5176\u538b\u5165\u5230\u5185\u6838\u6808\u9876 KERNEL_STACK[app_id].push_context( TrapContext::app_init_context(get_base_i(app_id), USER_STACK[app_id].get_sp()), ) } os/src/main.rs #![no_std] #![no_main] #![feature(panic_info_message)] #[macro_use] mod console; mod lang_items; mod sbi; mod syscall; mod trap; // mod batch; mod loader; mod config; mod task; mod sync; mod timer; use core::arch::global_asm; global_asm!(include_str!(\"entry.asm\")); global_asm!(include_str!(\"link_app.S\")); fn clear_bss(){ extern \"C\" { fn sbss(); fn ebss(); } // (sbss as usize..ebss as usize).for_each(|a| { // unsafe { (a as *mut u8).write_volatile(0)} // }); unsafe { core::slice::from_raw_parts_mut( sbss as usize as *mut u8, ebss as usize - sbss as usize, ).fill(0); } } #[no_mangle] pub fn rust_main() -> ! { clear_bss(); // loop {} // println!(\"Hello, world\"); // println!(\"I am zk\"); // println!(\"\\x1b[31mhello world\\x1b[0m\"); // extern \"C\" { // fn stext(); // fn etext(); // } // println!(\".text location: {}\", stext as usize); // panic!(\"Shutdown machine!\"); println!(\"[kernel] Hello, world!\"); // println!(\"test {} a {} text.\", 3, 5); trap::init(); // batch::init(); // batch::run_next_app(); loader::load_apps(); trap::enable_timer_interrupt(); // \u4e3a\u4e86\u907f\u514d S \u7279\u6743\u7ea7\u65f6\u949f\u4e2d\u65ad\u88ab\u5c4f\u853d\uff0c\u6211\u4eec\u9700\u8981\u5728\u6267\u884c\u7b2c\u4e00\u4e2a\u5e94\u7528\u4e4b\u524d\u8fdb\u884c\u4e00\u4e9b\u521d\u59cb\u5316\u8bbe\u7f6e // \u8bbe\u7f6e\u4e86 sie.stie \u4f7f\u5f97 S \u7279\u6743\u7ea7\u65f6\u949f\u4e2d\u65ad\u4e0d\u4f1a\u88ab\u5c4f\u853d timer::set_next_trigger(); // \u8bbe\u7f6e\u7b2c\u4e00\u4e2a 10ms \u7684\u8ba1\u65f6\u5668 task::run_first_task(); panic!(\"Unreachable in rust_main!\"); } os/Makefile #Building TARGET := riscv64gc-unknown-none-elf MODE := release KERNEL_ELF := target/$(TARGET)/$(MODE)/os KERNEL_BIN := $(KERNEL_ELF).bin DISASM_TMP := target/$(TARGET)/$(MODE)/asm #BOARD BOARD ?= qemu SBI ?= rustsbi BOOTLOADER := ../bootloader/$(SBI)-$(BOARD).bin K210_BOOTLOADER_SIZE := 131072 #KERNEL ENTRY ifeq ($(BOARD), qemu) KERNEL_ENTRY_PA := 0x80200000 else ifeq ($(BOARD), k210) KERNEL_ENTRY_PA := 0x80020000 endif #Run K210 K210-SERIALPORT = /dev/ttyUSB0 K210-BURNER = ../tools/kflash.py #Binutils OBJDUMP := rust-objdump --arch-name=riscv64 OBJCOPY := rust-objcopy --binary-architecture=riscv64 #Disassembly DISASM ?= -x build: env switch-check $(KERNEL_BIN) switch-check: ifeq ($(BOARD), qemu) (which last-qemu) || (rm -f last-k210 && touch last-qemu && make clean) else ifeq ($(BOARD), k210) (which last-k210) || (rm -f last-qemu && touch last-k210 && make clean) endif env: (rustup target list | grep \"riscv64gc-unknown-none-elf (installed)\") || rustup target add $(TARGET) cargo install cargo-binutils --vers =0.3.3 rustup component add rust-src rustup component add llvm-tools-preview $(KERNEL_BIN): kernel @$(OBJCOPY) $(KERNEL_ELF) --strip-all -O binary $@ kernel: @cd ../user && make build @echo Platform: $(BOARD) @cp src/linker-$(BOARD).ld src/linker.ld @cargo build --release --features \"board_$(BOARD)\" # \u8fd9\u91cc\u591a\u4e86 --features \"board_$(BOARD)\" @rm src/linker.ld clean: @cargo clean disasm: kernel @$(OBJDUMP) $(DISASM) $(KERNEL_ELF) | less disasm-vim: kernel @$(OBJDUMP) $(DISASM) $(KERNEL_ELF) > $(DISASM_TMP) @vim $(DISASM_TMP) @rm $(DISASM_TMP) run: run-inner run-inner: build ifeq ($(BOARD), qemu) @qemu-system-riscv64 \\ -machine virt \\ -nographic \\ -bios $(BOOTLOADER) \\ -device loader,file=$(KERNEL_BIN),addr=$(KERNEL_ENTRY_PA) else (which $(K210-BURNER)) || (cd .. && git clone https://github.com/sipeed/kflash.py.git && mv kflash.py tools) @cp $(BOOTLOADER) $(BOOTLOADER).copy @dd if=$(KERNEL_BIN) of=$(BOOTLOADER).copy bs=$(K210_BOOTLOADER_SIZE) seek=1 @mv $(BOOTLOADER).copy $(KERNEL_BIN) @sudo chmod 777 $(K210-SERIALPORT) python3 $(K210-BURNER) -p $(K210-SERIALPORT) -b 1500000 $(KERNEL_BIN) python3 -m serial.tools.miniterm --eol LF --dtr 0 --rts 0 --filter direct $(K210-SERIALPORT) 115200 endif debug: build @tmux new-session -d \\ \"qemu-system-riscv64 -machine virt -nographic -bios $(BOOTLOADER) -device loader,file=$(KERNEL_BIN),addr=$(KERNEL_ENTRY_PA) -s -S\" && \\ tmux split-window -h \"riscv64-unknown-elf-gdb -ex 'file $(KERNEL_ELF)' -ex 'set arch riscv64:riscv64' -ex 'target remote localhost:1234'\" && \\ tmux -2 attach-session -d .PHONY: build env kernel clean disasm disasm-vim run-inner switch-check \u5728 user \u6587\u4ef6\u5939\u4e0b user/.cargo/config [build] target = \"riscv64gc-unknown-none-elf\" [target.riscv64gc-unknown-none-elf] rustflags = [ \"-Clink-args=-Tsrc/linker.ld\", ] user/Cargo.toml [package] name = \"user_lib\" version = \"0.1.0\" authors = [\"Yifan Wu <shinbokuow@163.com>\"] edition = \"2018\" # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html [dependencies] user/build.py import os base_address = 0x80400000 step = 0x20000 linker = 'src/linker.ld' app_id = 0 apps = os.listdir('src/bin') # \u5f97\u5230\u4e00\u4e2a\u5217\u8868\uff0c \u91cc\u9762\u662f \u6587\u4ef6\u540d apps.sort() for app in apps: app = app[:app.find('.')] # app \u53d8\u6210\u4e0d\u5e26\u540e\u7f00\u7684\u6587\u4ef6\u540d lines = [] lines_before = [] with open(linker, 'r') as f: for line in f.readlines(): lines_before.append(line) line = line.replace(hex(base_address), hex(base_address+step*app_id)) lines.append(line) with open(linker, 'w+') as f: f.writelines(lines) # \u627e\u5230 src/linker.ld \u4e2d\u7684 BASE_ADDRESS = 0x80400000; # \u8fd9\u4e00\u884c\uff0c\u5e76\u5c06\u540e\u9762\u7684\u5730\u5740\u66ff\u6362\u4e3a\u548c\u5f53\u524d\u5e94\u7528\u5bf9\u5e94\u7684\u4e00\u4e2a\u5730\u5740 os.system('cargo build --bin %s --release' % app) # \u4f7f\u7528 --bin \u53c2\u6570\u6765\u53ea\u6784\u5efa\u67d0\u4e00\u4e2a\u5e94\u7528 # \u90a3\u5c31\u662f\u5bf9\u6bcf\u4e2a\u5e94\u7528\u5206\u522b\u8fdb\u884c\u7f16\u8bd1 \u6539\u53d8\u5176 \u8d77\u59cb\u5730\u5740 print('[build.py] application %s start with address %s' %(app, hex(base_address+step*app_id))) with open(linker, 'w+') as f: f.writelines(lines_before) # \u5c06 linker.ld \u590d\u539f\uff0c \u73b0\u5728\u7684 base_address = 0x80400000+step*app_id # \u6062\u590d\u4e3a 0x80400000 app_id = app_id + 1 user/src/console.rs use core::fmt::{self, Write}; use super::write; struct Stdout; const STDOUT: usize = 1; impl Write for Stdout { fn write_str(&mut self, s: &str) -> fmt::Result { write(STDOUT, s.as_bytes()); Ok(()) } } pub fn print(args: fmt::Arguments) { Stdout.write_fmt(args).unwrap(); } #[macro_export] macro_rules! print { ($fmt: literal $(, $($arg: tt)+)?) => { $crate::console::print(format_args!($fmt $(, $($arg)+)?)); } } #[macro_export] macro_rules! println { ($fmt: literal $(, $($arg: tt)+)?) => { $crate::console::print(format_args!(concat!($fmt, \"\\n\") $(, $($arg)+)?)); } } user/src/lang_items.rs #[panic_handler] fn panic_handler(panic_info: &core::panic::PanicInfo) -> ! { let err = panic_info.message().unwrap(); if let Some(location) = panic_info.location() { println!(\"Panicked at {}:{}, {}\", location.file(), location.line(), err); } else { println!(\"Panicked: {}\", err); } loop {} } user/src/lib.rs #![no_std] #![feature(panic_info_message)] #![feature(linkage)] #[macro_use] pub mod console; mod syscall; mod lang_items; #[no_mangle] #[link_section = \".text.entry\"] pub extern \"C\" fn _start() -> ! { clear_bss(); exit(main()); panic!(\"unreachable after sys_exit!\"); } #[linkage = \"weak\"] #[no_mangle] fn main() -> i32 { panic!(\"Cannot find main\"); } fn clear_bss(){ extern \"C\" { fn start_bss(); fn end_bss(); } (start_bss as usize..end_bss as usize).for_each(|addr|{ unsafe{ (addr as *mut u8).write_volatile(0);} }); } use syscall::*; pub fn write(fd: usize, buf: &[u8]) -> isize {sys_write(fd, buf)} pub fn exit(exit_code: i32) -> isize {sys_exit(exit_code)} pub fn yield_() -> isize { sys_yield() } pub fn get_time() -> isize { sys_get_time() } user/src/linker.ld OUTPUT_ARCH(riscv) ENTRY(_start) BASE_ADDRESS = 0x80400000; SECTIONS { . = BASE_ADDRESS; .text : { *(.text.entry) *(.text .text.*) } .rodata : { *(.rodata .rodata.*) *(.srodata .srodata.*) } .data : { *(.data .data.*) *(.sdata .sdata.*) } .bss : { start_bss = .; *(.bss .bss.*) *(.sbss .sbss.*) end_bss = .; } /DISCARD/ : { *(.eh_frame) *(.debug*) } } user/src/syscall.rs use core::arch::asm; const SYSCALL_WRITE: usize = 64; const SYSCALL_EXIT: usize = 93; const SYSCALL_YIELD: usize = 124; const SYSCALL_GET_TIME: usize = 169; fn syscall(id: usize, args: [usize; 3]) -> isize{ let mut ret: isize; unsafe{ asm!( \"ecall\", inlateout(\"x10\") args[0] => ret, in(\"x11\") args[1], in(\"x12\") args[2], in(\"x17\") id ); } ret } pub fn sys_write(fd: usize, buffer: &[u8]) -> isize{ syscall(SYSCALL_WRITE, [fd, buffer.as_ptr() as usize, buffer.len()]) } pub fn sys_exit(exit_code: i32) -> isize { syscall(SYSCALL_EXIT, [exit_code as usize, 0, 0]) } pub fn sys_yield() -> isize { syscall(SYSCALL_YIELD, [0, 0, 0]) } pub fn sys_get_time() -> isize { syscall(SYSCALL_GET_TIME, [0, 0, 0]) } user/src/bin/00power_3.rs #![no_std] #![no_main] #[macro_use] extern crate user_lib; const LEN: usize = 100; #[no_mangle] fn main() -> i32 { let p = 3u64; let m = 998244353u64; let iter: usize = 200000; let mut s = [0u64; LEN]; let mut cur = 0usize; s[cur] = 1; for i in 1..=iter { let next = if cur + 1 == LEN { 0 } else { cur + 1 }; s[next] = s[cur] * p % m; cur = next; if i % 10000 == 0 { println!(\"power_3 [{}/{}]\", i, iter); } } println!(\"{}^{} = {}(MOD {})\", p, iter, s[cur], m); println!(\"Test power_3 OK!\"); 0 } user/src/bin/01power_5.rs #![no_std] #![no_main] #[macro_use] extern crate user_lib; const LEN: usize = 100; #[no_mangle] fn main() -> i32 { let p = 5u64; let m = 998244353u64; let iter: usize = 140000; let mut s = [0u64; LEN]; let mut cur = 0usize; s[cur] = 1; for i in 1..=iter { let next = if cur + 1 == LEN { 0 } else { cur + 1 }; s[next] = s[cur] * p % m; cur = next; if i % 10000 == 0 { println!(\"power_5 [{}/{}]\", i, iter); } } println!(\"{}^{} = {}(MOD {})\", p, iter, s[cur], m); println!(\"Test power_5 OK!\"); 0 } user/src/bin/02power_7.rs #![no_std] #![no_main] #[macro_use] extern crate user_lib; const LEN: usize = 100; #[no_mangle] fn main() -> i32 { let p = 7u64; let m = 998244353u64; let iter: usize = 160000; let mut s = [0u64; LEN]; let mut cur = 0usize; s[cur] = 1; for i in 1..=iter { let next = if cur + 1 == LEN { 0 } else { cur + 1 }; s[next] = s[cur] * p % m; cur = next; if i % 10000 == 0 { println!(\"power_7 [{}/{}]\", i, iter); } } println!(\"{}^{} = {}(MOD {})\", p, iter, s[cur], m); println!(\"Test power_7 OK!\"); 0 } user/src/bin/03sleep.rs #![no_std] #![no_main] #[macro_use] extern crate user_lib; use user_lib::{get_time, yield_}; #[no_mangle] fn main() -> i32 { let current_timer = get_time(); let wait_for = current_timer + 3000; while get_time() < wait_for { yield_(); } println!(\"Test sleep OK!\"); 0 } user/Makefile TARGET := riscv64gc-unknown-none-elf MODE := release APP_DIR := src/bin TARGET_DIR := target/$(TARGET)/$(MODE) APPS := $(wildcard $(APP_DIR)/*.rs) ELFS := $(patsubst $(APP_DIR)/%.rs, $(TARGET_DIR)/%, $(APPS)) BINS := $(patsubst $(APP_DIR)/%.rs, $(TARGET_DIR)/%.bin, $(APPS)) OBJDUMP := rust-objdump --arch-name=riscv64 OBJCOPY := rust-objcopy --binary-architecture=riscv64 elf: $(APPS) @python3 build.py binary: elf $(foreach elf, $(ELFS), $(OBJCOPY) $(elf) --strip-all -O binary $(patsubst $(TARGET_DIR)/%, $(TARGET_DIR)/%.bin, $(elf));) build: binary clean: @cargo clean .PHONY: elf binary build clean \u6267\u884c\u6d41\u7a0b os/src/main.rs - \u5bfc\u5165 entry.asm \u8bbe\u7f6e\u51fd\u6570\u6808\uff0c \u8df3\u8f6c\u5230rust_main \u5bfc\u5165 link_app.S \u8fd9\u91cc\u5168\u662f\u6570\u636e\u6bb5\uff0c \u53ef\u6267\u884c\u6587\u4ef6\u5728\u90e8\u5206\u6570\u636e\u6bb5\u4e2d \u8c03\u7528 clear_bass \u51fd\u6570\uff0c \u6e05\u9664 \u9664 .bss.stack \u4ee5\u5916\u7684 .bss \u6bb5 \u8c03\u7528 println! \u6253\u5370 [kernel] Hello, world! , \u6b64\u65f6\u5904\u4e8e\u5185\u6838\u6001 \u8c03\u7528 trap::init os/src/trap/mod.rs \u6211\u4eec\u9700\u8981\u4fee\u6539stvec \u5bc4\u5b58\u5668\u6765\u6307\u5411\u6b63\u786e\u7684Trap\u5904\u7406\u5165\u53e3\u70b9 \u5c06stvec\u8bbe\u7f6e\u4e3aDirect\u6a21\u5f0f\u6307\u5411\u5b83\u7684\u5730\u5740 \u6ce8\u610f\uff1a\u7531\u4e8e\u524d\u9762\u6709\u5bfc\u5165 trap.S\uff0c \u6240\u6709\u8fd9\u91cc\u77e5\u9053 Trap\u7684\u5904\u7406\u5165\u53e3 \u5373 __alltraps \u8c03\u7528 loader::load_apps os/src/loader.rs \u8c03\u7528 get_num_app \u83b7\u53d6\u5e94\u7528\u4e2a\u6570 \u83b7\u53d6\u7b2c\u4e00\u4e2a\u7a0b\u5e8f\u7684\u5165\u53e3\u5730\u5740 \u5237\u65b0\u6307\u4ee4\u7f13\u51b2\u533a \u8c03\u7528 get_base_i \u83b7\u53d6 \u6bcf\u4e2a\u5e94\u7528\u7a0b\u5e8f\u7684\u8d77\u59cb\u5730\u5740 \u5c06\u6bcf\u4e2a\u5e94\u7528\u8d77\u59cb\u5730\u5740\u5230 \u5e94\u7528\u7a7a\u95f4\u9650\u5236\u8303\u56f4\u7684\u5730\u5740\u533a\u95f4 \u7528 0 \u586b\u5145 \u83b7\u53d6\u6bcf\u4e2a\u5e94\u7528\u5728 .data \u6bb5\u7684\u8d77\u59cb\u5730\u5740\u548c\u5927\u5c0f \u548c \u5728\u5c06\u4f1a\u653e\u7f6e\u8be5\u7a0b\u5e8f\u7684\u8d77\u59cb\u5730\u5740\u548c\u7a0b\u5e8f\u5927\u5c0f \u8c03\u7528 copy_from_slice \u5c06\u7a0b\u5e8f\u4ece .data \u6bb5\u590d\u5236\u5230 \u76f8\u5e94\u7684\u5730\u5740\u533a\u95f4 \u81f3\u6b64\uff0c\u7a0b\u5e8f\u52a0\u8f7d\u5b8c\u6bd5 os/src/main.rs \u8c03\u7528 trap::enable_timer_interrupt os/src/trap/mod.rs \u8c03\u7528 sie::set_stimer \u4f7f\u5f97 S \u7279\u6743\u7ea7\u65f6\u949f\u4e2d\u65ad\u4e0d\u4f1a\u88ab\u5c4f\u853d os/src/main.rs \u8c03\u7528 timer::set_next_trigger os/src/timer.rs \u8c03\u7528 get_time \u83b7\u5f97\u5f53\u524d\u65f6\u95f4\uff0c \u5373 mtime \u7684\u503c \u4f30\u7b97\u51fa 10 ms \u540e mtime \u7684\u503c \u518d\u5c06\u4f30\u7b97\u7684\u503c\u8d4b\u503c\u7ed9 mtimecmp os/src/main.rs \u8c03\u7528 task \u6a21\u5757\u7684 run_first_task os/src/task/mod.rs \u9996\u5148\uff0c\u9759\u6001\u52a0\u8f7d\u4e00\u4e2a\u5168\u5c40\u7684\u4efb\u52a1\u7ba1\u7406\u5668 TaskManager \u7ed3\u6784 \u7684\u5b9e\u4f8b TASK_MANAGER,\u5305\u542b num_app \u548c inner inner \u5305\u62ec \u6570\u7ec4 tasks \u548c current_task \u6570\u7ec4 tasks \u662f TaskControlBlock \u7ed3\u6784\u7684\u6570\u7ec4 TaskControlBlock \u7ed3\u6784\u4f53 \u5305\u62ec \u4efb\u52a1\u72b6\u6001 task_status \u548c \u4efb\u52a1\u4e0a\u4e0b\u6587 TaskContext TaskContext \u5305\u542b \u90a314\u4e2a\u5bc4\u5b58\u5668 \u5bf9\u4efb\u52a1\u6570\u7ec4\u8fdb\u884c\u521d\u59cb\u5316\uff0c\u5c06\u6bcf\u4e2a\u4efb\u52a1\u90fd\u8fdb\u884c\u521d\u59cb\u5316 \u5bf9\u4efb\u52a1\u4e0a\u4e0b\u6587\u8c03\u7528 zero_init \u8fdb\u884c\u521d\u59cb\u5316\uff0c\u5373\u5c06\u8fd9 14 \u4e2a\u5bc4\u5b58\u5668\u90fd\u521d\u59cb\u5316\u4e3a 0 \u5c06\u4efb\u52a1\u7684\u72b6\u6001 \u8bbe\u7f6e\u4e3a UnInit, \u5373\u672a\u521d\u59cb\u5316 \u5bf9\u4e8e\u6bcf\u4e2a\u4efb\u52a1\uff0c\u5148\u8c03\u7528 init_app_cx, \u6784\u9020\u8be5\u4efb\u52a1\u7684 Trap \u4e0a\u4e0b\u6587 \u5728 os/src/loader.rs \u83b7\u53d6\u6bcf\u4e2a\u5e94\u7528\u7684 \u8d77\u59cb\u5730\u5740 \u548c \u6808\u9488 \u521d\u59cb\u5316\u5b83\u7684 Trap \u4e0a\u4e0b\u6587 \u5728 os/src/trap/context.rs \u83b7\u53d6\u5f53\u524d\u7684 sstatus \u5e76\u5b58\u653e\u5728\u7ed3\u6784\u4e2d \u5c06\u8fd9\u4e2a sstatus \u7ed3\u6784\u7684 SPP\u7f6e\u4f4d User \u5c06\u901a\u7528\u5bc4\u5b58\u5668 \u5168\u7f6e\u4e3a 0 \u5c06 sepc \u8bbe\u4e3a\u4f20\u5165\u7684\u5e94\u7528\u7684\u5730\u5740 entry \u5c06 Trap\u4e0a\u4e0b\u6587\u7684 sp \u7f6e\u4e3a \u4f20\u5165\u7684 \u5185\u6838\u6808\u5730\u5740 sp \u8fd4\u56de Trap \u4e0a\u4e0b\u6587 \u5c06 Trap \u4e0a\u4e0b\u6587 push \u5230\u5185\u6838\u6808\u4e2d \u8fd4\u56de\u4e00\u4e2a \u6267\u884c\u6539\u4e0a\u4e0b\u6587\u7684 \u6307\u9488 \u5c06\u6307\u5411 Trap \u4e0a\u4e0b\u6587\u7684 \u6307\u9488 \u4f20\u5165\u5230 goto_restoren \u51fd\u6570\u4e2d \u7528\u5b83\u521d\u59cb\u5316\u4efb\u52a1\u4e0a\u4e0b\u6587 TaskContext \u5c06\u4efb\u52a1\u4e0a\u4e0b\u6587\u8fd4\u56de\u7ed9\u6bcf\u4e2a\u4efb\u52a1 \u5c06\u6bcf\u4e2a\u4efb\u52a1\u90fd\u7f6e\u4e3a Ready \u6700\u540e\uff0c\u83b7\u5f97\u4e00\u4e2a\u4efb\u52a1\u7ba1\u7406\u5668\uff0c\u5b83\u5305\u542b \u4efb\u52a1\u6570\uff0c\u4efb\u52a1\u6570\u7ec4\uff0c\u5f53\u524d\u4efb\u52a1\u7684\u7f16\u53f7 \u8fd9\u6837\uff0c\u9759\u6001\u52a0\u8f7d\u5668\u7684\u4efb\u52a1\u5b8c\u6210 \u8c03\u7528 run_first_task \u5c06\u7b2c\u4e00\u4e2a\u4efb\u52a1\u7684\u72b6\u6001\u7f6e\u4e3a Running \u521b\u5efa\u4e00\u4e2a\u6307\u9488 \u6307\u5411 \u7b2c\u4e00\u4e2a\u4efb\u52a1\u7684\u4efb\u52a1\u4e0a\u4e0b\u6587 \u6784\u9020\u4e00\u4e2a \u53ea\u6709\u4efb\u52a1\u4e0a\u4e0b\u6587\u7ed3\u6784\u800c\u65e0\u771f\u6b63\u5185\u5bb9\u7684 \u4efb\u52a1\u4e0a\u4e0b\u6587 \u5c06 \u8fd9\u4e24\u4e2a\u4e0a\u4e0b\u6587\u7684 \u6307\u9488\u9001\u7ed9 \u5207\u6362\u51fd\u6570 _switch _switch \u51fd\u6570\u5728\u5c06\u4ed6\u4eec\u9001\u5230 \u6c47\u7f16\u51fd\u6570 _switch \u4e2d \u4fdd\u5b58\u5f53\u524d\u4efb\u52a1\u7684 \u6808\u6bb5\uff0c \u4fdd\u5b58\u5f53\u524d \u4efb\u52a1\u4e0a\u4e0b\u6587\uff0c \u6062\u590d\u4e0b\u4e00\u4e2a\u4efb\u52a1\u4e0a\u4e0b\u6587\uff0c \u6062\u590d\u4e0b\u4e00\u4e2a\u4efb\u52a1\u7684 \u6808\u6bb5 ret \u8fd4\u56de\u5230 \u4e0b\u4e00\u4e2a\u4efb\u52a1\uff0c\u8fdb\u5165\u5230\u7528\u6237\u6001 user/src/bin/00power_3.rs \u6b63\u5e38\u8fd0\u884c \u8fbe\u5230\u65f6\u95f4\u540e\uff0c\u4e2d\u65ad\u89e6\u53d1\uff0c \u8fdb\u5165 Trap \u8fdb\u5165\u5230 __alltraps, \u4fdd\u5b58\u5b8c\u4e0a\u4e0b\u6587\u540e\uff0c\u8fdb\u5165\u5230 trap_handler \u5224\u65ad\u51fa\u662f \u65f6\u949f\u4e2d\u65ad\uff0c\u5148\u8bbe\u7f6e\u4e0b\u4e00\u4e2a\u4e2d\u65ad\u7684\u65f6\u95f4 \u518d\u60ac\u7f6e\u5f53\u524d\u4efb\u52a1\uff0c\u8df3\u8f6c\u5230\u4e0b\u4e00\u4e2a\u4efb\u52a1 \u5f53\u5e94\u7528\u5b8c\u6210\u4e86\uff0c \u6253\u5370 Test power_3 OK! user/src/lib.rs \u8c03\u7528 exit\uff0cexit \u8c03\u7528 sys_exit user/src/syscall.rs \u4e2d sys_exit \u8fdb\u884c \u7cfb\u7edf\u8c03\u7528 syscall , \u5f15\u53d1 ecall \u8df3\u8f6c\u5230 __alltraps \u8df3\u8f6c\u5230 os/src/syscall/mod.rs \u4e2d\u7684 sys_exit os/src/syscall/process.rs \u4e2d\u7684 sys_exit \u5148\u6253\u5370 [kernel] Application exited with code 0 \u7136\u540e\u8c03\u7528 exit_current_and_run_next \u518d\u6b21\u8fd4\u56de\u5230 os/src/task/mod.rs \u5148\u5c06 \u5f53\u524d\u4efb\u52a1\u7684\u72b6\u6001\u6807\u8bb0\u4e3a Exited \u518d\u8c03\u7528 run_next_task user/src/bin/sleep.rs \u5355\u51fa\u73b0 yield_ \u65f6\uff0c\u548c\u4e0a\u4e00\u8282\u4e00\u6837 \u5982\u679c\u6240\u6709\u7684\u4efb\u52a1\u90fd\u5b8c\u6210\u4e86\uff0c\u5c31 panic \u6253\u5370\u51fa All applications completed! \u6253\u5370 panic \u7684\u4f4d\u7f6e \u8c03\u7528 shutdown \u5173\u673a","title":"\u5b9e\u73b0\u5206\u65f6\u591a\u4efb\u52a1\u7cfb\u7edf\u4e0e\u62a2\u5360\u5f0f\u8c03\u5ea6"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/#_1","text":"","title":"\u5b9e\u73b0\u5206\u65f6\u591a\u4efb\u52a1\u7cfb\u7edf\u4e0e\u62a2\u5360\u5f0f\u8c03\u7528"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/#_2","text":"\u5206\u65f6\u591a\u4efb\u52a1\u7684\u4e3a\u4f8b ./os/src Rust 18 Files 511 Lines Assembly 3 Files 82 Lines \u251c\u2500\u2500 bootloader \u2502 \u251c\u2500\u2500 rustsbi-k210.bin \u2502 \u2514\u2500\u2500 rustsbi-qemu.bin \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 os \u2502 \u251c\u2500\u2500 build.rs \u2502 \u251c\u2500\u2500 Cargo.toml \u2502 \u251c\u2500\u2500 Makefile \u2502 \u2514\u2500\u2500 src \u2502 \u251c\u2500\u2500 batch.rs(\u79fb\u9664\uff1a\u529f\u80fd\u5206\u522b\u62c6\u5206\u5230 loader \u548c task \u4e24\u4e2a\u5b50\u6a21\u5757) \u2502 \u251c\u2500\u2500 config.rs(\u65b0\u589e\uff1a\u4fdd\u5b58\u5185\u6838\u7684\u4e00\u4e9b\u914d\u7f6e) \u2502 \u251c\u2500\u2500 console.rs \u2502 \u251c\u2500\u2500 entry.asm \u2502 \u251c\u2500\u2500 lang_items.rs \u2502 \u251c\u2500\u2500 link_app.S \u2502 \u251c\u2500\u2500 linker-k210.ld \u2502 \u251c\u2500\u2500 linker-qemu.ld \u2502 \u251c\u2500\u2500 loader.rs(\u65b0\u589e\uff1a\u5c06\u5e94\u7528\u52a0\u8f7d\u5230\u5185\u5b58\u5e76\u8fdb\u884c\u7ba1\u7406) \u2502 \u251c\u2500\u2500 main.rs(\u4fee\u6539\uff1a\u4e3b\u51fd\u6570\u8fdb\u884c\u4e86\u4fee\u6539) \u2502 \u251c\u2500\u2500 sbi.rs(\u4fee\u6539\uff1a\u5f15\u5165\u65b0\u7684 sbi call set_timer) \u2502 \u251c\u2500\u2500 sync \u2502 \u2502 \u251c\u2500\u2500 mod.rs \u2502 \u2502 \u2514\u2500\u2500 up.rs \u2502 \u251c\u2500\u2500 syscall(\u4fee\u6539\uff1a\u65b0\u589e\u82e5\u5e72 syscall) \u2502 \u2502 \u251c\u2500\u2500 fs.rs \u2502 \u2502 \u251c\u2500\u2500 mod.rs \u2502 \u2502 \u2514\u2500\u2500 process.rs \u2502 \u251c\u2500\u2500 task(\u65b0\u589e\uff1atask \u5b50\u6a21\u5757\uff0c\u4e3b\u8981\u8d1f\u8d23\u4efb\u52a1\u7ba1\u7406) \u2502 \u2502 \u251c\u2500\u2500 context.rs(\u5f15\u5165 Task \u4e0a\u4e0b\u6587 TaskContext) \u2502 \u2502 \u251c\u2500\u2500 mod.rs(\u5168\u5c40\u4efb\u52a1\u7ba1\u7406\u5668\u548c\u63d0\u4f9b\u7ed9\u5176\u4ed6\u6a21\u5757\u7684\u63a5\u53e3) \u2502 \u2502 \u251c\u2500\u2500 switch.rs(\u5c06\u4efb\u52a1\u5207\u6362\u7684\u6c47\u7f16\u4ee3\u7801\u89e3\u91ca\u4e3a Rust \u63a5\u53e3 __switch) \u2502 \u2502 \u251c\u2500\u2500 switch.S(\u4efb\u52a1\u5207\u6362\u7684\u6c47\u7f16\u4ee3\u7801) \u2502 \u2502 \u2514\u2500\u2500 task.rs(\u4efb\u52a1\u63a7\u5236\u5757 TaskControlBlock \u548c\u4efb\u52a1\u72b6\u6001 TaskStatus \u7684\u5b9a\u4e49) \u2502 \u251c\u2500\u2500 timer.rs(\u65b0\u589e\uff1a\u8ba1\u65f6\u5668\u76f8\u5173) \u2502 \u2514\u2500\u2500 trap \u2502 \u251c\u2500\u2500 context.rs \u2502 \u251c\u2500\u2500 mod.rs(\u4fee\u6539\uff1a\u65f6\u949f\u4e2d\u65ad\u76f8\u5e94\u5904\u7406) \u2502 \u2514\u2500\u2500 trap.S \u251c\u2500\u2500 README.md \u251c\u2500\u2500 rust-toolchain \u251c\u2500\u2500 tools \u2502 \u251c\u2500\u2500 kflash.py \u2502 \u251c\u2500\u2500 LICENSE \u2502 \u251c\u2500\u2500 package.json \u2502 \u251c\u2500\u2500 README.rst \u2502 \u2514\u2500\u2500 setup.py \u2514\u2500\u2500 user \u251c\u2500\u2500 build.py(\u65b0\u589e\uff1a\u4f7f\u7528 build.py \u6784\u5efa\u5e94\u7528\u4f7f\u5f97\u5b83\u4eec\u5360\u7528\u7684\u7269\u7406\u5730\u5740\u533a\u95f4\u4e0d\u76f8\u4ea4) \u251c\u2500\u2500 Cargo.toml \u251c\u2500\u2500 Makefile(\u4fee\u6539\uff1a\u4f7f\u7528 build.py \u6784\u5efa\u5e94\u7528) \u2514\u2500\u2500 src \u251c\u2500\u2500 bin(\u4fee\u6539\uff1a\u6362\u6210\u7b2c\u4e09\u7ae0\u6d4b\u4f8b) \u2502 \u251c\u2500\u2500 00power_3.rs \u2502 \u251c\u2500\u2500 01power_5.rs \u2502 \u251c\u2500\u2500 02power_7.rs \u2502 \u2514\u2500\u2500 03sleep.rs \u251c\u2500\u2500 console.rs \u251c\u2500\u2500 lang_items.rs \u251c\u2500\u2500 lib.rs \u251c\u2500\u2500 linker.ld \u2514\u2500\u2500 syscall.rs","title":"\u7b2c\u4e09\u7ae0\u4ee3\u7801\u6811"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/#_3","text":"\u672c\u8282\u5b9e\u73b0\u4e00\u4e2a\u652f\u6301 \u5bf9\u4e2d\u65ad\u7684\u5904\u7406\u548c\u5bf9\u5e94\u7528\u7a0b\u5e8f\u7684\u62a2\u5360\uff0c\u8bbe\u8ba1\u5b9e\u73b0\u66f4\u52a0\u516c\u5e73\u548c\u9ad8\u6548\u4ea4\u4e92\u7684\u62a2\u5360\u5f0f\u64cd\u4f5c\u7cfb\u7edf \u5f53\u5916\u8bbe\u60f3\u8981\u89e6\u53d1\u4e2d\u65ad\u7684\u65f6\u5019\u5219\u8f93\u5165\u4e00\u4e2a\u9ad8\u7535\u5e73\u6216\u6b63\u8fb9\u6cbf\uff0c\u5904\u7406\u5668\u4f1a\u5728\u6bcf\u6267\u884c\u5b8c\u4e00\u6761\u6307\u4ee4\u4e4b\u540e\u68c0\u67e5\u4e00\u4e0b\u8fd9\u6839\u7ebf\uff0c\u770b\u60c5\u51b5\u51b3\u5b9a\u662f\u7ee7\u7eed\u6267\u884c\u63a5\u4e0b\u6765\u7684\u6307\u4ee4\u8fd8\u662f\u8fdb\u5165\u4e2d\u65ad\u5904\u7406\u6d41\u7a0b \u672c\u7ae0\u7684\u64cd\u4f5c\u7cfb\u7edf\u652f\u6301\u628a\u591a\u4e2a\u5e94\u7528\u7684\u4ee3\u7801\u548c\u6570\u636e\u653e\u7f6e\u5230\u5185\u5b58\u4e2d\uff1b\u5e76\u80fd\u591f\u6267\u884c\u6bcf\u4e2a\u5e94\u7528\uff1b\u5728\u5e94\u7528\u7a0b\u5e8f\u53d1\u51fa sys_yeild \u7cfb\u7edf\u8c03\u7528\u65f6\uff0c\u534f\u4f5c\u5f0f\u5730\u5207\u6362\u5e94\u7528\uff1b\u5e76\u80fd\u901a\u8fc7\u65f6\u949f\u4e2d\u65ad\u6765\u5b9e\u73b0\u62a2\u5360\u5f0f\u8c03\u5ea6\u5e76\u5f3a\u884c\u5207\u6362\u5e94\u7528\uff0c\u4ece\u800c\u63d0\u9ad8\u4e86\u5e94\u7528\u6267\u884c\u7684\u7075\u6d3b\u6027\u3001\u516c\u5e73\u6027\u548c\u4ea4\u4e92\u6548\u7387\u3002","title":"\u672c\u8282\u7684\u4efb\u52a1"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/#_4","text":"","title":"\u672c\u8282\u6587\u4ef6\u89e3\u6790"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/#bootloader","text":"","title":"\u5728bootloader \u6587\u4ef6\u5939\u4e0b"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/#rustsbi-qemubin","text":"","title":"rustsbi-qemu.bin"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/#os","text":"","title":"\u5728 os \u6587\u4ef6\u5939\u4e0b"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/#oscargoconfig","text":"[build] target = \"riscv64gc-unknown-none-elf\" [target.riscv64gc-unknown-none-elf] rustflags = [ \"-Clink-arg=-Tsrc/linker.ld\", \"-Cforce-frame-pointers=yes\" ]","title":"os/.cargo/config"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/#osbuildrs","text":"use std::io::{Result, Write}; use std::fs::{File, read_dir}; fn main() { println!(\"cargo:rerun-if-changed=../user/src/\"); println!(\"cargo:rerun-if-changed={}\", TARGET_PATH); insert_app_data().unwrap(); } static TARGET_PATH: &str = \"../user/target/riscv64gc-unknown-none-elf/release/\"; fn insert_app_data() -> Result<()> { let mut f = File::create(\"src/link_app.S\").unwrap(); let mut apps: Vec<_> = read_dir(\"../user/src/bin\") .unwrap() .into_iter() .map(|dir_entry| { let mut name_with_ext = dir_entry.unwrap().file_name().into_string().unwrap(); name_with_ext.drain(name_with_ext.find('.').unwrap()..name_with_ext.len()); name_with_ext }) .collect(); apps.sort(); writeln!(f, r#\" .align 3 .section .data .global _num_app _num_app: .quad {}\"#, apps.len())?; for i in 0..apps.len() { writeln!(f, r#\" .quad app_{}_start\"#, i)?; } writeln!(f, r#\" .quad app_{}_end\"#, apps.len() - 1)?; for (idx, app) in apps.iter().enumerate() { println!(\"app_{}: {}\", idx, app); writeln!(f, r#\" .section .data .global app_{0}_start .global app_{0}_end app_{0}_start: .incbin \"{2}{1}.bin\" app_{0}_end:\"#, idx, app, TARGET_PATH)?; } Ok(()) }","title":"os/build.rs"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/#oscargotoml","text":"[package] name = \"os\" version = \"0.1.0\" edition = \"2021\" # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html [dependencies] riscv = {git = \"https://github.com/rcore-os/riscv\", features = [\"inline-asm\"]} lazy_static = {version = \"1.4.0\", features = [\"spin_no_std\"]} [features] board_qemu = [] board_k210 = []","title":"os/Cargo.toml"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/#ossrcconfigrs","text":"pub const USER_STACK_SIZE: usize = 4096 * 2; pub const KERNEL_STACK_SIZE: usize = 4096 * 2; pub const MAX_APP_NUM: usize = 4; pub const APP_BASE_ADDRESS: usize = 0x80400000; pub const APP_SIZE_LIMIT: usize = 0x20000; #[cfg(feature = \"board_k210\")] pub const CLOCK_FREQ: usize = 403000000 / 62; #[cfg(feature = \"board_qemu\")] pub const CLOCK_FREQ: usize = 12500000;","title":"os/src/config.rs"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/#ossrcconsolers","text":"use core::fmt::{self, Write}; use crate::sbi::console_putchar; struct Stdout; impl Write for Stdout { fn write_str(&mut self, s: &str) -> fmt::Result { for c in s.chars() { console_putchar(c as usize); } Ok(()) } } pub fn print(args: fmt::Arguments) { Stdout.write_fmt(args).unwrap(); } #[macro_export] macro_rules! print { ($fmt: literal $(, $($arg: tt)+)?) => { $crate::console::print(format_args!($fmt $(, $($arg)+)?)); } } #[macro_export] macro_rules! println { ($fmt: literal $(, $($arg: tt)+)?) => { $crate::console::print(format_args!(concat!($fmt, \"\\n\") $(, $($arg)+)?)); } }","title":"os/src/console.rs"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/#ossrcentryasm","text":".section .text.entry .globl _start _start: la sp, boot_stack_top call rust_main .section .bss.stack .globl boot_stack boot_stack: .space 4096 * 16 .globl boot_stack_top boot_stack_top:","title":"os/src/entry.asm"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/#ossrclang_itemsrs","text":"use core::panic::PanicInfo; use crate::sbi::shutdown; #[panic_handler] fn panic(info: &PanicInfo) -> ! { if let Some(location) = info.location() { println!(\"[kernel] Panicked at {}:{} {}\", location.file(), location.line(), info.message().unwrap()); } else { println!(\"[kernel] Panicked: {}\", info.message().unwrap()); } shutdown() }","title":"os/src/lang_items.rs"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/#ossrclink_apps","text":".align 3 .section .data .global _num_app _num_app: .quad 3 .quad app_0_start .quad app_1_start .quad app_2_start .quad app_2_end .section .data .global app_0_start .global app_0_end app_0_start: .incbin \"../user/target/riscv64gc-unknown-none-elf/release/00write_a.bin\" app_0_end: .section .data .global app_1_start .global app_1_end app_1_start: .incbin \"../user/target/riscv64gc-unknown-none-elf/release/01write_b.bin\" app_1_end: .section .data .global app_2_start .global app_2_end app_2_start: .incbin \"../user/target/riscv64gc-unknown-none-elf/release/02write_c.bin\" app_2_end:","title":"os/src/link_app.S"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/#ossrclinker-qemuld","text":"OUTPUT_ARCH(riscv) ENTRY(_start) BASE_ADDRESS = 0x80200000; SECTIONS { . = BASE_ADDRESS; skernel = .; stext = .; .text : { *(.text.entry) *(.text .text.*) } . = ALIGN(4K); etext = .; srodata = .; .rodata : { *(.rodata .rodata.*) *(.srodata .srodata.*) } . = ALIGN(4K); erodata = .; sdata = .; .data : { *(.data .data.*) *(.sdata .sdata.*) } . = ALIGN(4K); edata = .; .bss : { *(.bss.stack) sbss = .; *(.bss .bss.*) *(.sbss .sbss.*) } . = ALIGN(4K); ebss = .; ekernel = .; /DISCARD/ : { *(.eh_frame) } }","title":"os/src/linker-qemu.ld"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/#ossrcsbirs","text":"#![allow(unused)] const SBI_SET_TIMER:usize = 0; const SBI_CONSOLE_PUTCHAR:usize = 1; const SBI_CONSOLE_GETCHAR:usize = 2; const SBI_CLEAR_IPI:usize = 3; const SBI_SEND_IPI:usize = 4; const SBI_REMOTE_FENCE_I:usize = 5; const SBI_REMOTE_SFENCE_VMA:usize = 6; const SBI_REMOTE_SFENCE_VMA_ASID:usize = 7; const SBI_SHUTDOWN:usize = 8; use core::arch::asm; #[inline(always)] fn sbi_call(which:usize, arg0:usize, arg1:usize, arg2: usize) -> usize{ let mut ret; unsafe{ asm!( \"ecall\", inlateout(\"x10\") arg0 => ret, in(\"x11\") arg1, in(\"x12\") arg2, in(\"x17\") which, ); } ret } pub fn console_putchar(c:usize){ sbi_call(SBI_CONSOLE_PUTCHAR, c, 0, 0); } pub fn console_getchar() -> usize { sbi_call(SBI_CONSOLE_GETCHAR, 0, 0, 0) } pub fn shutdown() -> ! { sbi_call(SBI_SHUTDOWN, 0, 0, 0); panic!(\"It should shutdown!\"); } pub fn set_timer(timer: usize) { sbi_call(SBI_SET_TIMER, timer, 0, 0); } // sbi \u5b50\u6a21\u5757\u6709\u4e00\u4e2a set_timer \u8c03\u7528\uff0c\u662f\u4e00\u4e2a\u7531 SEE \u63d0\u4f9b\u7684\u6807\u51c6 SBI \u63a5\u53e3\u51fd\u6570\uff0c\u5b83\u53ef\u4ee5\u7528\u6765\u8bbe\u7f6e mtimecmp \u7684\u503c\u3002","title":"os/src/sbi.rs"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/#ossrctimerrs","text":"use riscv::register::time; use crate::sbi::set_timer; pub fn get_time() -> usize{ time::read() } // timer \u5b50\u6a21\u5757\u7684 get_time \u51fd\u6570\u53ef\u4ee5\u53d6\u5f97\u5f53\u524d mtime \u8ba1\u6570\u5668\u7684\u503c\uff1b use crate::config::CLOCK_FREQ; const TICKS_PER_SEC: usize = 100; pub fn set_next_trigger() { set_timer(get_time() + CLOCK_FREQ / TICKS_PER_SEC); } // timer \u5b50\u6a21\u5757\u7684 set_next_trigger \u51fd\u6570\u5bf9 set_timer \u8fdb\u884c\u4e86\u5c01\u88c5\uff0c // \u5b83\u9996\u5148\u8bfb\u53d6\u5f53\u524d mtime \u7684\u503c\uff0c\u7136\u540e\u8ba1\u7b97\u51fa 10ms \u4e4b\u5185\u8ba1\u6570\u5668\u7684\u589e\u91cf\uff0c // \u518d\u5c06 mtimecmp \u8bbe\u7f6e\u4e3a\u4e8c\u8005\u7684\u548c\u3002\u8fd9\u6837\uff0c10ms \u4e4b\u540e\u4e00\u4e2a S \u7279\u6743\u7ea7\u65f6\u949f\u4e2d\u65ad\u5c31\u4f1a\u88ab\u89e6\u53d1\u3002 // \u81f3\u4e8e\u589e\u91cf\u7684\u8ba1\u7b97\u65b9\u5f0f\uff0c\u5e38\u6570 CLOCK_FREQ \u662f\u4e00\u4e2a\u9884\u5148\u83b7\u53d6\u5230\u7684\u5404\u5e73\u53f0\u4e0d\u540c\u7684\u65f6\u949f\u9891\u7387\uff0c // \u5355\u4f4d\u4e3a\u8d6b\u5179\uff0c\u4e5f\u5c31\u662f\u4e00\u79d2\u949f\u4e4b\u5185\u8ba1\u6570\u5668\u7684\u589e\u91cf\u3002\u5b83\u53ef\u4ee5\u5728 config \u5b50\u6a21\u5757\u4e2d\u627e\u5230\u3002 // CLOCK_FREQ \u9664\u4ee5\u5e38\u6570 TICKS_PER_SEC \u5373\u662f\u4e0b\u4e00\u6b21\u65f6\u949f\u4e2d\u65ad\u7684\u8ba1\u6570\u5668\u589e\u91cf\u503c\u3002 const MICRO_PRE_SEC: usize = 1_000_000; pub fn get_time_ms() -> usize { time::read() / (CLOCK_FREQ / MICRO_PRE_SEC) } // timer \u5b50\u6a21\u5757\u7684 get_time_us \u4ee5\u5fae\u79d2\u4e3a\u5355\u4f4d\u8fd4\u56de\u5f53\u524d\u8ba1\u6570\u5668\u7684\u503c\uff0c\u8fd9\u8ba9\u6211\u4eec\u7ec8\u4e8e\u80fd\u5bf9\u65f6\u95f4\u6709\u4e00\u4e2a\u5177\u4f53\u6982\u5ff5\u4e86","title":"os/src/timer.rs"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/#ossrcsyncmodrs","text":"mod up; pub use up::UPSafeCell;","title":"os/src/sync/mod.rs"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/#ossrcsyncuprs","text":"use core::cell::{RefCell, RefMut}; /// Wrap a static data structure inside it so that we are /// able to access it without any `unsafe`. /// /// We should only use it in uniprocessor. /// /// In order to get mutable reference of inner data, call /// `exclusive_access`. pub struct UPSafeCell<T> { /// inner data inner: RefCell<T>, } unsafe impl<T> Sync for UPSafeCell<T> {} impl<T> UPSafeCell<T> { /// User is responsible to guarantee that inner struct is only used in /// uniprocessor. pub unsafe fn new(value: T) -> Self { Self { inner: RefCell::new(value) } } /// Panic if the data has been borrowed. pub fn exclusive_access(&self) -> RefMut<'_, T> { self.inner.borrow_mut() } }","title":"os/src/sync/up.rs"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/#ossrcsyscallfsrs","text":"const FD_STDOUT: usize = 1; pub fn sys_write(fd: usize, buf: *const u8, len: usize) -> isize { match fd { FD_STDOUT => { let slice = unsafe { core::slice::from_raw_parts(buf, len) }; let str = core::str::from_utf8(slice).unwrap(); print!(\"{}\", str); len as isize }, _ => { panic!(\"Unsupported fd in sys_write!\"); } } }","title":"os/src/syscall/fs.rs"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/#ossrcsyscallmodrs","text":"const SYSCALL_WRITE: usize = 64; const SYSCALL_EXIT: usize = 93; const SYSCALL_YIELD: usize = 124; const SYSCALL_GET_TIME: usize = 169; mod fs; mod process; use fs::*; use process::*; pub fn syscall(syscall_id: usize, args: [usize; 3]) -> isize{ match syscall_id { SYSCALL_WRITE => sys_write(args[0], args[1] as *const u8, args[2]), SYSCALL_EXIT => sys_exit(args[0] as i32), SYSCALL_YIELD => sys_yield(), SYSCALL_GET_TIME => sys_get_time(), _ => panic!(\"Unsupported syscall_id: {}\", syscall_id), } }","title":"os/src/syscall/mod.rs"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/#ossrcsyscallprocessrs","text":"use crate::task::{ suspend_current_and_run_next, exit_current_and_run_next, }; pub fn sys_exit(exit_code: i32) -> ! { println!(\"[kernel] Application exited with code {}\", exit_code); // \u5728\u8c03\u7528\u5b83\u4e4b\u524d\u6211\u4eec\u6253\u5370\u5e94\u7528\u7684\u9000\u51fa\u4fe1\u606f\u5e76\u8f93\u51fa\u5b83\u7684\u9000\u51fa\u7801 exit_current_and_run_next(); // \u57fa\u4e8e task \u5b50\u6a21\u5757\u63d0\u4f9b\u7684 exit_current_and_run_next \u63a5\u53e3 panic!(\"Unreachable in sys_exit!\"); } pub fn sys_yield() -> isize { suspend_current_and_run_next(); // task \u5b50\u6a21\u5757\u63d0\u4f9b\u7684 suspend_current_and_run_next \u63a5\u53e3 0 } // sys_yield \u8868\u793a\u5e94\u7528\u81ea\u5df1\u6682\u65f6\u653e\u5f03\u5bf9CPU\u7684\u5f53\u524d\u4f7f\u7528\u6743\uff0c\u8fdb\u5165 Ready \u72b6\u6001 use crate::timer::get_time_ms; pub fn sys_get_time() -> isize { get_time_ms() as isize }","title":"os/src/syscall/process.rs"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/#ossrctaskcontextrs","text":"#[derive(Copy, Clone)] #[repr(C)] pub struct TaskContext { ra: usize, // \u8bb0\u5f55__switch \u51fd\u6570\u8fd4\u56de\u4e4b\u540e\u5e94\u8be5\u8df3\u8f6c\u5230\u54ea\u91cc\u7ee7\u7eed\u6267\u884c // \u4ece\u800c\u5728\u4efb\u52a1\u5207\u6362\u5b8c\u6210\u5e76 ret \u4e4b\u540e\u80fd\u5230\u6b63\u786e\u7684\u4f4d\u7f6e sp: usize, s: [usize; 12], // \u5bf9\u4e8e\u4e00\u822c\u7684\u51fd\u6570\u800c\u8a00\uff0cRust/C \u7f16\u8bd1\u5668\u4f1a\u5728\u51fd\u6570\u7684\u8d77\u59cb\u4f4d\u7f6e\u81ea\u52a8\u751f\u6210\u4ee3\u7801\u6765\u4fdd\u5b58 s0~s11 \u8fd9\u4e9b\u88ab\u8c03\u7528\u8005\u4fdd\u5b58\u7684\u5bc4\u5b58\u5668\u3002 // \u4f46 __switch \u662f\u4e00\u4e2a\u7528\u6c47\u7f16\u4ee3\u7801\u5199\u7684\u7279\u6b8a\u51fd\u6570\uff0c\u5b83\u4e0d\u4f1a\u88ab Rust/C \u7f16\u8bd1\u5668\u5904\u7406\uff0c // \u6240\u4ee5\u6211\u4eec\u9700\u8981\u5728 __switch \u4e2d\u624b\u52a8\u7f16\u5199\u4fdd\u5b58 s0~s11 \u7684\u6c47\u7f16\u4ee3\u7801 // \u4e0d\u7528\u4fdd\u5b58\u5176\u5b83\u5bc4\u5b58\u5668\u662f\u56e0\u4e3a\uff1a\u5176\u5b83\u5bc4\u5b58\u5668\u4e2d\uff0c // \u5c5e\u4e8e\u8c03\u7528\u8005\u4fdd\u5b58\u7684\u5bc4\u5b58\u5668\u662f\u7531\u7f16\u8bd1\u5668\u5728\u9ad8\u7ea7\u8bed\u8a00\u7f16\u5199\u7684\u8c03\u7528\u51fd\u6570\u4e2d\u81ea\u52a8\u751f\u6210\u7684\u4ee3\u7801\u6765\u5b8c\u6210\u4fdd\u5b58\u7684\uff1b // \u8fd8\u6709\u4e00\u4e9b\u5bc4\u5b58\u5668\u5c5e\u4e8e\u4e34\u65f6\u5bc4\u5b58\u5668\uff0c\u4e0d\u9700\u8981\u4fdd\u5b58\u548c\u6062\u590d\u3002 } impl TaskContext { pub fn zero_init() -> Self { Self { ra: 0, sp: 0, s: [0; 12], } } pub fn goto_restore(kstack_ptr: usize) -> Self { // \u6784\u9020\u6bcf\u4e2a\u4efb\u52a1\u4fdd\u5b58\u5728\u4efb\u52a1\u63a7\u5236\u5757\u4e2d\u7684\u4efb\u52a1\u4e0a\u4e0b\u6587 extern \"C\" { fn __restore(); } Self { ra: __restore as usize, // \u5b83\u8bbe\u7f6e\u4efb\u52a1\u4e0a\u4e0b\u6587\u4e2d\u7684\u5185\u6838\u6808\u6307\u9488\u5c06\u4efb\u52a1\u4e0a\u4e0b\u6587\u7684 ra \u5bc4\u5b58\u5668\u8bbe\u7f6e\u4e3a __restore \u7684\u5165\u53e3\u5730\u5740 // \u8fd9\u6837\uff0c\u5728 __switch \u4ece\u5b83\u4e0a\u9762\u6062\u590d\u5e76\u8fd4\u56de\u4e4b\u540e\u5c31\u4f1a\u76f4\u63a5\u8df3\u8f6c\u5230 __restore \uff0c // \u6b64\u65f6\u6808\u9876\u662f\u4e00\u4e2a\u6211\u4eec\u6784\u9020\u51fa\u6765\u7b2c\u4e00\u6b21\u8fdb\u5165\u7528\u6237\u6001\u6267\u884c\u7684 Trap \u4e0a\u4e0b\u6587 sp: kstack_ptr, s: [0; 12], } } }","title":"os/src/task/context.rs"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/#ossrctaskswitchrs","text":"use super::TaskContext; use core::arch::global_asm; global_asm!(include_str!(\"switch.S\")); extern \"C\" { pub fn __switch( current_task_cx_ptr: *mut TaskContext, next_task_cx_ptr: *const TaskContext ); // \u6211\u4eec\u4f1a\u5c06\u8fd9\u6bb5\u6c47\u7f16\u4ee3\u7801\u4e2d\u7684\u5168\u5c40\u7b26\u53f7 __switch \u89e3\u91ca\u4e3a\u4e00\u4e2a Rust \u51fd\u6570 // \u6211\u4eec\u4f1a\u8c03\u7528\u8be5\u51fd\u6570\u6765\u5b8c\u6210\u5207\u6362\u529f\u80fd\u800c\u4e0d\u662f\u76f4\u63a5\u8df3\u8f6c\u5230\u7b26\u53f7 __switch \u7684\u5730\u5740\u3002 // \u56e0\u6b64\u5728\u8c03\u7528\u524d\u540e Rust \u7f16\u8bd1\u5668\u4f1a\u81ea\u52a8\u5e2e\u52a9\u6211\u4eec\u63d2\u5165\u4fdd\u5b58/\u6062\u590d\u8c03\u7528\u8005\u4fdd\u5b58\u5bc4\u5b58\u5668\u7684\u6c47\u7f16\u4ee3\u7801 }","title":"os/src/task/switch.rs"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/#ossrctaskswitchs","text":".altmacro .macro SAVE_SN n sd s\\n, (\\n+2)*8(a0) .endm .macro LOAD_SN n ld s\\n, (\\n+2)*8(a1) .endm .section .text .globl __switch __switch: # __switch( # current_task_cx_ptr: *mut TaskContext, # next_task_cx_ptr: *const TaskContext # ) # \u51fd\u6570\u539f\u578b\u4e2d\u7684\u4e24\u4e2a\u53c2\u6570\u5206\u522b\u662f\u5f53\u524d A \u4efb\u52a1\u4e0a\u4e0b\u6587\u6307\u9488 next_task_cx_ptr # \u548c\u5373\u5c06\u88ab\u5207\u6362\u5230\u7684 B \u4efb\u52a1\u4e0a\u4e0b\u6587\u6307\u9488 next_task_cx_ptr \uff0c # \u4ece RISC-V \u8c03\u7528\u89c4\u8303 \u53ef\u4ee5\u77e5\u9053\u5b83\u4eec\u5206\u522b\u901a\u8fc7\u5bc4\u5b58\u5668 a0/a1 \u4f20\u5165 # save kernel stack of current task # \u4fdd\u5b58\u5f53\u524d\u4efb\u52a1\u7684\u6808\u6bb5 sd sp, 8(a0) # save ra & s0~s11 of current execution # \u4fdd\u5b58\u5f53\u524d \u4efb\u52a1\u4e0a\u4e0b\u6587 sd ra, 0(a0) .set n, 0 .rept 12 SAVE_SN %n .set n, n + 1 .endr # restore ra & s0~s11 of next execution # \u6062\u590d\u4e0b\u4e00\u4e2a\u4efb\u52a1\u7684\u4e0a\u4e0b\u6587 ld ra, 0(a1) .set n, 0 .rept 12 LOAD_SN %n .set n, n + 1 .endr # restore kernel stack of next task # \u6062\u590d\u4e0a\u4e00\u4e2a\u4efb\u52a1\u7684 \u6808\u6bb5 ld sp, 8(a1) ret","title":"os/src/task/switch.S"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/#ossrctaskrs","text":"use super::TaskContext; #[derive(Copy, Clone)] // \u901a\u8fc7 #[derive(...)] \u53ef\u4ee5\u8ba9\u7f16\u8bd1\u5668\u4e3a\u4f60\u7684\u7c7b\u578b\u63d0\u4f9b\u4e00\u4e9b Trait \u7684\u9ed8\u8ba4\u5b9e\u73b0\u3002 // \u5b9e\u73b0\u4e86 Clone Trait \u4e4b\u540e\u5c31\u53ef\u4ee5\u8c03\u7528 clone \u51fd\u6570\u5b8c\u6210\u62f7\u8d1d\uff1b // \u5b9e\u73b0\u4e86 PartialEq Trait \u4e4b\u540e\u5c31\u53ef\u4ee5\u4f7f\u7528 == \u8fd0\u7b97\u7b26\u6bd4\u8f83\u8be5\u7c7b\u578b\u7684\u4e24\u4e2a\u5b9e\u4f8b\uff0c // \u4ece\u903b\u8f91\u4e0a\u8bf4\u53ea\u6709 \u4e24\u4e2a\u76f8\u7b49\u7684\u5e94\u7528\u6267\u884c\u72b6\u6001\u624d\u4f1a\u88ab\u5224\u4e3a\u76f8\u7b49\uff0c\u800c\u4e8b\u5b9e\u4e0a\u4e5f\u786e\u5b9e\u5982\u6b64\u3002 // Copy \u662f\u4e00\u4e2a\u6807\u8bb0 Trait\uff0c\u51b3\u5b9a\u8be5\u7c7b\u578b\u5728\u6309\u503c\u4f20\u53c2/\u8d4b\u503c\u7684\u65f6\u5019\u91c7\u7528\u79fb\u52a8\u8bed\u4e49\u8fd8\u662f\u590d\u5236\u8bed\u4e49\u3002 pub struct TaskControlBlock { // \u4efb\u52a1\u63a7\u5236\u5757 pub task_status: TaskStatus, // \u4efb\u52a1 \u8fd0\u884c\u72b6\u6001 pub task_cx: TaskContext, // \u4efb\u52a1\u4e0a\u4e0b\u6587 } #[derive(Copy, Clone, PartialEq)] pub enum TaskStatus { UnInit, // \u672a\u521d\u59cb\u5316 Ready, // \u51c6\u5907\u8fd0\u884c Running, // \u6b63\u5728\u8fd0\u884c Exited, // \u5df2\u9000\u51fa }","title":"os/src/task.rs"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/#ossrctaskmodrs","text":"mod context; mod switch; mod task; use crate::config::MAX_APP_NUM; use crate::loader::{get_num_app, init_app_cx}; use lazy_static::*; use switch::__switch; use task::{TaskControlBlock, TaskStatus}; use crate::sync::UPSafeCell; pub use context::TaskContext; // \u5168\u5c40\u7684\u4efb\u52a1\u7ba1\u7406\u5668 pub struct TaskManager { num_app: usize, // \u4efb\u52a1\u7ba1\u7406\u5668\u7ba1\u7406\u7684\u5e94\u7528\u7684\u6570\u76ee // \u5b83\u5728 TaskManager \u521d\u59cb\u5316\u4e4b\u540e\u5c31\u4e0d\u4f1a\u53d1\u751f\u53d8\u5316 inner: UPSafeCell<TaskManagerInner>, // \u800c\u5305\u88f9\u5728 TaskManagerInner \u5185\u7684\u4efb\u52a1\u63a7\u5236\u5757\u6570\u7ec4 tasks // \u4ee5\u53ca\u8868\u793a CPU \u6b63\u5728\u6267\u884c\u7684\u5e94\u7528\u7f16\u53f7 current_task \u4f1a\u5728\u6267\u884c\u5e94\u7528\u7684\u8fc7\u7a0b\u4e2d\u53d1\u751f\u53d8\u5316\uff1a // \u6bcf\u4e2a\u5e94\u7528\u7684\u8fd0\u884c\u72b6\u6001\u90fd\u4f1a\u53d1\u751f\u53d8\u5316\uff0c\u800c CPU \u6267\u884c\u7684\u5e94\u7528\u4e5f\u5728\u4e0d\u65ad\u5207\u6362\u3002 // \u56e0\u6b64\u6211\u4eec\u9700\u8981\u5c06 TaskManagerInner \u5305\u88f9\u5728 UPSafeCell \u5185 // \u4ee5\u83b7\u53d6\u5176\u5185\u90e8\u53ef\u53d8\u6027\u4ee5\u53ca\u5355\u6838\u4e0a\u5b89\u5168\u7684\u8fd0\u884c\u65f6\u501f\u7528\u68c0\u67e5\u80fd\u529b } struct TaskManagerInner { tasks: [TaskControlBlock; MAX_APP_NUM], current_task: usize, // \u53ea\u80fd\u901a\u8fc7\u5b83\u77e5\u9053 CPU\u6b63\u5728\u6267\u884c\u54ea\u4e2a\u5e94\u7528\uff0c\u800c\u4e0d\u80fd\u63a8\u6d4b\u51fa\u5176\u4ed6\u5e94\u7528\u7684\u4efb\u4f55\u4fe1\u606f } lazy_static! { pub static ref TASK_MANAGER: TaskManager = { let num_app = get_num_app(); // \u8c03\u7528 loader \u5b50\u6a21\u5757\u63d0\u4f9b\u7684 get_num_app \u63a5\u53e3\u83b7\u53d6\u94fe\u63a5\u5230\u5185\u6838\u7684\u5e94\u7528\u603b\u6570 let mut tasks = [ TaskControlBlock { task_cx: TaskContext::zero_init(), task_status: TaskStatus::UnInit }; MAX_APP_NUM ]; // \u521b\u5efa\u4e00\u4e2a\u521d\u59cb\u5316\u7684 tasks \u6570\u7ec4\uff0c\u5176\u4e2d\u7684\u6bcf\u4e2a\u4efb\u52a1\u63a7\u5236\u5757\u7684\u8fd0\u884c\u72b6\u6001\u90fd\u662f UnInit \uff1a\u8868\u793a\u5c1a\u672a\u521d\u59cb\u5316 for i in 0..num_app { tasks[i].task_cx = TaskContext::goto_restore(init_app_cx(i)); // \u5bf9\u4e8e\u6bcf\u4e2a\u4efb\u52a1\uff0c\u6211\u4eec\u5148\u8c03\u7528 init_app_cx \u6784\u9020\u8be5\u4efb\u52a1\u7684 Trap \u4e0a\u4e0b\u6587 // \uff08\u5305\u62ec\u5e94\u7528\u5165\u53e3\u5730\u5740\u548c\u7528\u6237\u6808\u6307\u9488\uff09\u5e76\u5c06\u5176\u538b\u5165\u5230\u5185\u6838\u6808\u9876 // \u63a5\u7740\u8c03\u7528 TaskContext::goto_restore \u6765\u6784\u9020\u6bcf\u4e2a\u4efb\u52a1\u4fdd\u5b58\u5728\u4efb\u52a1\u63a7\u5236\u5757\u4e2d\u7684\u4efb\u52a1\u4e0a\u4e0b\u6587\u3002 // \u5b83\u8bbe\u7f6e\u4efb\u52a1\u4e0a\u4e0b\u6587\u4e2d\u7684\u5185\u6838\u6808\u6307\u9488\u5c06\u4efb\u52a1\u4e0a\u4e0b\u6587\u7684 ra \u5bc4\u5b58\u5668\u8bbe\u7f6e\u4e3a __restore \u7684\u5165\u53e3\u5730\u5740 // \u8fd9\u6837\uff0c\u5728 __switch \u4ece\u5b83\u4e0a\u9762\u6062\u590d\u5e76\u8fd4\u56de\u4e4b\u540e\u5c31\u4f1a\u76f4\u63a5\u8df3\u8f6c\u5230 __restore \uff0c // \u6b64\u65f6\u6808\u9876\u662f\u4e00\u4e2a\u6211\u4eec\u6784\u9020\u51fa\u6765\u7b2c\u4e00\u6b21\u8fdb\u5165\u7528\u6237\u6001\u6267\u884c\u7684 Trap \u4e0a\u4e0b\u6587 tasks[i].task_status = TaskStatus::Ready; } // \u4f9d\u6b21\u5bf9\u6bcf\u4e2a\u4efb\u52a1\u63a7\u5236\u5757\u8fdb\u884c\u521d\u59cb\u5316\uff0c\u5c06\u5176\u8fd0\u884c\u72b6\u6001\u8bbe\u7f6e\u4e3a Ready \uff1a\u8868\u793a\u53ef\u4ee5\u8fd0\u884c\uff0c // \u5e76\u521d\u59cb\u5316\u5b83\u7684 \u4efb\u52a1\u4e0a\u4e0b\u6587 TaskManager { num_app, inner: unsafe { UPSafeCell::new(TaskManagerInner { tasks, current_task: 0, })}, } // \u521b\u5efa TaskManager \u5b9e\u4f8b\u5e76\u8fd4\u56de }; } //\u6ce8\u610f\u6211\u4eec\u65e0\u9700\u548c\u7b2c\u4e8c\u7ae0\u4e00\u6837\u5c06 TaskManager \u6807\u8bb0\u4e3a Sync \uff0c // \u56e0\u4e3a\u7f16\u8bd1\u5668\u53ef\u4ee5\u6839\u636e TaskManager \u5b57\u6bb5\u7684\u60c5\u51b5\u81ea\u52a8\u63a8\u5bfc\u51fa TaskManager \u662f Sync \u7684 impl TaskManager { fn run_first_task(&self) -> ! { let mut inner = self.inner.exclusive_access(); let task0 = &mut inner.tasks[0]; // \u6211\u4eec\u53d6\u51fa\u5373\u5c06\u6700\u5148\u6267\u884c\u7684\u7f16\u53f7\u4e3a 0 \u7684\u5e94\u7528\u7684\u4efb\u52a1\u4e0a\u4e0b\u6587\u6307\u9488 next_task_cx_ptr \u5e76\u5e0c\u671b\u80fd\u591f\u5207\u6362\u8fc7\u53bb\u3002\u6ce8\u610f __switch \u6709\u4e24\u4e2a\u53c2\u6570\u5206\u522b\u8868\u793a\u5f53\u524d\u5e94\u7528\u548c\u5373\u5c06\u5207\u6362\u5230\u7684\u5e94\u7528\u7684\u4efb\u52a1\u4e0a\u4e0b\u6587\u6307\u9488\uff0c\u5176\u7b2c\u4e00\u4e2a\u53c2\u6570\u5b58\u5728\u7684\u610f\u4e49\u662f\u8bb0\u5f55\u5f53\u524d\u5e94\u7528\u7684\u4efb\u52a1\u4e0a\u4e0b\u6587\u88ab\u4fdd\u5b58\u5728\u54ea\u91cc\uff0c\u4e5f\u5c31\u662f\u5f53\u524d\u5e94\u7528\u5185\u6838\u6808\u7684\u6808\u9876\uff0c\u8fd9\u6837\u4e4b\u540e\u624d\u80fd\u7ee7\u7eed\u6267\u884c\u8be5\u5e94\u7528\u3002\u4f46\u5728 run_first_task \u7684\u65f6\u5019\uff0c\u6211\u4eec\u5e76\u6ca1\u6709\u6267\u884c\u4efb\u4f55\u5e94\u7528\uff0c __switch \u524d\u534a\u90e8\u5206\u7684\u4fdd\u5b58\u4ec5\u4ec5\u662f\u5728\u542f\u52a8\u6808\u4e0a\u4fdd\u5b58\u4e86\u4e00\u4e9b\u4e4b\u540e\u4e0d\u4f1a\u7528\u5230\u7684\u6570\u636e\uff0c\u81ea\u7136\u4e5f\u65e0\u9700\u8bb0\u5f55\u542f\u52a8\u6808\u6808\u9876\u7684\u4f4d\u7f6e\u3002 // \u56e0\u6b64\uff0c\u6211\u4eec\u663e\u5f0f\u5728\u542f\u52a8\u6808\u4e0a\u5206\u914d\u4e86\u4e00\u4e2a\u540d\u4e3a _unused \u7684\u4efb\u52a1\u4e0a\u4e0b\u6587\uff0c\u5e76\u5c06\u5b83\u7684\u5730\u5740\u4f5c\u4e3a\u7b2c\u4e00\u4e2a\u53c2\u6570\u4f20\u7ed9 __switch \uff0c\u8fd9\u6837\u4fdd\u5b58\u4e00\u4e9b\u5bc4\u5b58\u5668\u4e4b\u540e\u7684\u542f\u52a8\u6808\u6808\u9876\u7684\u4f4d\u7f6e\u5c06\u4f1a\u4fdd\u5b58\u5728\u6b64\u53d8\u91cf\u4e2d\u3002\u7136\u800c\u65e0\u8bba\u662f\u6b64\u53d8\u91cf\u8fd8\u662f\u542f\u52a8\u6808\u6211\u4eec\u4e4b\u540e\u5747\u4e0d\u4f1a\u6d89\u53ca\u5230\uff0c\u4e00\u65e6\u5e94\u7528\u5f00\u59cb\u8fd0\u884c\uff0c\u6211\u4eec\u5c31\u5f00\u59cb\u5728\u5e94\u7528\u7684\u7528\u6237\u6808\u548c\u5185\u6838\u6808\u4e4b\u95f4\u5f00\u59cb\u5207\u6362\u4e86\u3002\u8fd9\u91cc\u58f0\u660e\u6b64\u53d8\u91cf\u7684\u610f\u4e49\u4ec5\u4ec5\u662f\u4e3a\u4e86\u907f\u514d\u8986\u76d6\u5230\u5176\u4ed6\u6570\u636e task0.task_status = TaskStatus::Running; let next_task_cx_ptr = &task0.task_cx as *const TaskContext; // \u5c06\u7f16\u53f7\u4e3a0 \u7684\u4efb\u52a1 \u6807\u8bb0\u4e3a\u4e0b\u4e00\u4e2a\u8981\u5207\u6362\u5230\u7684\u4efb\u52a1 drop(inner); let mut _unused = TaskContext::zero_init(); // \u521d\u59cb\u5316\u521b\u5efa\u4e00\u4e2a\u4e0d\u4f1a\u7528\u7684\u7684 \u4efb\u52a1\u4e0a\u4e0b\u6587 \u4f5c\u4e3a\u5f53\u524d\u4efb\u52a1\u4e0a\u4e0b\u6587 // \u7531\u4e8e\u4e4b\u540e\u5207\u6362\u65f6 \u627e\u4e0d\u5230\u5b83\u7684 ID\uff0c\u6240\u6709\u4e0d\u7528\u5f53\u5fc3\u5b83\u5bf9\u540e\u7eed\u7a0b\u5e8f\u8fd0\u884c\u7684\u5f71\u54cd // before this, we should drop local variables that must be dropped manually unsafe { __switch( &mut _unused as *mut TaskContext, next_task_cx_ptr, ); } panic!(\"unreachable in run_first_task!\"); } fn mark_current_suspended(&self) { let mut inner = self.inner.exclusive_access(); let current = inner.current_task; inner.tasks[current].task_status = TaskStatus::Ready; // \u5176\u4e2d\uff0c\u9996\u5148\u83b7\u5f97\u91cc\u5c42 TaskManagerInner \u7684\u53ef\u53d8\u5f15\u7528\uff0c // \u901a\u8fc7 sync/up.rs \u91cc UPSafeCell\u7ed3\u6784\u4f53\u7684\u65b9\u6cd5 exclusive_access \u83b7\u53d6 // \u7136\u540e\u6839\u636e\u5176\u4e2d\u8bb0\u5f55\u7684\u5f53\u524d\u6b63\u5728\u6267\u884c\u7684\u5e94\u7528 ID \u5bf9\u5e94\u5728\u4efb\u52a1\u63a7\u5236\u5757\u6570\u7ec4 tasks \u4e2d\u4fee\u6539\u72b6\u6001 } fn mark_current_exited(&self) { let mut inner = self.inner.exclusive_access(); let current = inner.current_task; inner.tasks[current].task_status = TaskStatus::Exited; // \u5176\u4e2d\uff0c\u9996\u5148\u83b7\u5f97\u91cc\u5c42 TaskManagerInner \u7684\u53ef\u53d8\u5f15\u7528\uff0c // \u901a\u8fc7 sync/up.rs \u91cc UPSafeCell\u7ed3\u6784\u4f53\u7684\u65b9\u6cd5 exclusive_access \u83b7\u53d6 // \u7136\u540e\u6839\u636e\u5176\u4e2d\u8bb0\u5f55\u7684\u5f53\u524d\u6b63\u5728\u6267\u884c\u7684\u5e94\u7528 ID \u5bf9\u5e94\u5728\u4efb\u52a1\u63a7\u5236\u5757\u6570\u7ec4 tasks \u4e2d\u4fee\u6539\u72b6\u6001 } fn find_next_task(&self) -> Option<usize> { let inner = self.inner.exclusive_access(); let current = inner.current_task; (current + 1..current + self.num_app + 1) .map(|id| id % self.num_app) .find(|id| { inner.tasks[*id].task_status == TaskStatus::Ready }) // TaskManagerInner \u7684 tasks \u662f\u4e00\u4e2a\u56fa\u5b9a\u7684\u4efb\u52a1\u63a7\u5236\u5757\u7ec4\u6210\u7684\u8868\uff0c\u957f\u5ea6\u4e3a num_app \uff0c // \u53ef\u4ee5\u7528\u4e0b\u6807 0~num_app-1 \u6765\u8bbf\u95ee\u5f97\u5230\u6bcf\u4e2a\u5e94\u7528\u7684\u63a7\u5236\u72b6\u6001\u3002 // \u6211\u4eec\u7684\u4efb\u52a1\u5c31\u662f\u627e\u5230 current_task \u540e\u9762\u7b2c\u4e00\u4e2a\u72b6\u6001\u4e3a Ready \u7684\u5e94\u7528\u3002 // \u56e0\u6b64\u4ece current_task + 1 \u5f00\u59cb\u5faa\u73af\u4e00\u5708\uff0c\u9700\u8981\u9996\u5148\u5bf9 num_app \u53d6\u6a21\u5f97\u5230\u5b9e\u9645\u7684\u4e0b\u6807\uff0c // \u7136\u540e\u68c0\u67e5\u5b83\u7684\u8fd0\u884c\u72b6\u6001 } fn run_next_task(&self) { if let Some(next) = self.find_next_task() { // \u5b83\u4f1a\u8c03\u7528 find_next_task \u65b9\u6cd5\u5c1d\u8bd5\u5bfb\u627e\u4e00\u4e2a\u8fd0\u884c\u72b6\u6001\u4e3a Ready \u7684\u5e94\u7528\u5e76\u8fd4\u56de\u5176 ID let mut inner = self.inner.exclusive_access(); // \u83b7\u53d6\u5168\u5c40\u4efb\u52a1\u7ba1\u7406\u5668\u7684 struct TaskManagerInner { // tasks: [TaskControlBlock; MAX_APP_NUM], // current_task: usize, // } let current = inner.current_task; // \u83b7\u53d6\u5f53\u524d\u4efb\u52a1\u7684 ID inner.tasks[next].task_status = TaskStatus::Running; // \u5c06\u4e0b\u4e00\u4e2a\u4efb\u52a1\u7684\u72b6\u6001\u6807\u6ce8\u4e3a Running inner.current_task = next; // \u5c06\u5f53\u524d\u4efb\u52a1 \u6807\u6ce8\u4e3a\u4e0b\u4e00\u4e2a\u4efb\u52a1\u7684 ID let current_task_cx_ptr = &mut inner.tasks[current].task_cx as *mut TaskContext; // \u83b7\u53d6\u5b58\u653e\u5f53\u524d\u4efb\u52a1\u4e0a\u4e0b\u6587\u7684 \u5730\u5740 let next_task_cx_ptr = &inner.tasks[next].task_cx as *const TaskContext; // \u83b7\u53d6\u5b58\u653e\u4e0b\u4e00\u4e2a\u4efb\u52a1\u4e0a\u4e0b\u6587\u7684 \u5730\u5740 drop(inner); // \u5728\u5b9e\u9645\u5207\u6362\u4e4b\u524d\u6211\u4eec\u9700\u8981\u624b\u52a8 drop \u6389\u6211\u4eec\u83b7\u53d6\u5230\u7684 TaskManagerInner // \u7684\u6765\u81ea UPSafeCell \u7684\u501f\u7528\u6807\u8bb0\u3002 // \u56e0\u4e3a\u4e00\u822c\u60c5\u51b5\u4e0b\u5b83\u662f\u5728\u51fd\u6570\u9000\u51fa\u4e4b\u540e\u624d\u4f1a\u88ab\u81ea\u52a8\u91ca\u653e\uff0c\u4ece\u800c TASK_MANAGER // \u7684 inner \u5b57\u6bb5\u5f97\u4ee5\u56de\u5f52\u5230\u672a\u88ab\u501f\u7528\u7684\u72b6\u6001\uff0c // \u4e4b\u540e\u53ef\u4ee5\u518d\u501f\u7528\u3002\u5982\u679c\u4e0d\u624b\u52a8 drop \u7684\u8bdd\uff0c\u7f16\u8bd1\u5668\u4f1a\u5728 __switch \u8fd4\u56de\u65f6\uff0c // \u4e5f\u5c31\u662f\u5f53\u524d\u5e94\u7528\u88ab\u5207\u6362\u56de\u6765\u7684\u65f6\u5019\u624d drop\uff0c\u8fd9\u671f\u95f4\u6211\u4eec\u90fd\u4e0d\u80fd\u4fee\u6539 TaskManagerInner \uff0c // \u751a\u81f3\u4e0d\u80fd\u8bfb\uff08\u56e0\u4e3a\u4e4b\u524d\u662f\u53ef\u53d8\u501f\u7528\uff09\uff0c\u4f1a\u5bfc\u81f4\u5185\u6838 panic \u62a5\u9519\u9000\u51fa\u3002 // \u6b63\u56e0\u5982\u6b64\uff0c\u6211\u4eec\u9700\u8981\u5728 __switch \u524d\u63d0\u65e9\u624b\u52a8 drop \u6389 inner // before this, we should drop local variables that must be dropped manually unsafe { __switch( current_task_cx_ptr, next_task_cx_ptr, ); } // \u5982\u679c\u80fd\u591f\u627e\u5230\u4e0b\u4e00\u4e2a\u53ef\u8fd0\u884c\u7684\u5e94\u7528\u7684\u8bdd\uff0c // \u6211\u4eec\u5c31\u53ef\u4ee5\u5206\u522b\u62ff\u5230\u5f53\u524d\u5e94\u7528 current_task_cx_ptr // \u548c\u5373\u5c06\u88ab\u5207\u6362\u5230\u7684\u5e94\u7528 next_task_cx_ptr \u7684\u4efb\u52a1\u4e0a\u4e0b\u6587\u6307\u9488\uff0c // \u7136\u540e\u8c03\u7528 __switch \u63a5\u53e3\u8fdb\u884c\u5207\u6362 // go back to user mode } else { // \u627e\u4e0d\u5230\u5c31 panic\uff0c\u6b64\u65f6 panic \u540e\u5c31\u4f1a\u9000\u51fa panic!(\"All applications completed!\"); } } } pub fn run_first_task() { TASK_MANAGER.run_first_task(); // \u5b83\u8c03\u7528\u4e86\u5168\u5c40\u4efb\u52a1\u7ba1\u7406\u5668 TASK_MANAGER \u7684 run_first_task \u65b9\u6cd5\u3002 } fn run_next_task() { TASK_MANAGER.run_next_task(); // \u5b83\u8c03\u7528\u4e86\u5168\u5c40\u4efb\u52a1\u7ba1\u7406\u5668 TASK_MANAGER \u7684 run_next_task \u65b9\u6cd5\u3002 } fn mark_current_suspended() { TASK_MANAGER.mark_current_suspended(); // \u5b83\u8c03\u7528\u4e86\u5168\u5c40\u4efb\u52a1\u7ba1\u7406\u5668 TASK_MANAGER \u7684 mark_current_suspended \u65b9\u6cd5\u3002 } fn mark_current_exited() { TASK_MANAGER.mark_current_exited(); // \u5b83\u8c03\u7528\u4e86\u5168\u5c40\u4efb\u52a1\u7ba1\u7406\u5668 TASK_MANAGER \u7684 mark_current_exited \u65b9\u6cd5\u3002 } pub fn suspend_current_and_run_next() { mark_current_suspended(); // \u5148\u4fee\u6539\u5f53\u524d\u5e94\u7528\u7684\u8fd0\u884c\u72b6\u6001 run_next_task(); // \u7136\u540e\u5c1d\u8bd5\u5207\u6362\u5230\u4e0b\u4e00\u4e2a\u5e94\u7528 } pub fn exit_current_and_run_next() { mark_current_exited(); // \u5148\u4fee\u6539\u5f53\u524d\u5e94\u7528\u7684\u8fd0\u884c\u72b6\u6001 run_next_task(); // \u7136\u540e\u5c1d\u8bd5\u5207\u6362\u5230\u4e0b\u4e00\u4e2a\u5e94\u7528 }","title":"os/src/task/mod.rs"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/#ossrctrapcontextrs","text":"use riscv::register::sstatus::{Sstatus, self, SPP}; #[repr(C)] pub struct TrapContext { pub x: [usize; 32], pub sstatus: Sstatus, pub sepc: usize, } impl TrapContext { pub fn set_sp(&mut self, sp: usize) { self.x[2] = sp; } pub fn app_init_context(entry: usize, sp: usize) -> Self { let mut sstatus = sstatus::read(); sstatus.set_spp(SPP::User); let mut cx = Self { x: [0; 32], sstatus, sepc: entry, }; cx.set_sp(sp); cx } }","title":"os/src/trap/context.rs"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/#ossrctrapmodrs","text":"mod context; use riscv::register::{ mtvec::TrapMode, stvec, scause::{ self, Trap, Exception, Interrupt, }, stval, sie, }; use crate::syscall::syscall; // use crate::batch::run_next_app; use core::arch::global_asm; use crate::task::{ exit_current_and_run_next, suspend_current_and_run_next, }; use crate::timer::set_next_trigger; global_asm!(include_str!(\"trap.S\")); pub fn init(){ extern \"C\" {fn __alltraps();} unsafe{ stvec::write(__alltraps as usize, TrapMode::Direct); } } #[no_mangle] pub fn trap_handler(cx: &mut TrapContext) -> &mut TrapContext{ let scause = scause::read(); let stval = stval::read(); match scause.cause(){ Trap::Exception(Exception::UserEnvCall) => { cx.sepc += 4; cx.x[10] = syscall(cx.x[17], [cx.x[10], cx.x[11], cx.x[12]]) as usize; } Trap::Exception(Exception::StoreFault) | Trap::Exception(Exception::StorePageFault) => { println!(\"[kernel] PageFault in application, bad addr = {:#x}, bad instruction = {:#x}, kernel killed it.\", stval, cx.sepc); exit_current_and_run_next(); } Trap::Exception(Exception::IllegalInstruction) => { println!(\"[kernel] IllegalInstruction in application, kernel killed it.\"); exit_current_and_run_next(); } Trap::Interrupt(Interrupt::SupervisorTimer) => { set_next_trigger(); suspend_current_and_run_next(); } // \u5f53\u53d1\u73b0\u89e6\u53d1\u4e86\u4e00\u4e2a S \u7279\u6743\u7ea7\u65f6\u949f\u4e2d\u65ad\u7684\u65f6\u5019\uff0c\u9996\u5148\u91cd\u65b0\u8bbe\u7f6e\u4e00\u4e2a 10ms \u7684\u8ba1\u65f6\u5668\uff0c // \u7136\u540e\u8c03\u7528\u4e0a\u4e00\u5c0f\u8282\u63d0\u5230\u7684 suspend_current_and_run_next \u51fd\u6570\u6682\u505c\u5f53\u524d\u5e94\u7528\u5e76\u5207\u6362\u5230\u4e0b\u4e00\u4e2a _ => { panic!(\"Unsupported trap {:?}, stval = {:#x}!\", scause.cause(), stval); } } cx } pub use context::TrapContext; // use riscv::register::sie; pub fn enable_timer_interrupt() { unsafe { sie::set_stimer(); } }","title":"os/src/trap/mod.rs"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/#ossrctraptraps","text":".altmacro .macro SAVE_GP n sd x\\n, \\n*8(sp) .endm .macro LOAD_GP n ld x\\n, \\n*8(sp) .endm .section .text .globl __alltraps .globl __restore .align 2 __alltraps: csrrw sp, sscratch, sp # now sp->kernel stack, sscratch->user stack # allocate a TrapContext on kernel stack addi sp, sp, -34*8 # save general-purpose registers sd x1, 1*8(sp) # skip sp(x2), we will save it later sd x3, 3*8(sp) # skip tp(x4), application does not use it # save x5~x31 .set n, 5 .rept 27 SAVE_GP %n .set n, n+1 .endr # we can use t0/t1/t2 freely, because they were saved on kernel stack csrr t0, sstatus csrr t1, sepc sd t0, 32*8(sp) sd t1, 33*8(sp) # read user stack from sscratch and save it on the kernel stack csrr t2, sscratch sd t2, 2*8(sp) # set input argument of trap_handler(cx: &mut TrapContext) mv a0, sp call trap_handler __restore: # now sp->kernel stack(after allocated), sscratch->user stack # restore sstatus/sepc # \u5b83 \u4e0d\u518d\u9700\u8981 \u5728\u5f00\u5934 mv sp, a0 \u4e86\u3002\u56e0\u4e3a\u5728 __switch \u4e4b\u540e\uff0c # sp \u5c31\u5df2\u7ecf\u6b63\u786e\u6307\u5411\u4e86\u6211\u4eec\u9700\u8981\u7684 Trap \u4e0a\u4e0b\u6587\u5730\u5740 ld t0, 32*8(sp) ld t1, 33*8(sp) ld t2, 2*8(sp) csrw sstatus, t0 csrw sepc, t1 csrw sscratch, t2 # restore general-purpuse registers except sp/tp ld x1, 1*8(sp) ld x3, 3*8(sp) .set n, 5 .rept 27 LOAD_GP %n .set n, n+1 .endr # release TrapContext on kernel stack addi sp, sp, 34*8 # now sp->kernel stack, sscratch->user stack csrrw sp, sscratch, sp sret","title":"os/src/trap/trap.S"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/#ossrcloaderrs","text":"use crate::trap::TrapContext; use crate::config::*; use core::arch::asm; #[repr(align(4096))] #[derive(Copy, Clone)] struct KernelStack { data: [u8; KERNEL_STACK_SIZE], } #[repr(align(4096))] #[derive(Copy, Clone)] struct UserStack { data: [u8; USER_STACK_SIZE], } static KERNEL_STACK: [KernelStack; MAX_APP_NUM] = [ KernelStack { data: [0; KERNEL_STACK_SIZE], }; MAX_APP_NUM ]; static USER_STACK: [UserStack; MAX_APP_NUM] = [ UserStack { data: [0; USER_STACK_SIZE], }; MAX_APP_NUM ]; impl KernelStack { fn get_sp(&self) -> usize { self.data.as_ptr() as usize + KERNEL_STACK_SIZE } pub fn push_context(&self, trap_cx: TrapContext) -> usize { let trap_cx_ptr = (self.get_sp() - core::mem::size_of::<TrapContext>()) as *mut TrapContext; unsafe { *trap_cx_ptr = trap_cx; } trap_cx_ptr as usize } } impl UserStack { fn get_sp(&self) -> usize { self.data.as_ptr() as usize + USER_STACK_SIZE } } fn get_base_i(app_id: usize) -> usize { APP_BASE_ADDRESS + app_id * APP_SIZE_LIMIT } // \u83b7\u53d6\u7b2c i \u4e2a\u5e94\u7528\u7684\u8d77\u59cb\u5730\u5740 pub fn get_num_app() -> usize { extern \"C\" { fn _num_app(); } unsafe { (_num_app as usize as *const usize).read_volatile() } } // \u83b7\u53d6 _num_app, \u5373\u5e94\u7528\u7684\u4e2a\u6570 pub fn load_apps() { extern \"C\" { fn _num_app(); } let num_app_ptr = _num_app as usize as *const usize; let num_app = get_num_app(); let app_start = unsafe { core::slice::from_raw_parts(num_app_ptr.add(1), num_app + 1) }; // clear i-cache first unsafe { asm!(\"fence.i\"); } // load apps for i in 0..num_app { let base_i = get_base_i(i); // \u83b7\u53d6\u7b2c i \u4e2a\u5e94\u7528\u7684\u8d77\u59cb\u5730\u5740 (base_i..base_i + APP_SIZE_LIMIT).for_each(|addr| unsafe { (addr as *mut u8).write_volatile(0) }); // \u5c06\u7528\u4e8e\u5b58\u653e\u7b2c i \u4e2a\u5e94\u7528\u7684\u5730\u5740\u533a\u95f4 \u7528 0 \u586b\u5145 let src = unsafe { core::slice::from_raw_parts(app_start[i] as *const u8, app_start[i + 1] - app_start[i]) }; // \u83b7\u53d6\u7b2c i \u4e2a\u5e94\u7528\u5728 .data \u6bb5\u4e2d\u7684\u8d77\u59cb\u5730\u5740 \u548c \u957f\u5ea6 let dst = unsafe { core::slice::from_raw_parts_mut(base_i as *mut u8, src.len()) }; // \u5c06\u521a\u624d\u7528 0 \u586b\u5145\u7684\u8d77\u59cb\u5730\u5740 \u548c \u5e94\u7528\u7684\u957f\u5ea6\u5c01\u88c5\u8d77\u6765 dst.copy_from_slice(src); // \u5c06\u7b2c i \u4e2a\u5e94\u7528 \u4ece .data \u6bb5\u52a0\u8f7d\u5230 \u4e0a\u9762\u5bf9\u5e94\u7684\u5730\u5740\u7a7a\u95f4 } } pub fn init_app_cx(app_id: usize) -> usize { // \u6784\u9020\u8be5\u4efb\u52a1\u7684 Trap \u4e0a\u4e0b\u6587\uff08\u5305\u62ec\u5e94\u7528\u5165\u53e3\u5730\u5740\u548c\u7528\u6237\u6808\u6307\u9488\uff09\u5e76\u5c06\u5176\u538b\u5165\u5230\u5185\u6838\u6808\u9876 KERNEL_STACK[app_id].push_context( TrapContext::app_init_context(get_base_i(app_id), USER_STACK[app_id].get_sp()), ) }","title":"os/src/loader.rs"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/#ossrcmainrs","text":"#![no_std] #![no_main] #![feature(panic_info_message)] #[macro_use] mod console; mod lang_items; mod sbi; mod syscall; mod trap; // mod batch; mod loader; mod config; mod task; mod sync; mod timer; use core::arch::global_asm; global_asm!(include_str!(\"entry.asm\")); global_asm!(include_str!(\"link_app.S\")); fn clear_bss(){ extern \"C\" { fn sbss(); fn ebss(); } // (sbss as usize..ebss as usize).for_each(|a| { // unsafe { (a as *mut u8).write_volatile(0)} // }); unsafe { core::slice::from_raw_parts_mut( sbss as usize as *mut u8, ebss as usize - sbss as usize, ).fill(0); } } #[no_mangle] pub fn rust_main() -> ! { clear_bss(); // loop {} // println!(\"Hello, world\"); // println!(\"I am zk\"); // println!(\"\\x1b[31mhello world\\x1b[0m\"); // extern \"C\" { // fn stext(); // fn etext(); // } // println!(\".text location: {}\", stext as usize); // panic!(\"Shutdown machine!\"); println!(\"[kernel] Hello, world!\"); // println!(\"test {} a {} text.\", 3, 5); trap::init(); // batch::init(); // batch::run_next_app(); loader::load_apps(); trap::enable_timer_interrupt(); // \u4e3a\u4e86\u907f\u514d S \u7279\u6743\u7ea7\u65f6\u949f\u4e2d\u65ad\u88ab\u5c4f\u853d\uff0c\u6211\u4eec\u9700\u8981\u5728\u6267\u884c\u7b2c\u4e00\u4e2a\u5e94\u7528\u4e4b\u524d\u8fdb\u884c\u4e00\u4e9b\u521d\u59cb\u5316\u8bbe\u7f6e // \u8bbe\u7f6e\u4e86 sie.stie \u4f7f\u5f97 S \u7279\u6743\u7ea7\u65f6\u949f\u4e2d\u65ad\u4e0d\u4f1a\u88ab\u5c4f\u853d timer::set_next_trigger(); // \u8bbe\u7f6e\u7b2c\u4e00\u4e2a 10ms \u7684\u8ba1\u65f6\u5668 task::run_first_task(); panic!(\"Unreachable in rust_main!\"); }","title":"os/src/main.rs"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/#osmakefile","text":"#Building TARGET := riscv64gc-unknown-none-elf MODE := release KERNEL_ELF := target/$(TARGET)/$(MODE)/os KERNEL_BIN := $(KERNEL_ELF).bin DISASM_TMP := target/$(TARGET)/$(MODE)/asm #BOARD BOARD ?= qemu SBI ?= rustsbi BOOTLOADER := ../bootloader/$(SBI)-$(BOARD).bin K210_BOOTLOADER_SIZE := 131072 #KERNEL ENTRY ifeq ($(BOARD), qemu) KERNEL_ENTRY_PA := 0x80200000 else ifeq ($(BOARD), k210) KERNEL_ENTRY_PA := 0x80020000 endif #Run K210 K210-SERIALPORT = /dev/ttyUSB0 K210-BURNER = ../tools/kflash.py #Binutils OBJDUMP := rust-objdump --arch-name=riscv64 OBJCOPY := rust-objcopy --binary-architecture=riscv64 #Disassembly DISASM ?= -x build: env switch-check $(KERNEL_BIN) switch-check: ifeq ($(BOARD), qemu) (which last-qemu) || (rm -f last-k210 && touch last-qemu && make clean) else ifeq ($(BOARD), k210) (which last-k210) || (rm -f last-qemu && touch last-k210 && make clean) endif env: (rustup target list | grep \"riscv64gc-unknown-none-elf (installed)\") || rustup target add $(TARGET) cargo install cargo-binutils --vers =0.3.3 rustup component add rust-src rustup component add llvm-tools-preview $(KERNEL_BIN): kernel @$(OBJCOPY) $(KERNEL_ELF) --strip-all -O binary $@ kernel: @cd ../user && make build @echo Platform: $(BOARD) @cp src/linker-$(BOARD).ld src/linker.ld @cargo build --release --features \"board_$(BOARD)\" # \u8fd9\u91cc\u591a\u4e86 --features \"board_$(BOARD)\" @rm src/linker.ld clean: @cargo clean disasm: kernel @$(OBJDUMP) $(DISASM) $(KERNEL_ELF) | less disasm-vim: kernel @$(OBJDUMP) $(DISASM) $(KERNEL_ELF) > $(DISASM_TMP) @vim $(DISASM_TMP) @rm $(DISASM_TMP) run: run-inner run-inner: build ifeq ($(BOARD), qemu) @qemu-system-riscv64 \\ -machine virt \\ -nographic \\ -bios $(BOOTLOADER) \\ -device loader,file=$(KERNEL_BIN),addr=$(KERNEL_ENTRY_PA) else (which $(K210-BURNER)) || (cd .. && git clone https://github.com/sipeed/kflash.py.git && mv kflash.py tools) @cp $(BOOTLOADER) $(BOOTLOADER).copy @dd if=$(KERNEL_BIN) of=$(BOOTLOADER).copy bs=$(K210_BOOTLOADER_SIZE) seek=1 @mv $(BOOTLOADER).copy $(KERNEL_BIN) @sudo chmod 777 $(K210-SERIALPORT) python3 $(K210-BURNER) -p $(K210-SERIALPORT) -b 1500000 $(KERNEL_BIN) python3 -m serial.tools.miniterm --eol LF --dtr 0 --rts 0 --filter direct $(K210-SERIALPORT) 115200 endif debug: build @tmux new-session -d \\ \"qemu-system-riscv64 -machine virt -nographic -bios $(BOOTLOADER) -device loader,file=$(KERNEL_BIN),addr=$(KERNEL_ENTRY_PA) -s -S\" && \\ tmux split-window -h \"riscv64-unknown-elf-gdb -ex 'file $(KERNEL_ELF)' -ex 'set arch riscv64:riscv64' -ex 'target remote localhost:1234'\" && \\ tmux -2 attach-session -d .PHONY: build env kernel clean disasm disasm-vim run-inner switch-check","title":"os/Makefile"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/#user","text":"","title":"\u5728 user \u6587\u4ef6\u5939\u4e0b"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/#usercargoconfig","text":"[build] target = \"riscv64gc-unknown-none-elf\" [target.riscv64gc-unknown-none-elf] rustflags = [ \"-Clink-args=-Tsrc/linker.ld\", ]","title":"user/.cargo/config"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/#usercargotoml","text":"[package] name = \"user_lib\" version = \"0.1.0\" authors = [\"Yifan Wu <shinbokuow@163.com>\"] edition = \"2018\" # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html [dependencies]","title":"user/Cargo.toml"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/#userbuildpy","text":"import os base_address = 0x80400000 step = 0x20000 linker = 'src/linker.ld' app_id = 0 apps = os.listdir('src/bin') # \u5f97\u5230\u4e00\u4e2a\u5217\u8868\uff0c \u91cc\u9762\u662f \u6587\u4ef6\u540d apps.sort() for app in apps: app = app[:app.find('.')] # app \u53d8\u6210\u4e0d\u5e26\u540e\u7f00\u7684\u6587\u4ef6\u540d lines = [] lines_before = [] with open(linker, 'r') as f: for line in f.readlines(): lines_before.append(line) line = line.replace(hex(base_address), hex(base_address+step*app_id)) lines.append(line) with open(linker, 'w+') as f: f.writelines(lines) # \u627e\u5230 src/linker.ld \u4e2d\u7684 BASE_ADDRESS = 0x80400000; # \u8fd9\u4e00\u884c\uff0c\u5e76\u5c06\u540e\u9762\u7684\u5730\u5740\u66ff\u6362\u4e3a\u548c\u5f53\u524d\u5e94\u7528\u5bf9\u5e94\u7684\u4e00\u4e2a\u5730\u5740 os.system('cargo build --bin %s --release' % app) # \u4f7f\u7528 --bin \u53c2\u6570\u6765\u53ea\u6784\u5efa\u67d0\u4e00\u4e2a\u5e94\u7528 # \u90a3\u5c31\u662f\u5bf9\u6bcf\u4e2a\u5e94\u7528\u5206\u522b\u8fdb\u884c\u7f16\u8bd1 \u6539\u53d8\u5176 \u8d77\u59cb\u5730\u5740 print('[build.py] application %s start with address %s' %(app, hex(base_address+step*app_id))) with open(linker, 'w+') as f: f.writelines(lines_before) # \u5c06 linker.ld \u590d\u539f\uff0c \u73b0\u5728\u7684 base_address = 0x80400000+step*app_id # \u6062\u590d\u4e3a 0x80400000 app_id = app_id + 1","title":"user/build.py"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/#usersrcconsolers","text":"use core::fmt::{self, Write}; use super::write; struct Stdout; const STDOUT: usize = 1; impl Write for Stdout { fn write_str(&mut self, s: &str) -> fmt::Result { write(STDOUT, s.as_bytes()); Ok(()) } } pub fn print(args: fmt::Arguments) { Stdout.write_fmt(args).unwrap(); } #[macro_export] macro_rules! print { ($fmt: literal $(, $($arg: tt)+)?) => { $crate::console::print(format_args!($fmt $(, $($arg)+)?)); } } #[macro_export] macro_rules! println { ($fmt: literal $(, $($arg: tt)+)?) => { $crate::console::print(format_args!(concat!($fmt, \"\\n\") $(, $($arg)+)?)); } }","title":"user/src/console.rs"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/#usersrclang_itemsrs","text":"#[panic_handler] fn panic_handler(panic_info: &core::panic::PanicInfo) -> ! { let err = panic_info.message().unwrap(); if let Some(location) = panic_info.location() { println!(\"Panicked at {}:{}, {}\", location.file(), location.line(), err); } else { println!(\"Panicked: {}\", err); } loop {} }","title":"user/src/lang_items.rs"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/#usersrclibrs","text":"#![no_std] #![feature(panic_info_message)] #![feature(linkage)] #[macro_use] pub mod console; mod syscall; mod lang_items; #[no_mangle] #[link_section = \".text.entry\"] pub extern \"C\" fn _start() -> ! { clear_bss(); exit(main()); panic!(\"unreachable after sys_exit!\"); } #[linkage = \"weak\"] #[no_mangle] fn main() -> i32 { panic!(\"Cannot find main\"); } fn clear_bss(){ extern \"C\" { fn start_bss(); fn end_bss(); } (start_bss as usize..end_bss as usize).for_each(|addr|{ unsafe{ (addr as *mut u8).write_volatile(0);} }); } use syscall::*; pub fn write(fd: usize, buf: &[u8]) -> isize {sys_write(fd, buf)} pub fn exit(exit_code: i32) -> isize {sys_exit(exit_code)} pub fn yield_() -> isize { sys_yield() } pub fn get_time() -> isize { sys_get_time() }","title":"user/src/lib.rs"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/#usersrclinkerld","text":"OUTPUT_ARCH(riscv) ENTRY(_start) BASE_ADDRESS = 0x80400000; SECTIONS { . = BASE_ADDRESS; .text : { *(.text.entry) *(.text .text.*) } .rodata : { *(.rodata .rodata.*) *(.srodata .srodata.*) } .data : { *(.data .data.*) *(.sdata .sdata.*) } .bss : { start_bss = .; *(.bss .bss.*) *(.sbss .sbss.*) end_bss = .; } /DISCARD/ : { *(.eh_frame) *(.debug*) } }","title":"user/src/linker.ld"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/#usersrcsyscallrs","text":"use core::arch::asm; const SYSCALL_WRITE: usize = 64; const SYSCALL_EXIT: usize = 93; const SYSCALL_YIELD: usize = 124; const SYSCALL_GET_TIME: usize = 169; fn syscall(id: usize, args: [usize; 3]) -> isize{ let mut ret: isize; unsafe{ asm!( \"ecall\", inlateout(\"x10\") args[0] => ret, in(\"x11\") args[1], in(\"x12\") args[2], in(\"x17\") id ); } ret } pub fn sys_write(fd: usize, buffer: &[u8]) -> isize{ syscall(SYSCALL_WRITE, [fd, buffer.as_ptr() as usize, buffer.len()]) } pub fn sys_exit(exit_code: i32) -> isize { syscall(SYSCALL_EXIT, [exit_code as usize, 0, 0]) } pub fn sys_yield() -> isize { syscall(SYSCALL_YIELD, [0, 0, 0]) } pub fn sys_get_time() -> isize { syscall(SYSCALL_GET_TIME, [0, 0, 0]) }","title":"user/src/syscall.rs"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/#usersrcbin00power_3rs","text":"#![no_std] #![no_main] #[macro_use] extern crate user_lib; const LEN: usize = 100; #[no_mangle] fn main() -> i32 { let p = 3u64; let m = 998244353u64; let iter: usize = 200000; let mut s = [0u64; LEN]; let mut cur = 0usize; s[cur] = 1; for i in 1..=iter { let next = if cur + 1 == LEN { 0 } else { cur + 1 }; s[next] = s[cur] * p % m; cur = next; if i % 10000 == 0 { println!(\"power_3 [{}/{}]\", i, iter); } } println!(\"{}^{} = {}(MOD {})\", p, iter, s[cur], m); println!(\"Test power_3 OK!\"); 0 }","title":"user/src/bin/00power_3.rs"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/#usersrcbin01power_5rs","text":"#![no_std] #![no_main] #[macro_use] extern crate user_lib; const LEN: usize = 100; #[no_mangle] fn main() -> i32 { let p = 5u64; let m = 998244353u64; let iter: usize = 140000; let mut s = [0u64; LEN]; let mut cur = 0usize; s[cur] = 1; for i in 1..=iter { let next = if cur + 1 == LEN { 0 } else { cur + 1 }; s[next] = s[cur] * p % m; cur = next; if i % 10000 == 0 { println!(\"power_5 [{}/{}]\", i, iter); } } println!(\"{}^{} = {}(MOD {})\", p, iter, s[cur], m); println!(\"Test power_5 OK!\"); 0 }","title":"user/src/bin/01power_5.rs"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/#usersrcbin02power_7rs","text":"#![no_std] #![no_main] #[macro_use] extern crate user_lib; const LEN: usize = 100; #[no_mangle] fn main() -> i32 { let p = 7u64; let m = 998244353u64; let iter: usize = 160000; let mut s = [0u64; LEN]; let mut cur = 0usize; s[cur] = 1; for i in 1..=iter { let next = if cur + 1 == LEN { 0 } else { cur + 1 }; s[next] = s[cur] * p % m; cur = next; if i % 10000 == 0 { println!(\"power_7 [{}/{}]\", i, iter); } } println!(\"{}^{} = {}(MOD {})\", p, iter, s[cur], m); println!(\"Test power_7 OK!\"); 0 }","title":"user/src/bin/02power_7.rs"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/#usersrcbin03sleeprs","text":"#![no_std] #![no_main] #[macro_use] extern crate user_lib; use user_lib::{get_time, yield_}; #[no_mangle] fn main() -> i32 { let current_timer = get_time(); let wait_for = current_timer + 3000; while get_time() < wait_for { yield_(); } println!(\"Test sleep OK!\"); 0 }","title":"user/src/bin/03sleep.rs"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/#usermakefile","text":"TARGET := riscv64gc-unknown-none-elf MODE := release APP_DIR := src/bin TARGET_DIR := target/$(TARGET)/$(MODE) APPS := $(wildcard $(APP_DIR)/*.rs) ELFS := $(patsubst $(APP_DIR)/%.rs, $(TARGET_DIR)/%, $(APPS)) BINS := $(patsubst $(APP_DIR)/%.rs, $(TARGET_DIR)/%.bin, $(APPS)) OBJDUMP := rust-objdump --arch-name=riscv64 OBJCOPY := rust-objcopy --binary-architecture=riscv64 elf: $(APPS) @python3 build.py binary: elf $(foreach elf, $(ELFS), $(OBJCOPY) $(elf) --strip-all -O binary $(patsubst $(TARGET_DIR)/%, $(TARGET_DIR)/%.bin, $(elf));) build: binary clean: @cargo clean .PHONY: elf binary build clean","title":"user/Makefile"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/#_5","text":"os/src/main.rs - \u5bfc\u5165 entry.asm \u8bbe\u7f6e\u51fd\u6570\u6808\uff0c \u8df3\u8f6c\u5230rust_main \u5bfc\u5165 link_app.S \u8fd9\u91cc\u5168\u662f\u6570\u636e\u6bb5\uff0c \u53ef\u6267\u884c\u6587\u4ef6\u5728\u90e8\u5206\u6570\u636e\u6bb5\u4e2d \u8c03\u7528 clear_bass \u51fd\u6570\uff0c \u6e05\u9664 \u9664 .bss.stack \u4ee5\u5916\u7684 .bss \u6bb5 \u8c03\u7528 println! \u6253\u5370 [kernel] Hello, world! , \u6b64\u65f6\u5904\u4e8e\u5185\u6838\u6001 \u8c03\u7528 trap::init os/src/trap/mod.rs \u6211\u4eec\u9700\u8981\u4fee\u6539stvec \u5bc4\u5b58\u5668\u6765\u6307\u5411\u6b63\u786e\u7684Trap\u5904\u7406\u5165\u53e3\u70b9 \u5c06stvec\u8bbe\u7f6e\u4e3aDirect\u6a21\u5f0f\u6307\u5411\u5b83\u7684\u5730\u5740 \u6ce8\u610f\uff1a\u7531\u4e8e\u524d\u9762\u6709\u5bfc\u5165 trap.S\uff0c \u6240\u6709\u8fd9\u91cc\u77e5\u9053 Trap\u7684\u5904\u7406\u5165\u53e3 \u5373 __alltraps \u8c03\u7528 loader::load_apps os/src/loader.rs \u8c03\u7528 get_num_app \u83b7\u53d6\u5e94\u7528\u4e2a\u6570 \u83b7\u53d6\u7b2c\u4e00\u4e2a\u7a0b\u5e8f\u7684\u5165\u53e3\u5730\u5740 \u5237\u65b0\u6307\u4ee4\u7f13\u51b2\u533a \u8c03\u7528 get_base_i \u83b7\u53d6 \u6bcf\u4e2a\u5e94\u7528\u7a0b\u5e8f\u7684\u8d77\u59cb\u5730\u5740 \u5c06\u6bcf\u4e2a\u5e94\u7528\u8d77\u59cb\u5730\u5740\u5230 \u5e94\u7528\u7a7a\u95f4\u9650\u5236\u8303\u56f4\u7684\u5730\u5740\u533a\u95f4 \u7528 0 \u586b\u5145 \u83b7\u53d6\u6bcf\u4e2a\u5e94\u7528\u5728 .data \u6bb5\u7684\u8d77\u59cb\u5730\u5740\u548c\u5927\u5c0f \u548c \u5728\u5c06\u4f1a\u653e\u7f6e\u8be5\u7a0b\u5e8f\u7684\u8d77\u59cb\u5730\u5740\u548c\u7a0b\u5e8f\u5927\u5c0f \u8c03\u7528 copy_from_slice \u5c06\u7a0b\u5e8f\u4ece .data \u6bb5\u590d\u5236\u5230 \u76f8\u5e94\u7684\u5730\u5740\u533a\u95f4 \u81f3\u6b64\uff0c\u7a0b\u5e8f\u52a0\u8f7d\u5b8c\u6bd5 os/src/main.rs \u8c03\u7528 trap::enable_timer_interrupt os/src/trap/mod.rs \u8c03\u7528 sie::set_stimer \u4f7f\u5f97 S \u7279\u6743\u7ea7\u65f6\u949f\u4e2d\u65ad\u4e0d\u4f1a\u88ab\u5c4f\u853d os/src/main.rs \u8c03\u7528 timer::set_next_trigger os/src/timer.rs \u8c03\u7528 get_time \u83b7\u5f97\u5f53\u524d\u65f6\u95f4\uff0c \u5373 mtime \u7684\u503c \u4f30\u7b97\u51fa 10 ms \u540e mtime \u7684\u503c \u518d\u5c06\u4f30\u7b97\u7684\u503c\u8d4b\u503c\u7ed9 mtimecmp os/src/main.rs \u8c03\u7528 task \u6a21\u5757\u7684 run_first_task os/src/task/mod.rs \u9996\u5148\uff0c\u9759\u6001\u52a0\u8f7d\u4e00\u4e2a\u5168\u5c40\u7684\u4efb\u52a1\u7ba1\u7406\u5668 TaskManager \u7ed3\u6784 \u7684\u5b9e\u4f8b TASK_MANAGER,\u5305\u542b num_app \u548c inner inner \u5305\u62ec \u6570\u7ec4 tasks \u548c current_task \u6570\u7ec4 tasks \u662f TaskControlBlock \u7ed3\u6784\u7684\u6570\u7ec4 TaskControlBlock \u7ed3\u6784\u4f53 \u5305\u62ec \u4efb\u52a1\u72b6\u6001 task_status \u548c \u4efb\u52a1\u4e0a\u4e0b\u6587 TaskContext TaskContext \u5305\u542b \u90a314\u4e2a\u5bc4\u5b58\u5668 \u5bf9\u4efb\u52a1\u6570\u7ec4\u8fdb\u884c\u521d\u59cb\u5316\uff0c\u5c06\u6bcf\u4e2a\u4efb\u52a1\u90fd\u8fdb\u884c\u521d\u59cb\u5316 \u5bf9\u4efb\u52a1\u4e0a\u4e0b\u6587\u8c03\u7528 zero_init \u8fdb\u884c\u521d\u59cb\u5316\uff0c\u5373\u5c06\u8fd9 14 \u4e2a\u5bc4\u5b58\u5668\u90fd\u521d\u59cb\u5316\u4e3a 0 \u5c06\u4efb\u52a1\u7684\u72b6\u6001 \u8bbe\u7f6e\u4e3a UnInit, \u5373\u672a\u521d\u59cb\u5316 \u5bf9\u4e8e\u6bcf\u4e2a\u4efb\u52a1\uff0c\u5148\u8c03\u7528 init_app_cx, \u6784\u9020\u8be5\u4efb\u52a1\u7684 Trap \u4e0a\u4e0b\u6587 \u5728 os/src/loader.rs \u83b7\u53d6\u6bcf\u4e2a\u5e94\u7528\u7684 \u8d77\u59cb\u5730\u5740 \u548c \u6808\u9488 \u521d\u59cb\u5316\u5b83\u7684 Trap \u4e0a\u4e0b\u6587 \u5728 os/src/trap/context.rs \u83b7\u53d6\u5f53\u524d\u7684 sstatus \u5e76\u5b58\u653e\u5728\u7ed3\u6784\u4e2d \u5c06\u8fd9\u4e2a sstatus \u7ed3\u6784\u7684 SPP\u7f6e\u4f4d User \u5c06\u901a\u7528\u5bc4\u5b58\u5668 \u5168\u7f6e\u4e3a 0 \u5c06 sepc \u8bbe\u4e3a\u4f20\u5165\u7684\u5e94\u7528\u7684\u5730\u5740 entry \u5c06 Trap\u4e0a\u4e0b\u6587\u7684 sp \u7f6e\u4e3a \u4f20\u5165\u7684 \u5185\u6838\u6808\u5730\u5740 sp \u8fd4\u56de Trap \u4e0a\u4e0b\u6587 \u5c06 Trap \u4e0a\u4e0b\u6587 push \u5230\u5185\u6838\u6808\u4e2d \u8fd4\u56de\u4e00\u4e2a \u6267\u884c\u6539\u4e0a\u4e0b\u6587\u7684 \u6307\u9488 \u5c06\u6307\u5411 Trap \u4e0a\u4e0b\u6587\u7684 \u6307\u9488 \u4f20\u5165\u5230 goto_restoren \u51fd\u6570\u4e2d \u7528\u5b83\u521d\u59cb\u5316\u4efb\u52a1\u4e0a\u4e0b\u6587 TaskContext \u5c06\u4efb\u52a1\u4e0a\u4e0b\u6587\u8fd4\u56de\u7ed9\u6bcf\u4e2a\u4efb\u52a1 \u5c06\u6bcf\u4e2a\u4efb\u52a1\u90fd\u7f6e\u4e3a Ready \u6700\u540e\uff0c\u83b7\u5f97\u4e00\u4e2a\u4efb\u52a1\u7ba1\u7406\u5668\uff0c\u5b83\u5305\u542b \u4efb\u52a1\u6570\uff0c\u4efb\u52a1\u6570\u7ec4\uff0c\u5f53\u524d\u4efb\u52a1\u7684\u7f16\u53f7 \u8fd9\u6837\uff0c\u9759\u6001\u52a0\u8f7d\u5668\u7684\u4efb\u52a1\u5b8c\u6210 \u8c03\u7528 run_first_task \u5c06\u7b2c\u4e00\u4e2a\u4efb\u52a1\u7684\u72b6\u6001\u7f6e\u4e3a Running \u521b\u5efa\u4e00\u4e2a\u6307\u9488 \u6307\u5411 \u7b2c\u4e00\u4e2a\u4efb\u52a1\u7684\u4efb\u52a1\u4e0a\u4e0b\u6587 \u6784\u9020\u4e00\u4e2a \u53ea\u6709\u4efb\u52a1\u4e0a\u4e0b\u6587\u7ed3\u6784\u800c\u65e0\u771f\u6b63\u5185\u5bb9\u7684 \u4efb\u52a1\u4e0a\u4e0b\u6587 \u5c06 \u8fd9\u4e24\u4e2a\u4e0a\u4e0b\u6587\u7684 \u6307\u9488\u9001\u7ed9 \u5207\u6362\u51fd\u6570 _switch _switch \u51fd\u6570\u5728\u5c06\u4ed6\u4eec\u9001\u5230 \u6c47\u7f16\u51fd\u6570 _switch \u4e2d \u4fdd\u5b58\u5f53\u524d\u4efb\u52a1\u7684 \u6808\u6bb5\uff0c \u4fdd\u5b58\u5f53\u524d \u4efb\u52a1\u4e0a\u4e0b\u6587\uff0c \u6062\u590d\u4e0b\u4e00\u4e2a\u4efb\u52a1\u4e0a\u4e0b\u6587\uff0c \u6062\u590d\u4e0b\u4e00\u4e2a\u4efb\u52a1\u7684 \u6808\u6bb5 ret \u8fd4\u56de\u5230 \u4e0b\u4e00\u4e2a\u4efb\u52a1\uff0c\u8fdb\u5165\u5230\u7528\u6237\u6001 user/src/bin/00power_3.rs \u6b63\u5e38\u8fd0\u884c \u8fbe\u5230\u65f6\u95f4\u540e\uff0c\u4e2d\u65ad\u89e6\u53d1\uff0c \u8fdb\u5165 Trap \u8fdb\u5165\u5230 __alltraps, \u4fdd\u5b58\u5b8c\u4e0a\u4e0b\u6587\u540e\uff0c\u8fdb\u5165\u5230 trap_handler \u5224\u65ad\u51fa\u662f \u65f6\u949f\u4e2d\u65ad\uff0c\u5148\u8bbe\u7f6e\u4e0b\u4e00\u4e2a\u4e2d\u65ad\u7684\u65f6\u95f4 \u518d\u60ac\u7f6e\u5f53\u524d\u4efb\u52a1\uff0c\u8df3\u8f6c\u5230\u4e0b\u4e00\u4e2a\u4efb\u52a1 \u5f53\u5e94\u7528\u5b8c\u6210\u4e86\uff0c \u6253\u5370 Test power_3 OK! user/src/lib.rs \u8c03\u7528 exit\uff0cexit \u8c03\u7528 sys_exit user/src/syscall.rs \u4e2d sys_exit \u8fdb\u884c \u7cfb\u7edf\u8c03\u7528 syscall , \u5f15\u53d1 ecall \u8df3\u8f6c\u5230 __alltraps \u8df3\u8f6c\u5230 os/src/syscall/mod.rs \u4e2d\u7684 sys_exit os/src/syscall/process.rs \u4e2d\u7684 sys_exit \u5148\u6253\u5370 [kernel] Application exited with code 0 \u7136\u540e\u8c03\u7528 exit_current_and_run_next \u518d\u6b21\u8fd4\u56de\u5230 os/src/task/mod.rs \u5148\u5c06 \u5f53\u524d\u4efb\u52a1\u7684\u72b6\u6001\u6807\u8bb0\u4e3a Exited \u518d\u8c03\u7528 run_next_task user/src/bin/sleep.rs \u5355\u51fa\u73b0 yield_ \u65f6\uff0c\u548c\u4e0a\u4e00\u8282\u4e00\u6837 \u5982\u679c\u6240\u6709\u7684\u4efb\u52a1\u90fd\u5b8c\u6210\u4e86\uff0c\u5c31 panic \u6253\u5370\u51fa All applications completed! \u6253\u5370 panic \u7684\u4f4d\u7f6e \u8c03\u7528 shutdown \u5173\u673a","title":"\u6267\u884c\u6d41\u7a0b"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%8D%8F%E4%BD%9C%E5%BC%8F%E8%B0%83%E7%94%A8/","text":"\u5b9e\u73b0\u591a\u9053\u7a0b\u5e8f\u4e0e\u534f\u4f5c\u5f0f\u8c03\u7528 \u7b2c\u4e09\u7ae0\u4ee3\u7801\u6811 \u5206\u65f6\u591a\u4efb\u52a1\u7684\u4e3a\u4f8b ./os/src Rust 18 Files 511 Lines Assembly 3 Files 82 Lines \u251c\u2500\u2500 bootloader \u2502 \u251c\u2500\u2500 rustsbi-k210.bin \u2502 \u2514\u2500\u2500 rustsbi-qemu.bin \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 os \u2502 \u251c\u2500\u2500 build.rs \u2502 \u251c\u2500\u2500 Cargo.toml \u2502 \u251c\u2500\u2500 Makefile \u2502 \u2514\u2500\u2500 src \u2502 \u251c\u2500\u2500 batch.rs(\u79fb\u9664\uff1a\u529f\u80fd\u5206\u522b\u62c6\u5206\u5230 loader \u548c task \u4e24\u4e2a\u5b50\u6a21\u5757) \u2502 \u251c\u2500\u2500 config.rs(\u65b0\u589e\uff1a\u4fdd\u5b58\u5185\u6838\u7684\u4e00\u4e9b\u914d\u7f6e) \u2502 \u251c\u2500\u2500 console.rs \u2502 \u251c\u2500\u2500 entry.asm \u2502 \u251c\u2500\u2500 lang_items.rs \u2502 \u251c\u2500\u2500 link_app.S \u2502 \u251c\u2500\u2500 linker-k210.ld \u2502 \u251c\u2500\u2500 linker-qemu.ld \u2502 \u251c\u2500\u2500 loader.rs(\u65b0\u589e\uff1a\u5c06\u5e94\u7528\u52a0\u8f7d\u5230\u5185\u5b58\u5e76\u8fdb\u884c\u7ba1\u7406) \u2502 \u251c\u2500\u2500 main.rs(\u4fee\u6539\uff1a\u4e3b\u51fd\u6570\u8fdb\u884c\u4e86\u4fee\u6539) \u2502 \u251c\u2500\u2500 sbi.rs(\u4fee\u6539\uff1a\u5f15\u5165\u65b0\u7684 sbi call set_timer) \u2502 \u251c\u2500\u2500 sync \u2502 \u2502 \u251c\u2500\u2500 mod.rs \u2502 \u2502 \u2514\u2500\u2500 up.rs \u2502 \u251c\u2500\u2500 syscall(\u4fee\u6539\uff1a\u65b0\u589e\u82e5\u5e72 syscall) \u2502 \u2502 \u251c\u2500\u2500 fs.rs \u2502 \u2502 \u251c\u2500\u2500 mod.rs \u2502 \u2502 \u2514\u2500\u2500 process.rs \u2502 \u251c\u2500\u2500 task(\u65b0\u589e\uff1atask \u5b50\u6a21\u5757\uff0c\u4e3b\u8981\u8d1f\u8d23\u4efb\u52a1\u7ba1\u7406) \u2502 \u2502 \u251c\u2500\u2500 context.rs(\u5f15\u5165 Task \u4e0a\u4e0b\u6587 TaskContext) \u2502 \u2502 \u251c\u2500\u2500 mod.rs(\u5168\u5c40\u4efb\u52a1\u7ba1\u7406\u5668\u548c\u63d0\u4f9b\u7ed9\u5176\u4ed6\u6a21\u5757\u7684\u63a5\u53e3) \u2502 \u2502 \u251c\u2500\u2500 switch.rs(\u5c06\u4efb\u52a1\u5207\u6362\u7684\u6c47\u7f16\u4ee3\u7801\u89e3\u91ca\u4e3a Rust \u63a5\u53e3 __switch) \u2502 \u2502 \u251c\u2500\u2500 switch.S(\u4efb\u52a1\u5207\u6362\u7684\u6c47\u7f16\u4ee3\u7801) \u2502 \u2502 \u2514\u2500\u2500 task.rs(\u4efb\u52a1\u63a7\u5236\u5757 TaskControlBlock \u548c\u4efb\u52a1\u72b6\u6001 TaskStatus \u7684\u5b9a\u4e49) \u2502 \u251c\u2500\u2500 timer.rs(\u65b0\u589e\uff1a\u8ba1\u65f6\u5668\u76f8\u5173) \u2502 \u2514\u2500\u2500 trap \u2502 \u251c\u2500\u2500 context.rs \u2502 \u251c\u2500\u2500 mod.rs(\u4fee\u6539\uff1a\u65f6\u949f\u4e2d\u65ad\u76f8\u5e94\u5904\u7406) \u2502 \u2514\u2500\u2500 trap.S \u251c\u2500\u2500 README.md \u251c\u2500\u2500 rust-toolchain \u251c\u2500\u2500 tools \u2502 \u251c\u2500\u2500 kflash.py \u2502 \u251c\u2500\u2500 LICENSE \u2502 \u251c\u2500\u2500 package.json \u2502 \u251c\u2500\u2500 README.rst \u2502 \u2514\u2500\u2500 setup.py \u2514\u2500\u2500 user \u251c\u2500\u2500 build.py(\u65b0\u589e\uff1a\u4f7f\u7528 build.py \u6784\u5efa\u5e94\u7528\u4f7f\u5f97\u5b83\u4eec\u5360\u7528\u7684\u7269\u7406\u5730\u5740\u533a\u95f4\u4e0d\u76f8\u4ea4) \u251c\u2500\u2500 Cargo.toml \u251c\u2500\u2500 Makefile(\u4fee\u6539\uff1a\u4f7f\u7528 build.py \u6784\u5efa\u5e94\u7528) \u2514\u2500\u2500 src \u251c\u2500\u2500 bin(\u4fee\u6539\uff1a\u6362\u6210\u7b2c\u4e09\u7ae0\u6d4b\u4f8b) \u2502 \u251c\u2500\u2500 00power_3.rs \u2502 \u251c\u2500\u2500 01power_5.rs \u2502 \u251c\u2500\u2500 02power_7.rs \u2502 \u2514\u2500\u2500 03sleep.rs \u251c\u2500\u2500 console.rs \u251c\u2500\u2500 lang_items.rs \u251c\u2500\u2500 lib.rs \u251c\u2500\u2500 linker.ld \u2514\u2500\u2500 syscall.rs \u672c\u8282\u7684\u4efb\u52a1 \u4e0d\u662f\u6240\u6709\u7684\u8d44\u6e90\u90fd\u9700\u8981\u88ab\u4fdd\u5b58\uff0c\u4e8b\u5b9e\u4e0a\u53ea\u6709\u90a3\u4e9b\u5bf9\u4e8e\u7a0b\u5e8f\u63a5\u4e0b\u6765\u7684\u6b63\u786e\u6267\u884c\u4ecd\u7136\u6709\u7528\uff0c\u4e14\u5728\u5b83\u88ab\u5207\u6362\u51fa\u53bb\u7684\u65f6\u5019\u6709\u88ab\u8986\u76d6\u98ce\u9669\u7684\u90a3\u4e9b\u8d44\u6e90\u624d\u6709\u88ab\u4fdd\u5b58\u7684\u4ef7\u503c\u3002\u8fd9\u4e9b\u9700\u8981\u4fdd\u5b58\u4e0e\u6062\u590d\u7684\u8d44\u6e90\u88ab\u79f0\u4e3a \u4efb\u52a1\u4e0a\u4e0b\u6587 (Task Context) \u672c\u8282\u5b9e\u73b0\u4e00\u4e2a\u652f\u6301 \u628a\u591a\u4e2a\u5e94\u7528\u7684\u4ee3\u7801\u548c\u6570\u636e\u653e\u7f6e\u5230\u5185\u5b58\u4e2d\uff0c\u5e76\u80fd\u591f\u6267\u884c\u6bcf\u4e00\u4e2a\u5e94\u7528 \u5728\u5e94\u7528\u7a0b\u5e8f\u53d1\u51fa sys_yeild \u7cfb\u7edf\u8c03\u7528\u65f6\uff0c\u80fd\u5207\u6362\u5e94\u7528\uff0c\u4ece\u800c\u8ba9CPU\u5c3d\u53ef\u80fd\u5fd9\u4e8e\u6bcf\u4e2a\u5e94\u7528\u7684\u8ba1\u7b97\u4efb\u52a1 \u63d0\u9ad8\u4efb\u52a1\u8c03\u5ea6\u7684\u7075\u6d3b\u6027 \u548c CPU \u7684\u4f7f\u7528\u6548\u7387 \u672c\u8282\u6587\u4ef6\u89e3\u6790 \u5728bootloader \u6587\u4ef6\u5939\u4e0b rustsbi-qemu.bin \u5728 os \u6587\u4ef6\u5939\u4e0b os/.cargo/config [build] target = \"riscv64gc-unknown-none-elf\" [target.riscv64gc-unknown-none-elf] rustflags = [ \"-Clink-arg=-Tsrc/linker.ld\", \"-Cforce-frame-pointers=yes\" ] os/build.rs use std::io::{Result, Write}; use std::fs::{File, read_dir}; fn main() { println!(\"cargo:rerun-if-changed=../user/src/\"); println!(\"cargo:rerun-if-changed={}\", TARGET_PATH); insert_app_data().unwrap(); } static TARGET_PATH: &str = \"../user/target/riscv64gc-unknown-none-elf/release/\"; fn insert_app_data() -> Result<()> { let mut f = File::create(\"src/link_app.S\").unwrap(); let mut apps: Vec<_> = read_dir(\"../user/src/bin\") .unwrap() .into_iter() .map(|dir_entry| { let mut name_with_ext = dir_entry.unwrap().file_name().into_string().unwrap(); name_with_ext.drain(name_with_ext.find('.').unwrap()..name_with_ext.len()); name_with_ext }) .collect(); apps.sort(); writeln!(f, r#\" .align 3 .section .data .global _num_app _num_app: .quad {}\"#, apps.len())?; for i in 0..apps.len() { writeln!(f, r#\" .quad app_{}_start\"#, i)?; } writeln!(f, r#\" .quad app_{}_end\"#, apps.len() - 1)?; for (idx, app) in apps.iter().enumerate() { println!(\"app_{}: {}\", idx, app); writeln!(f, r#\" .section .data .global app_{0}_start .global app_{0}_end app_{0}_start: .incbin \"{2}{1}.bin\" app_{0}_end:\"#, idx, app, TARGET_PATH)?; } Ok(()) } os/Cargo.toml [package] name = \"os\" version = \"0.1.0\" authors = [\"Yifan Wu <shinbokuow@163.com>\"] edition = \"2018\" # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html [dependencies] riscv = { git = \"https://github.com/rcore-os/riscv\", features = [\"inline-asm\"] } lazy_static = { version = \"1.4.0\", features = [\"spin_no_std\"] } os/src/config.rs pub const USER_STACK_SIZE: usize = 4096 * 2; pub const KERNEL_STACK_SIZE: usize = 4096 * 2; pub const MAX_APP_NUM: usize = 4; pub const APP_BASE_ADDRESS: usize = 0x80400000; pub const APP_SIZE_LIMIT: usize = 0x20000; os/src/console.rs use core::fmt::{self, Write}; use crate::sbi::console_putchar; struct Stdout; impl Write for Stdout { fn write_str(&mut self, s: &str) -> fmt::Result { for c in s.chars() { console_putchar(c as usize); } Ok(()) } } pub fn print(args: fmt::Arguments) { Stdout.write_fmt(args).unwrap(); } #[macro_export] macro_rules! print { ($fmt: literal $(, $($arg: tt)+)?) => { $crate::console::print(format_args!($fmt $(, $($arg)+)?)); } } #[macro_export] macro_rules! println { ($fmt: literal $(, $($arg: tt)+)?) => { $crate::console::print(format_args!(concat!($fmt, \"\\n\") $(, $($arg)+)?)); } } os/src/entry.asm .section .text.entry .globl _start _start: la sp, boot_stack_top call rust_main .section .bss.stack .globl boot_stack boot_stack: .space 4096 * 16 .globl boot_stack_top boot_stack_top: os/src/lang_items.rs use core::panic::PanicInfo; use crate::sbi::shutdown; #[panic_handler] fn panic(info: &PanicInfo) -> ! { if let Some(location) = info.location() { println!(\"[kernel] Panicked at {}:{} {}\", location.file(), location.line(), info.message().unwrap()); } else { println!(\"[kernel] Panicked: {}\", info.message().unwrap()); } shutdown() } os/src/link_app.S .align 3 .section .data .global _num_app _num_app: .quad 3 .quad app_0_start .quad app_1_start .quad app_2_start .quad app_2_end .section .data .global app_0_start .global app_0_end app_0_start: .incbin \"../user/target/riscv64gc-unknown-none-elf/release/00write_a.bin\" app_0_end: .section .data .global app_1_start .global app_1_end app_1_start: .incbin \"../user/target/riscv64gc-unknown-none-elf/release/01write_b.bin\" app_1_end: .section .data .global app_2_start .global app_2_end app_2_start: .incbin \"../user/target/riscv64gc-unknown-none-elf/release/02write_c.bin\" app_2_end: os/src/linker-qemu.ld OUTPUT_ARCH(riscv) ENTRY(_start) BASE_ADDRESS = 0x80200000; SECTIONS { . = BASE_ADDRESS; skernel = .; stext = .; .text : { *(.text.entry) *(.text .text.*) } . = ALIGN(4K); etext = .; srodata = .; .rodata : { *(.rodata .rodata.*) *(.srodata .srodata.*) } . = ALIGN(4K); erodata = .; sdata = .; .data : { *(.data .data.*) *(.sdata .sdata.*) } . = ALIGN(4K); edata = .; .bss : { *(.bss.stack) sbss = .; *(.bss .bss.*) *(.sbss .sbss.*) } . = ALIGN(4K); ebss = .; ekernel = .; /DISCARD/ : { *(.eh_frame) } } os/src/sbi.rs #![allow(unused)] use core::arch::asm; const SBI_SET_TIMER: usize = 0; const SBI_CONSOLE_PUTCHAR: usize = 1; const SBI_CONSOLE_GETCHAR: usize = 2; const SBI_CLEAR_IPI: usize = 3; const SBI_SEND_IPI: usize = 4; const SBI_REMOTE_FENCE_I: usize = 5; const SBI_REMOTE_SFENCE_VMA: usize = 6; const SBI_REMOTE_SFENCE_VMA_ASID: usize = 7; const SBI_SHUTDOWN: usize = 8; #[inline(always)] fn sbi_call(which: usize, arg0: usize, arg1: usize, arg2: usize) -> usize { let mut ret; unsafe { asm!( \"ecall\", inlateout(\"x10\") arg0 => ret, in(\"x11\") arg1, in(\"x12\") arg2, in(\"x17\") which, ); } ret } pub fn console_putchar(c: usize) { sbi_call(SBI_CONSOLE_PUTCHAR, c, 0, 0); } pub fn console_getchar() -> usize { sbi_call(SBI_CONSOLE_GETCHAR, 0, 0, 0) } pub fn shutdown() -> ! { sbi_call(SBI_SHUTDOWN, 0, 0, 0); panic!(\"It should shutdown!\"); } os/src/sync/mod.rs mod up; pub use up::UPSafeCell; os/src/sync/up.rs use core::cell::{RefCell, RefMut}; /// Wrap a static data structure inside it so that we are /// able to access it without any `unsafe`. /// /// We should only use it in uniprocessor. /// /// In order to get mutable reference of inner data, call /// `exclusive_access`. pub struct UPSafeCell<T> { /// inner data inner: RefCell<T>, } unsafe impl<T> Sync for UPSafeCell<T> {} impl<T> UPSafeCell<T> { /// User is responsible to guarantee that inner struct is only used in /// uniprocessor. pub unsafe fn new(value: T) -> Self { Self { inner: RefCell::new(value) } } /// Panic if the data has been borrowed. pub fn exclusive_access(&self) -> RefMut<'_, T> { self.inner.borrow_mut() } } os/src/syscall/fs.rs const FD_STDOUT: usize = 1; pub fn sys_write(fd: usize, buf: *const u8, len: usize) -> isize { match fd { FD_STDOUT => { let slice = unsafe { core::slice::from_raw_parts(buf, len) }; let str = core::str::from_utf8(slice).unwrap(); print!(\"{}\", str); len as isize }, _ => { panic!(\"Unsupported fd in sys_write!\"); } } } os/src/syscall/mod.rs const SYSCALL_WRITE: usize = 64; const SYSCALL_EXIT: usize = 93; const SYSCALL_YIELD: usize = 124; //const SYSCALL_GET_TIME: usize = 169; mod fs; mod process; use fs::*; use process::*; pub fn syscall(syscall_id: usize, args: [usize; 3]) -> isize { match syscall_id { SYSCALL_WRITE => sys_write(args[0], args[1] as *const u8, args[2]), SYSCALL_EXIT => sys_exit(args[0] as i32), SYSCALL_YIELD => sys_yield(), _ => panic!(\"Unsupported syscall_id: {}\", syscall_id), } } os/src/syscall/process.rs use crate::task::{ suspend_current_and_run_next, exit_current_and_run_next, }; pub fn sys_exit(exit_code: i32) -> ! { println!(\"[kernel] Application exited with code {}\", exit_code); // \u5728\u8c03\u7528\u5b83\u4e4b\u524d\u6211\u4eec\u6253\u5370\u5e94\u7528\u7684\u9000\u51fa\u4fe1\u606f\u5e76\u8f93\u51fa\u5b83\u7684\u9000\u51fa\u7801 exit_current_and_run_next(); // \u57fa\u4e8e task \u5b50\u6a21\u5757\u63d0\u4f9b\u7684 exit_current_and_run_next \u63a5\u53e3 panic!(\"Unreachable in sys_exit!\"); } pub fn sys_yield() -> isize { suspend_current_and_run_next(); // task \u5b50\u6a21\u5757\u63d0\u4f9b\u7684 suspend_current_and_run_next \u63a5\u53e3 0 } // sys_yield \u8868\u793a\u5e94\u7528\u81ea\u5df1\u6682\u65f6\u653e\u5f03\u5bf9CPU\u7684\u5f53\u524d\u4f7f\u7528\u6743\uff0c\u8fdb\u5165 Ready \u72b6\u6001 os/src/task/context.rs #[derive(Copy, Clone)] #[repr(C)] pub struct TaskContext { ra: usize, // \u8bb0\u5f55__switch \u51fd\u6570\u8fd4\u56de\u4e4b\u540e\u5e94\u8be5\u8df3\u8f6c\u5230\u54ea\u91cc\u7ee7\u7eed\u6267\u884c // \u4ece\u800c\u5728\u4efb\u52a1\u5207\u6362\u5b8c\u6210\u5e76 ret \u4e4b\u540e\u80fd\u5230\u6b63\u786e\u7684\u4f4d\u7f6e sp: usize, s: [usize; 12], // \u5bf9\u4e8e\u4e00\u822c\u7684\u51fd\u6570\u800c\u8a00\uff0cRust/C \u7f16\u8bd1\u5668\u4f1a\u5728\u51fd\u6570\u7684\u8d77\u59cb\u4f4d\u7f6e\u81ea\u52a8\u751f\u6210\u4ee3\u7801\u6765\u4fdd\u5b58 s0~s11 \u8fd9\u4e9b\u88ab\u8c03\u7528\u8005\u4fdd\u5b58\u7684\u5bc4\u5b58\u5668\u3002 // \u4f46 __switch \u662f\u4e00\u4e2a\u7528\u6c47\u7f16\u4ee3\u7801\u5199\u7684\u7279\u6b8a\u51fd\u6570\uff0c\u5b83\u4e0d\u4f1a\u88ab Rust/C \u7f16\u8bd1\u5668\u5904\u7406\uff0c // \u6240\u4ee5\u6211\u4eec\u9700\u8981\u5728 __switch \u4e2d\u624b\u52a8\u7f16\u5199\u4fdd\u5b58 s0~s11 \u7684\u6c47\u7f16\u4ee3\u7801 // \u4e0d\u7528\u4fdd\u5b58\u5176\u5b83\u5bc4\u5b58\u5668\u662f\u56e0\u4e3a\uff1a\u5176\u5b83\u5bc4\u5b58\u5668\u4e2d\uff0c // \u5c5e\u4e8e\u8c03\u7528\u8005\u4fdd\u5b58\u7684\u5bc4\u5b58\u5668\u662f\u7531\u7f16\u8bd1\u5668\u5728\u9ad8\u7ea7\u8bed\u8a00\u7f16\u5199\u7684\u8c03\u7528\u51fd\u6570\u4e2d\u81ea\u52a8\u751f\u6210\u7684\u4ee3\u7801\u6765\u5b8c\u6210\u4fdd\u5b58\u7684\uff1b // \u8fd8\u6709\u4e00\u4e9b\u5bc4\u5b58\u5668\u5c5e\u4e8e\u4e34\u65f6\u5bc4\u5b58\u5668\uff0c\u4e0d\u9700\u8981\u4fdd\u5b58\u548c\u6062\u590d\u3002 } impl TaskContext { pub fn zero_init() -> Self { Self { ra: 0, sp: 0, s: [0; 12], } } pub fn goto_restore(kstack_ptr: usize) -> Self { // \u6784\u9020\u6bcf\u4e2a\u4efb\u52a1\u4fdd\u5b58\u5728\u4efb\u52a1\u63a7\u5236\u5757\u4e2d\u7684\u4efb\u52a1\u4e0a\u4e0b\u6587 extern \"C\" { fn __restore(); } Self { ra: __restore as usize, // \u5b83\u8bbe\u7f6e\u4efb\u52a1\u4e0a\u4e0b\u6587\u4e2d\u7684\u5185\u6838\u6808\u6307\u9488\u5c06\u4efb\u52a1\u4e0a\u4e0b\u6587\u7684 ra \u5bc4\u5b58\u5668\u8bbe\u7f6e\u4e3a __restore \u7684\u5165\u53e3\u5730\u5740 // \u8fd9\u6837\uff0c\u5728 __switch \u4ece\u5b83\u4e0a\u9762\u6062\u590d\u5e76\u8fd4\u56de\u4e4b\u540e\u5c31\u4f1a\u76f4\u63a5\u8df3\u8f6c\u5230 __restore \uff0c // \u6b64\u65f6\u6808\u9876\u662f\u4e00\u4e2a\u6211\u4eec\u6784\u9020\u51fa\u6765\u7b2c\u4e00\u6b21\u8fdb\u5165\u7528\u6237\u6001\u6267\u884c\u7684 Trap \u4e0a\u4e0b\u6587 sp: kstack_ptr, s: [0; 12], } } } os/src/task/switch.rs use super::TaskContext; use core::arch::global_asm; global_asm!(include_str!(\"switch.S\")); extern \"C\" { pub fn __switch( current_task_cx_ptr: *mut TaskContext, next_task_cx_ptr: *const TaskContext ); // \u6211\u4eec\u4f1a\u5c06\u8fd9\u6bb5\u6c47\u7f16\u4ee3\u7801\u4e2d\u7684\u5168\u5c40\u7b26\u53f7 __switch \u89e3\u91ca\u4e3a\u4e00\u4e2a Rust \u51fd\u6570 // \u6211\u4eec\u4f1a\u8c03\u7528\u8be5\u51fd\u6570\u6765\u5b8c\u6210\u5207\u6362\u529f\u80fd\u800c\u4e0d\u662f\u76f4\u63a5\u8df3\u8f6c\u5230\u7b26\u53f7 __switch \u7684\u5730\u5740\u3002 // \u56e0\u6b64\u5728\u8c03\u7528\u524d\u540e Rust \u7f16\u8bd1\u5668\u4f1a\u81ea\u52a8\u5e2e\u52a9\u6211\u4eec\u63d2\u5165\u4fdd\u5b58/\u6062\u590d\u8c03\u7528\u8005\u4fdd\u5b58\u5bc4\u5b58\u5668\u7684\u6c47\u7f16\u4ee3\u7801 } os/src/task/switch.S .altmacro .macro SAVE_SN n sd s\\n, (\\n+2)*8(a0) .endm .macro LOAD_SN n ld s\\n, (\\n+2)*8(a1) .endm .section .text .globl __switch __switch: # __switch( # current_task_cx_ptr: *mut TaskContext, # next_task_cx_ptr: *const TaskContext # ) # \u51fd\u6570\u539f\u578b\u4e2d\u7684\u4e24\u4e2a\u53c2\u6570\u5206\u522b\u662f\u5f53\u524d A \u4efb\u52a1\u4e0a\u4e0b\u6587\u6307\u9488 next_task_cx_ptr # \u548c\u5373\u5c06\u88ab\u5207\u6362\u5230\u7684 B \u4efb\u52a1\u4e0a\u4e0b\u6587\u6307\u9488 next_task_cx_ptr \uff0c # \u4ece RISC-V \u8c03\u7528\u89c4\u8303 \u53ef\u4ee5\u77e5\u9053\u5b83\u4eec\u5206\u522b\u901a\u8fc7\u5bc4\u5b58\u5668 a0/a1 \u4f20\u5165 # save kernel stack of current task # \u4fdd\u5b58\u5f53\u524d\u4efb\u52a1\u7684\u6808\u6bb5 sd sp, 8(a0) # save ra & s0~s11 of current execution # \u4fdd\u5b58\u5f53\u524d \u4efb\u52a1\u4e0a\u4e0b\u6587 sd ra, 0(a0) .set n, 0 .rept 12 SAVE_SN %n .set n, n + 1 .endr # restore ra & s0~s11 of next execution # \u6062\u590d\u4e0b\u4e00\u4e2a\u4efb\u52a1\u7684\u4e0a\u4e0b\u6587 ld ra, 0(a1) .set n, 0 .rept 12 LOAD_SN %n .set n, n + 1 .endr # restore kernel stack of next task # \u6062\u590d\u4e0a\u4e00\u4e2a\u4efb\u52a1\u7684 \u6808\u6bb5 ld sp, 8(a1) ret os/src/task.rs use super::TaskContext; #[derive(Copy, Clone)] // \u901a\u8fc7 #[derive(...)] \u53ef\u4ee5\u8ba9\u7f16\u8bd1\u5668\u4e3a\u4f60\u7684\u7c7b\u578b\u63d0\u4f9b\u4e00\u4e9b Trait \u7684\u9ed8\u8ba4\u5b9e\u73b0\u3002 // \u5b9e\u73b0\u4e86 Clone Trait \u4e4b\u540e\u5c31\u53ef\u4ee5\u8c03\u7528 clone \u51fd\u6570\u5b8c\u6210\u62f7\u8d1d\uff1b // \u5b9e\u73b0\u4e86 PartialEq Trait \u4e4b\u540e\u5c31\u53ef\u4ee5\u4f7f\u7528 == \u8fd0\u7b97\u7b26\u6bd4\u8f83\u8be5\u7c7b\u578b\u7684\u4e24\u4e2a\u5b9e\u4f8b\uff0c // \u4ece\u903b\u8f91\u4e0a\u8bf4\u53ea\u6709 \u4e24\u4e2a\u76f8\u7b49\u7684\u5e94\u7528\u6267\u884c\u72b6\u6001\u624d\u4f1a\u88ab\u5224\u4e3a\u76f8\u7b49\uff0c\u800c\u4e8b\u5b9e\u4e0a\u4e5f\u786e\u5b9e\u5982\u6b64\u3002 // Copy \u662f\u4e00\u4e2a\u6807\u8bb0 Trait\uff0c\u51b3\u5b9a\u8be5\u7c7b\u578b\u5728\u6309\u503c\u4f20\u53c2/\u8d4b\u503c\u7684\u65f6\u5019\u91c7\u7528\u79fb\u52a8\u8bed\u4e49\u8fd8\u662f\u590d\u5236\u8bed\u4e49\u3002 pub struct TaskControlBlock { // \u4efb\u52a1\u63a7\u5236\u5757 pub task_status: TaskStatus, // \u4efb\u52a1 \u8fd0\u884c\u72b6\u6001 pub task_cx: TaskContext, // \u4efb\u52a1\u4e0a\u4e0b\u6587 } #[derive(Copy, Clone, PartialEq)] pub enum TaskStatus { UnInit, // \u672a\u521d\u59cb\u5316 Ready, // \u51c6\u5907\u8fd0\u884c Running, // \u6b63\u5728\u8fd0\u884c Exited, // \u5df2\u9000\u51fa } os/src/task/mod.rs mod context; mod switch; mod task; use crate::config::MAX_APP_NUM; use crate::loader::{get_num_app, init_app_cx}; use lazy_static::*; use switch::__switch; use task::{TaskControlBlock, TaskStatus}; use crate::sync::UPSafeCell; pub use context::TaskContext; // \u5168\u5c40\u7684\u4efb\u52a1\u7ba1\u7406\u5668 pub struct TaskManager { num_app: usize, // \u4efb\u52a1\u7ba1\u7406\u5668\u7ba1\u7406\u7684\u5e94\u7528\u7684\u6570\u76ee // \u5b83\u5728 TaskManager \u521d\u59cb\u5316\u4e4b\u540e\u5c31\u4e0d\u4f1a\u53d1\u751f\u53d8\u5316 inner: UPSafeCell<TaskManagerInner>, // \u800c\u5305\u88f9\u5728 TaskManagerInner \u5185\u7684\u4efb\u52a1\u63a7\u5236\u5757\u6570\u7ec4 tasks // \u4ee5\u53ca\u8868\u793a CPU \u6b63\u5728\u6267\u884c\u7684\u5e94\u7528\u7f16\u53f7 current_task \u4f1a\u5728\u6267\u884c\u5e94\u7528\u7684\u8fc7\u7a0b\u4e2d\u53d1\u751f\u53d8\u5316\uff1a // \u6bcf\u4e2a\u5e94\u7528\u7684\u8fd0\u884c\u72b6\u6001\u90fd\u4f1a\u53d1\u751f\u53d8\u5316\uff0c\u800c CPU \u6267\u884c\u7684\u5e94\u7528\u4e5f\u5728\u4e0d\u65ad\u5207\u6362\u3002 // \u56e0\u6b64\u6211\u4eec\u9700\u8981\u5c06 TaskManagerInner \u5305\u88f9\u5728 UPSafeCell \u5185 // \u4ee5\u83b7\u53d6\u5176\u5185\u90e8\u53ef\u53d8\u6027\u4ee5\u53ca\u5355\u6838\u4e0a\u5b89\u5168\u7684\u8fd0\u884c\u65f6\u501f\u7528\u68c0\u67e5\u80fd\u529b } struct TaskManagerInner { tasks: [TaskControlBlock; MAX_APP_NUM], current_task: usize, // \u53ea\u80fd\u901a\u8fc7\u5b83\u77e5\u9053 CPU\u6b63\u5728\u6267\u884c\u54ea\u4e2a\u5e94\u7528\uff0c\u800c\u4e0d\u80fd\u63a8\u6d4b\u51fa\u5176\u4ed6\u5e94\u7528\u7684\u4efb\u4f55\u4fe1\u606f } lazy_static! { pub static ref TASK_MANAGER: TaskManager = { let num_app = get_num_app(); // \u8c03\u7528 loader \u5b50\u6a21\u5757\u63d0\u4f9b\u7684 get_num_app \u63a5\u53e3\u83b7\u53d6\u94fe\u63a5\u5230\u5185\u6838\u7684\u5e94\u7528\u603b\u6570 let mut tasks = [ TaskControlBlock { task_cx: TaskContext::zero_init(), task_status: TaskStatus::UnInit }; MAX_APP_NUM ]; // \u521b\u5efa\u4e00\u4e2a\u521d\u59cb\u5316\u7684 tasks \u6570\u7ec4\uff0c\u5176\u4e2d\u7684\u6bcf\u4e2a\u4efb\u52a1\u63a7\u5236\u5757\u7684\u8fd0\u884c\u72b6\u6001\u90fd\u662f UnInit \uff1a\u8868\u793a\u5c1a\u672a\u521d\u59cb\u5316 for i in 0..num_app { tasks[i].task_cx = TaskContext::goto_restore(init_app_cx(i)); // \u5bf9\u4e8e\u6bcf\u4e2a\u4efb\u52a1\uff0c\u6211\u4eec\u5148\u8c03\u7528 init_app_cx \u6784\u9020\u8be5\u4efb\u52a1\u7684 Trap \u4e0a\u4e0b\u6587 // \uff08\u5305\u62ec\u5e94\u7528\u5165\u53e3\u5730\u5740\u548c\u7528\u6237\u6808\u6307\u9488\uff09\u5e76\u5c06\u5176\u538b\u5165\u5230\u5185\u6838\u6808\u9876 // \u63a5\u7740\u8c03\u7528 TaskContext::goto_restore \u6765\u6784\u9020\u6bcf\u4e2a\u4efb\u52a1\u4fdd\u5b58\u5728\u4efb\u52a1\u63a7\u5236\u5757\u4e2d\u7684\u4efb\u52a1\u4e0a\u4e0b\u6587\u3002 // \u5b83\u8bbe\u7f6e\u4efb\u52a1\u4e0a\u4e0b\u6587\u4e2d\u7684\u5185\u6838\u6808\u6307\u9488\u5c06\u4efb\u52a1\u4e0a\u4e0b\u6587\u7684 ra \u5bc4\u5b58\u5668\u8bbe\u7f6e\u4e3a __restore \u7684\u5165\u53e3\u5730\u5740 // \u8fd9\u6837\uff0c\u5728 __switch \u4ece\u5b83\u4e0a\u9762\u6062\u590d\u5e76\u8fd4\u56de\u4e4b\u540e\u5c31\u4f1a\u76f4\u63a5\u8df3\u8f6c\u5230 __restore \uff0c // \u6b64\u65f6\u6808\u9876\u662f\u4e00\u4e2a\u6211\u4eec\u6784\u9020\u51fa\u6765\u7b2c\u4e00\u6b21\u8fdb\u5165\u7528\u6237\u6001\u6267\u884c\u7684 Trap \u4e0a\u4e0b\u6587 tasks[i].task_status = TaskStatus::Ready; } // \u4f9d\u6b21\u5bf9\u6bcf\u4e2a\u4efb\u52a1\u63a7\u5236\u5757\u8fdb\u884c\u521d\u59cb\u5316\uff0c\u5c06\u5176\u8fd0\u884c\u72b6\u6001\u8bbe\u7f6e\u4e3a Ready \uff1a\u8868\u793a\u53ef\u4ee5\u8fd0\u884c\uff0c // \u5e76\u521d\u59cb\u5316\u5b83\u7684 \u4efb\u52a1\u4e0a\u4e0b\u6587 TaskManager { num_app, inner: unsafe { UPSafeCell::new(TaskManagerInner { tasks, current_task: 0, })}, } // \u521b\u5efa TaskManager \u5b9e\u4f8b\u5e76\u8fd4\u56de }; } //\u6ce8\u610f\u6211\u4eec\u65e0\u9700\u548c\u7b2c\u4e8c\u7ae0\u4e00\u6837\u5c06 TaskManager \u6807\u8bb0\u4e3a Sync \uff0c // \u56e0\u4e3a\u7f16\u8bd1\u5668\u53ef\u4ee5\u6839\u636e TaskManager \u5b57\u6bb5\u7684\u60c5\u51b5\u81ea\u52a8\u63a8\u5bfc\u51fa TaskManager \u662f Sync \u7684 impl TaskManager { fn run_first_task(&self) -> ! { let mut inner = self.inner.exclusive_access(); let task0 = &mut inner.tasks[0]; // \u6211\u4eec\u53d6\u51fa\u5373\u5c06\u6700\u5148\u6267\u884c\u7684\u7f16\u53f7\u4e3a 0 \u7684\u5e94\u7528\u7684\u4efb\u52a1\u4e0a\u4e0b\u6587\u6307\u9488 next_task_cx_ptr \u5e76\u5e0c\u671b\u80fd\u591f\u5207\u6362\u8fc7\u53bb\u3002\u6ce8\u610f __switch \u6709\u4e24\u4e2a\u53c2\u6570\u5206\u522b\u8868\u793a\u5f53\u524d\u5e94\u7528\u548c\u5373\u5c06\u5207\u6362\u5230\u7684\u5e94\u7528\u7684\u4efb\u52a1\u4e0a\u4e0b\u6587\u6307\u9488\uff0c\u5176\u7b2c\u4e00\u4e2a\u53c2\u6570\u5b58\u5728\u7684\u610f\u4e49\u662f\u8bb0\u5f55\u5f53\u524d\u5e94\u7528\u7684\u4efb\u52a1\u4e0a\u4e0b\u6587\u88ab\u4fdd\u5b58\u5728\u54ea\u91cc\uff0c\u4e5f\u5c31\u662f\u5f53\u524d\u5e94\u7528\u5185\u6838\u6808\u7684\u6808\u9876\uff0c\u8fd9\u6837\u4e4b\u540e\u624d\u80fd\u7ee7\u7eed\u6267\u884c\u8be5\u5e94\u7528\u3002\u4f46\u5728 run_first_task \u7684\u65f6\u5019\uff0c\u6211\u4eec\u5e76\u6ca1\u6709\u6267\u884c\u4efb\u4f55\u5e94\u7528\uff0c __switch \u524d\u534a\u90e8\u5206\u7684\u4fdd\u5b58\u4ec5\u4ec5\u662f\u5728\u542f\u52a8\u6808\u4e0a\u4fdd\u5b58\u4e86\u4e00\u4e9b\u4e4b\u540e\u4e0d\u4f1a\u7528\u5230\u7684\u6570\u636e\uff0c\u81ea\u7136\u4e5f\u65e0\u9700\u8bb0\u5f55\u542f\u52a8\u6808\u6808\u9876\u7684\u4f4d\u7f6e\u3002 // \u56e0\u6b64\uff0c\u6211\u4eec\u663e\u5f0f\u5728\u542f\u52a8\u6808\u4e0a\u5206\u914d\u4e86\u4e00\u4e2a\u540d\u4e3a _unused \u7684\u4efb\u52a1\u4e0a\u4e0b\u6587\uff0c\u5e76\u5c06\u5b83\u7684\u5730\u5740\u4f5c\u4e3a\u7b2c\u4e00\u4e2a\u53c2\u6570\u4f20\u7ed9 __switch \uff0c\u8fd9\u6837\u4fdd\u5b58\u4e00\u4e9b\u5bc4\u5b58\u5668\u4e4b\u540e\u7684\u542f\u52a8\u6808\u6808\u9876\u7684\u4f4d\u7f6e\u5c06\u4f1a\u4fdd\u5b58\u5728\u6b64\u53d8\u91cf\u4e2d\u3002\u7136\u800c\u65e0\u8bba\u662f\u6b64\u53d8\u91cf\u8fd8\u662f\u542f\u52a8\u6808\u6211\u4eec\u4e4b\u540e\u5747\u4e0d\u4f1a\u6d89\u53ca\u5230\uff0c\u4e00\u65e6\u5e94\u7528\u5f00\u59cb\u8fd0\u884c\uff0c\u6211\u4eec\u5c31\u5f00\u59cb\u5728\u5e94\u7528\u7684\u7528\u6237\u6808\u548c\u5185\u6838\u6808\u4e4b\u95f4\u5f00\u59cb\u5207\u6362\u4e86\u3002\u8fd9\u91cc\u58f0\u660e\u6b64\u53d8\u91cf\u7684\u610f\u4e49\u4ec5\u4ec5\u662f\u4e3a\u4e86\u907f\u514d\u8986\u76d6\u5230\u5176\u4ed6\u6570\u636e task0.task_status = TaskStatus::Running; let next_task_cx_ptr = &task0.task_cx as *const TaskContext; // \u5c06\u7f16\u53f7\u4e3a0 \u7684\u4efb\u52a1 \u6807\u8bb0\u4e3a\u4e0b\u4e00\u4e2a\u8981\u5207\u6362\u5230\u7684\u4efb\u52a1 drop(inner); let mut _unused = TaskContext::zero_init(); // \u521d\u59cb\u5316\u521b\u5efa\u4e00\u4e2a\u4e0d\u4f1a\u7528\u7684\u7684 \u4efb\u52a1\u4e0a\u4e0b\u6587 \u4f5c\u4e3a\u5f53\u524d\u4efb\u52a1\u4e0a\u4e0b\u6587 // \u7531\u4e8e\u4e4b\u540e\u5207\u6362\u65f6 \u627e\u4e0d\u5230\u5b83\u7684 ID\uff0c\u6240\u6709\u4e0d\u7528\u5f53\u5fc3\u5b83\u5bf9\u540e\u7eed\u7a0b\u5e8f\u8fd0\u884c\u7684\u5f71\u54cd // before this, we should drop local variables that must be dropped manually unsafe { __switch( &mut _unused as *mut TaskContext, next_task_cx_ptr, ); } panic!(\"unreachable in run_first_task!\"); } fn mark_current_suspended(&self) { let mut inner = self.inner.exclusive_access(); let current = inner.current_task; inner.tasks[current].task_status = TaskStatus::Ready; // \u5176\u4e2d\uff0c\u9996\u5148\u83b7\u5f97\u91cc\u5c42 TaskManagerInner \u7684\u53ef\u53d8\u5f15\u7528\uff0c // \u901a\u8fc7 sync/up.rs \u91cc UPSafeCell\u7ed3\u6784\u4f53\u7684\u65b9\u6cd5 exclusive_access \u83b7\u53d6 // \u7136\u540e\u6839\u636e\u5176\u4e2d\u8bb0\u5f55\u7684\u5f53\u524d\u6b63\u5728\u6267\u884c\u7684\u5e94\u7528 ID \u5bf9\u5e94\u5728\u4efb\u52a1\u63a7\u5236\u5757\u6570\u7ec4 tasks \u4e2d\u4fee\u6539\u72b6\u6001 } fn mark_current_exited(&self) { let mut inner = self.inner.exclusive_access(); let current = inner.current_task; inner.tasks[current].task_status = TaskStatus::Exited; // \u5176\u4e2d\uff0c\u9996\u5148\u83b7\u5f97\u91cc\u5c42 TaskManagerInner \u7684\u53ef\u53d8\u5f15\u7528\uff0c // \u901a\u8fc7 sync/up.rs \u91cc UPSafeCell\u7ed3\u6784\u4f53\u7684\u65b9\u6cd5 exclusive_access \u83b7\u53d6 // \u7136\u540e\u6839\u636e\u5176\u4e2d\u8bb0\u5f55\u7684\u5f53\u524d\u6b63\u5728\u6267\u884c\u7684\u5e94\u7528 ID \u5bf9\u5e94\u5728\u4efb\u52a1\u63a7\u5236\u5757\u6570\u7ec4 tasks \u4e2d\u4fee\u6539\u72b6\u6001 } fn find_next_task(&self) -> Option<usize> { let inner = self.inner.exclusive_access(); let current = inner.current_task; (current + 1..current + self.num_app + 1) .map(|id| id % self.num_app) .find(|id| { inner.tasks[*id].task_status == TaskStatus::Ready }) // TaskManagerInner \u7684 tasks \u662f\u4e00\u4e2a\u56fa\u5b9a\u7684\u4efb\u52a1\u63a7\u5236\u5757\u7ec4\u6210\u7684\u8868\uff0c\u957f\u5ea6\u4e3a num_app \uff0c // \u53ef\u4ee5\u7528\u4e0b\u6807 0~num_app-1 \u6765\u8bbf\u95ee\u5f97\u5230\u6bcf\u4e2a\u5e94\u7528\u7684\u63a7\u5236\u72b6\u6001\u3002 // \u6211\u4eec\u7684\u4efb\u52a1\u5c31\u662f\u627e\u5230 current_task \u540e\u9762\u7b2c\u4e00\u4e2a\u72b6\u6001\u4e3a Ready \u7684\u5e94\u7528\u3002 // \u56e0\u6b64\u4ece current_task + 1 \u5f00\u59cb\u5faa\u73af\u4e00\u5708\uff0c\u9700\u8981\u9996\u5148\u5bf9 num_app \u53d6\u6a21\u5f97\u5230\u5b9e\u9645\u7684\u4e0b\u6807\uff0c // \u7136\u540e\u68c0\u67e5\u5b83\u7684\u8fd0\u884c\u72b6\u6001 } fn run_next_task(&self) { if let Some(next) = self.find_next_task() { // \u5b83\u4f1a\u8c03\u7528 find_next_task \u65b9\u6cd5\u5c1d\u8bd5\u5bfb\u627e\u4e00\u4e2a\u8fd0\u884c\u72b6\u6001\u4e3a Ready \u7684\u5e94\u7528\u5e76\u8fd4\u56de\u5176 ID let mut inner = self.inner.exclusive_access(); // \u83b7\u53d6\u5168\u5c40\u4efb\u52a1\u7ba1\u7406\u5668\u7684 struct TaskManagerInner { // tasks: [TaskControlBlock; MAX_APP_NUM], // current_task: usize, // } let current = inner.current_task; // \u83b7\u53d6\u5f53\u524d\u4efb\u52a1\u7684 ID inner.tasks[next].task_status = TaskStatus::Running; // \u5c06\u4e0b\u4e00\u4e2a\u4efb\u52a1\u7684\u72b6\u6001\u6807\u6ce8\u4e3a Running inner.current_task = next; // \u5c06\u5f53\u524d\u4efb\u52a1 \u6807\u6ce8\u4e3a\u4e0b\u4e00\u4e2a\u4efb\u52a1\u7684 ID let current_task_cx_ptr = &mut inner.tasks[current].task_cx as *mut TaskContext; // \u83b7\u53d6\u5b58\u653e\u5f53\u524d\u4efb\u52a1\u4e0a\u4e0b\u6587\u7684 \u5730\u5740 let next_task_cx_ptr = &inner.tasks[next].task_cx as *const TaskContext; // \u83b7\u53d6\u5b58\u653e\u4e0b\u4e00\u4e2a\u4efb\u52a1\u4e0a\u4e0b\u6587\u7684 \u5730\u5740 drop(inner); // \u5728\u5b9e\u9645\u5207\u6362\u4e4b\u524d\u6211\u4eec\u9700\u8981\u624b\u52a8 drop \u6389\u6211\u4eec\u83b7\u53d6\u5230\u7684 TaskManagerInner // \u7684\u6765\u81ea UPSafeCell \u7684\u501f\u7528\u6807\u8bb0\u3002 // \u56e0\u4e3a\u4e00\u822c\u60c5\u51b5\u4e0b\u5b83\u662f\u5728\u51fd\u6570\u9000\u51fa\u4e4b\u540e\u624d\u4f1a\u88ab\u81ea\u52a8\u91ca\u653e\uff0c\u4ece\u800c TASK_MANAGER // \u7684 inner \u5b57\u6bb5\u5f97\u4ee5\u56de\u5f52\u5230\u672a\u88ab\u501f\u7528\u7684\u72b6\u6001\uff0c // \u4e4b\u540e\u53ef\u4ee5\u518d\u501f\u7528\u3002\u5982\u679c\u4e0d\u624b\u52a8 drop \u7684\u8bdd\uff0c\u7f16\u8bd1\u5668\u4f1a\u5728 __switch \u8fd4\u56de\u65f6\uff0c // \u4e5f\u5c31\u662f\u5f53\u524d\u5e94\u7528\u88ab\u5207\u6362\u56de\u6765\u7684\u65f6\u5019\u624d drop\uff0c\u8fd9\u671f\u95f4\u6211\u4eec\u90fd\u4e0d\u80fd\u4fee\u6539 TaskManagerInner \uff0c // \u751a\u81f3\u4e0d\u80fd\u8bfb\uff08\u56e0\u4e3a\u4e4b\u524d\u662f\u53ef\u53d8\u501f\u7528\uff09\uff0c\u4f1a\u5bfc\u81f4\u5185\u6838 panic \u62a5\u9519\u9000\u51fa\u3002 // \u6b63\u56e0\u5982\u6b64\uff0c\u6211\u4eec\u9700\u8981\u5728 __switch \u524d\u63d0\u65e9\u624b\u52a8 drop \u6389 inner // before this, we should drop local variables that must be dropped manually unsafe { __switch( current_task_cx_ptr, next_task_cx_ptr, ); } // \u5982\u679c\u80fd\u591f\u627e\u5230\u4e0b\u4e00\u4e2a\u53ef\u8fd0\u884c\u7684\u5e94\u7528\u7684\u8bdd\uff0c // \u6211\u4eec\u5c31\u53ef\u4ee5\u5206\u522b\u62ff\u5230\u5f53\u524d\u5e94\u7528 current_task_cx_ptr // \u548c\u5373\u5c06\u88ab\u5207\u6362\u5230\u7684\u5e94\u7528 next_task_cx_ptr \u7684\u4efb\u52a1\u4e0a\u4e0b\u6587\u6307\u9488\uff0c // \u7136\u540e\u8c03\u7528 __switch \u63a5\u53e3\u8fdb\u884c\u5207\u6362 // go back to user mode } else { // \u627e\u4e0d\u5230\u5c31 panic\uff0c\u6b64\u65f6 panic \u540e\u5c31\u4f1a\u9000\u51fa panic!(\"All applications completed!\"); } } } pub fn run_first_task() { TASK_MANAGER.run_first_task(); // \u5b83\u8c03\u7528\u4e86\u5168\u5c40\u4efb\u52a1\u7ba1\u7406\u5668 TASK_MANAGER \u7684 run_first_task \u65b9\u6cd5\u3002 } fn run_next_task() { TASK_MANAGER.run_next_task(); // \u5b83\u8c03\u7528\u4e86\u5168\u5c40\u4efb\u52a1\u7ba1\u7406\u5668 TASK_MANAGER \u7684 run_next_task \u65b9\u6cd5\u3002 } fn mark_current_suspended() { TASK_MANAGER.mark_current_suspended(); // \u5b83\u8c03\u7528\u4e86\u5168\u5c40\u4efb\u52a1\u7ba1\u7406\u5668 TASK_MANAGER \u7684 mark_current_suspended \u65b9\u6cd5\u3002 } fn mark_current_exited() { TASK_MANAGER.mark_current_exited(); // \u5b83\u8c03\u7528\u4e86\u5168\u5c40\u4efb\u52a1\u7ba1\u7406\u5668 TASK_MANAGER \u7684 mark_current_exited \u65b9\u6cd5\u3002 } pub fn suspend_current_and_run_next() { mark_current_suspended(); // \u5148\u4fee\u6539\u5f53\u524d\u5e94\u7528\u7684\u8fd0\u884c\u72b6\u6001 run_next_task(); // \u7136\u540e\u5c1d\u8bd5\u5207\u6362\u5230\u4e0b\u4e00\u4e2a\u5e94\u7528 } pub fn exit_current_and_run_next() { mark_current_exited(); // \u5148\u4fee\u6539\u5f53\u524d\u5e94\u7528\u7684\u8fd0\u884c\u72b6\u6001 run_next_task(); // \u7136\u540e\u5c1d\u8bd5\u5207\u6362\u5230\u4e0b\u4e00\u4e2a\u5e94\u7528 } os/src/trap/context.rs use riscv::register::sstatus::{Sstatus, self, SPP}; #[repr(C)] pub struct TrapContext { pub x: [usize; 32], pub sstatus: Sstatus, pub sepc: usize, } impl TrapContext { pub fn set_sp(&mut self, sp: usize) { self.x[2] = sp; } pub fn app_init_context(entry: usize, sp: usize) -> Self { let mut sstatus = sstatus::read(); sstatus.set_spp(SPP::User); let mut cx = Self { x: [0; 32], sstatus, sepc: entry, }; cx.set_sp(sp); cx } } os/src/trap/mod.rs mod context; use riscv::register::{ mtvec::TrapMode, stvec, scause::{ self, Trap, Exception, }, stval, }; use crate::syscall::syscall; use core::arch::global_asm; global_asm!(include_str!(\"trap.S\")); pub fn init() { extern \"C\" { fn __alltraps(); } unsafe { stvec::write(__alltraps as usize, TrapMode::Direct); } } #[no_mangle] pub fn trap_handler(cx: &mut TrapContext) -> &mut TrapContext { let scause = scause::read(); let stval = stval::read(); match scause.cause() { Trap::Exception(Exception::UserEnvCall) => { cx.sepc += 4; cx.x[10] = syscall(cx.x[17], [cx.x[10], cx.x[11], cx.x[12]]) as usize; } Trap::Exception(Exception::StoreFault) | Trap::Exception(Exception::StorePageFault) => { println!(\"[kernel] PageFault in application, bad addr = {:#x}, bad instruction = {:#x}, kernel killed it.\", stval, cx.sepc); panic!(\"[kernel] Cannot continue!\"); //run_next_app(); } Trap::Exception(Exception::IllegalInstruction) => { println!(\"[kernel] IllegalInstruction in application, kernel killed it.\"); panic!(\"[kernel] Cannot continue!\"); //run_next_app(); } _ => { panic!(\"Unsupported trap {:?}, stval = {:#x}!\", scause.cause(), stval); } } cx } pub use context::TrapContext; os/src/trap/trap.S .altmacro .macro SAVE_GP n sd x\\n, \\n*8(sp) .endm .macro LOAD_GP n ld x\\n, \\n*8(sp) .endm .section .text .globl __alltraps .globl __restore .align 2 __alltraps: csrrw sp, sscratch, sp # now sp->kernel stack, sscratch->user stack # allocate a TrapContext on kernel stack addi sp, sp, -34*8 # save general-purpose registers sd x1, 1*8(sp) # skip sp(x2), we will save it later sd x3, 3*8(sp) # skip tp(x4), application does not use it # save x5~x31 .set n, 5 .rept 27 SAVE_GP %n .set n, n+1 .endr # we can use t0/t1/t2 freely, because they were saved on kernel stack csrr t0, sstatus csrr t1, sepc sd t0, 32*8(sp) sd t1, 33*8(sp) # read user stack from sscratch and save it on the kernel stack csrr t2, sscratch sd t2, 2*8(sp) # set input argument of trap_handler(cx: &mut TrapContext) mv a0, sp call trap_handler __restore: # now sp->kernel stack(after allocated), sscratch->user stack # restore sstatus/sepc # \u5b83 \u4e0d\u518d\u9700\u8981 \u5728\u5f00\u5934 mv sp, a0 \u4e86\u3002\u56e0\u4e3a\u5728 __switch \u4e4b\u540e\uff0c # sp \u5c31\u5df2\u7ecf\u6b63\u786e\u6307\u5411\u4e86\u6211\u4eec\u9700\u8981\u7684 Trap \u4e0a\u4e0b\u6587\u5730\u5740 ld t0, 32*8(sp) ld t1, 33*8(sp) ld t2, 2*8(sp) csrw sstatus, t0 csrw sepc, t1 csrw sscratch, t2 # restore general-purpuse registers except sp/tp ld x1, 1*8(sp) ld x3, 3*8(sp) .set n, 5 .rept 27 LOAD_GP %n .set n, n+1 .endr # release TrapContext on kernel stack addi sp, sp, 34*8 # now sp->kernel stack, sscratch->user stack csrrw sp, sscratch, sp sret os/src/loader.rs use crate::trap::TrapContext; use crate::config::*; use core::arch::asm; #[repr(align(4096))] #[derive(Copy, Clone)] struct KernelStack { data: [u8; KERNEL_STACK_SIZE], } #[repr(align(4096))] #[derive(Copy, Clone)] struct UserStack { data: [u8; USER_STACK_SIZE], } static KERNEL_STACK: [KernelStack; MAX_APP_NUM] = [ KernelStack { data: [0; KERNEL_STACK_SIZE], }; MAX_APP_NUM ]; static USER_STACK: [UserStack; MAX_APP_NUM] = [ UserStack { data: [0; USER_STACK_SIZE], }; MAX_APP_NUM ]; impl KernelStack { fn get_sp(&self) -> usize { self.data.as_ptr() as usize + KERNEL_STACK_SIZE } pub fn push_context(&self, trap_cx: TrapContext) -> usize { let trap_cx_ptr = (self.get_sp() - core::mem::size_of::<TrapContext>()) as *mut TrapContext; unsafe { *trap_cx_ptr = trap_cx; } trap_cx_ptr as usize } } impl UserStack { fn get_sp(&self) -> usize { self.data.as_ptr() as usize + USER_STACK_SIZE } } fn get_base_i(app_id: usize) -> usize { APP_BASE_ADDRESS + app_id * APP_SIZE_LIMIT } // \u83b7\u53d6\u7b2c i \u4e2a\u5e94\u7528\u7684\u8d77\u59cb\u5730\u5740 pub fn get_num_app() -> usize { extern \"C\" { fn _num_app(); } unsafe { (_num_app as usize as *const usize).read_volatile() } } // \u83b7\u53d6 _num_app, \u5373\u5e94\u7528\u7684\u4e2a\u6570 pub fn load_apps() { extern \"C\" { fn _num_app(); } let num_app_ptr = _num_app as usize as *const usize; let num_app = get_num_app(); let app_start = unsafe { core::slice::from_raw_parts(num_app_ptr.add(1), num_app + 1) }; // clear i-cache first unsafe { asm!(\"fence.i\"); } // load apps for i in 0..num_app { let base_i = get_base_i(i); // \u83b7\u53d6\u7b2c i \u4e2a\u5e94\u7528\u7684\u8d77\u59cb\u5730\u5740 (base_i..base_i + APP_SIZE_LIMIT).for_each(|addr| unsafe { (addr as *mut u8).write_volatile(0) }); // \u5c06\u7528\u4e8e\u5b58\u653e\u7b2c i \u4e2a\u5e94\u7528\u7684\u5730\u5740\u533a\u95f4 \u7528 0 \u586b\u5145 let src = unsafe { core::slice::from_raw_parts(app_start[i] as *const u8, app_start[i + 1] - app_start[i]) }; // \u83b7\u53d6\u7b2c i \u4e2a\u5e94\u7528\u5728 .data \u6bb5\u4e2d\u7684\u8d77\u59cb\u5730\u5740 \u548c \u957f\u5ea6 let dst = unsafe { core::slice::from_raw_parts_mut(base_i as *mut u8, src.len()) }; // \u5c06\u521a\u624d\u7528 0 \u586b\u5145\u7684\u8d77\u59cb\u5730\u5740 \u548c \u5e94\u7528\u7684\u957f\u5ea6\u5c01\u88c5\u8d77\u6765 dst.copy_from_slice(src); // \u5c06\u7b2c i \u4e2a\u5e94\u7528 \u4ece .data \u6bb5\u52a0\u8f7d\u5230 \u4e0a\u9762\u5bf9\u5e94\u7684\u5730\u5740\u7a7a\u95f4 } } pub fn init_app_cx(app_id: usize) -> usize { // \u6784\u9020\u8be5\u4efb\u52a1\u7684 Trap \u4e0a\u4e0b\u6587\uff08\u5305\u62ec\u5e94\u7528\u5165\u53e3\u5730\u5740\u548c\u7528\u6237\u6808\u6307\u9488\uff09\u5e76\u5c06\u5176\u538b\u5165\u5230\u5185\u6838\u6808\u9876 KERNEL_STACK[app_id].push_context( TrapContext::app_init_context(get_base_i(app_id), USER_STACK[app_id].get_sp()), ) } os/src/main.rs #![no_std] #![no_main] #![feature(panic_info_message)] use core::arch::global_asm; #[macro_use] mod console; mod lang_items; mod sbi; mod syscall; mod trap; mod loader; mod config; mod task; mod sync; global_asm!(include_str!(\"entry.asm\")); global_asm!(include_str!(\"link_app.S\")); fn clear_bss() { extern \"C\" { fn sbss(); fn ebss(); } unsafe { core::slice::from_raw_parts_mut( sbss as usize as *mut u8, ebss as usize - sbss as usize, ).fill(0); } } #[no_mangle] pub fn rust_main() -> ! { clear_bss(); println!(\"[kernel] Hello, world!\"); trap::init(); loader::load_apps(); task::run_first_task(); panic!(\"Unreachable in rust_main!\"); } os/Makefile # Building TARGET := riscv64gc-unknown-none-elf MODE := release KERNEL_ELF := target/$(TARGET)/$(MODE)/os KERNEL_BIN := $(KERNEL_ELF).bin DISASM_TMP := target/$(TARGET)/$(MODE)/asm # BOARD BOARD ?= qemu SBI ?= rustsbi BOOTLOADER := ../bootloader/$(SBI)-$(BOARD).bin K210_BOOTLOADER_SIZE := 131072 # KERNEL ENTRY ifeq ($(BOARD), qemu) KERNEL_ENTRY_PA := 0x80200000 else ifeq ($(BOARD), k210) KERNEL_ENTRY_PA := 0x80020000 endif # Run K210 K210-SERIALPORT = /dev/ttyUSB0 K210-BURNER = ../tools/kflash.py # Binutils OBJDUMP := rust-objdump --arch-name=riscv64 OBJCOPY := rust-objcopy --binary-architecture=riscv64 # Disassembly DISASM ?= -x build: env switch-check $(KERNEL_BIN) switch-check: ifeq ($(BOARD), qemu) (which last-qemu) || (rm last-k210 -f && touch last-qemu && make clean) else ifeq ($(BOARD), k210) (which last-k210) || (rm last-qemu -f && touch last-k210 && make clean) endif env: rustup component add rust-src rustup component add llvm-tools-preview cargo install cargo-binutils --vers =0.3.3 rustup target add riscv64gc-unknown-none-elf $(KERNEL_BIN): kernel @$(OBJCOPY) $(KERNEL_ELF) --strip-all -O binary $@ kernel: @cd ../user && make build @echo Platform: $(BOARD) @cp src/linker-$(BOARD).ld src/linker.ld @cargo build --release @rm src/linker.ld clean: @cargo clean disasm: kernel @$(OBJDUMP) $(DISASM) $(KERNEL_ELF) | less disasm-vim: kernel @$(OBJDUMP) $(DISASM) $(KERNEL_ELF) > $(DISASM_TMP) @vim $(DISASM_TMP) @rm $(DISASM_TMP) run: run-inner run-inner: build ifeq ($(BOARD),qemu) @qemu-system-riscv64 \\ -machine virt \\ -nographic \\ -bios $(BOOTLOADER) \\ -device loader,file=$(KERNEL_BIN),addr=$(KERNEL_ENTRY_PA) else (which $(K210-BURNER)) || (cd .. && git clone https://github.com/sipeed/kflash.py.git && mv kflash.py tools) @cp $(BOOTLOADER) $(BOOTLOADER).copy @dd if=$(KERNEL_BIN) of=$(BOOTLOADER).copy bs=$(K210_BOOTLOADER_SIZE) seek=1 @mv $(BOOTLOADER).copy $(KERNEL_BIN) @sudo chmod 777 $(K210-SERIALPORT) python3 $(K210-BURNER) -p $(K210-SERIALPORT) -b 1500000 $(KERNEL_BIN) python3 -m serial.tools.miniterm --eol LF --dtr 0 --rts 0 --filter direct $(K210-SERIALPORT) 115200 endif debug: build @tmux new-session -d \\ \"qemu-system-riscv64 -machine virt -nographic -bios $(BOOTLOADER) -device loader,file=$(KERNEL_BIN),addr=$(KERNEL_ENTRY_PA) -s -S\" && \\ tmux split-window -h \"riscv64-unknown-elf-gdb -ex 'file $(KERNEL_ELF)' -ex 'set arch riscv:rv64' -ex 'target remote localhost:1234'\" && \\ tmux -2 attach-session -d .PHONY: build env kernel clean disasm disasm-vim run-inner switch-check \u5728 user \u6587\u4ef6\u5939\u4e0b user/.cargo/config [build] target = \"riscv64gc-unknown-none-elf\" [target.riscv64gc-unknown-none-elf] rustflags = [ \"-Clink-args=-Tsrc/linker.ld\", ] user/Cargo.toml [package] name = \"user_lib\" version = \"0.1.0\" authors = [\"Yifan Wu <shinbokuow@163.com>\"] edition = \"2018\" # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html [dependencies] user/build.py import os base_address = 0x80400000 step = 0x20000 linker = 'src/linker.ld' app_id = 0 apps = os.listdir('src/bin') # \u5f97\u5230\u4e00\u4e2a\u5217\u8868\uff0c \u91cc\u9762\u662f \u6587\u4ef6\u540d apps.sort() for app in apps: app = app[:app.find('.')] # app \u53d8\u6210\u4e0d\u5e26\u540e\u7f00\u7684\u6587\u4ef6\u540d lines = [] lines_before = [] with open(linker, 'r') as f: for line in f.readlines(): lines_before.append(line) line = line.replace(hex(base_address), hex(base_address+step*app_id)) lines.append(line) with open(linker, 'w+') as f: f.writelines(lines) # \u627e\u5230 src/linker.ld \u4e2d\u7684 BASE_ADDRESS = 0x80400000; # \u8fd9\u4e00\u884c\uff0c\u5e76\u5c06\u540e\u9762\u7684\u5730\u5740\u66ff\u6362\u4e3a\u548c\u5f53\u524d\u5e94\u7528\u5bf9\u5e94\u7684\u4e00\u4e2a\u5730\u5740 os.system('cargo build --bin %s --release' % app) # \u4f7f\u7528 --bin \u53c2\u6570\u6765\u53ea\u6784\u5efa\u67d0\u4e00\u4e2a\u5e94\u7528 # \u90a3\u5c31\u662f\u5bf9\u6bcf\u4e2a\u5e94\u7528\u5206\u522b\u8fdb\u884c\u7f16\u8bd1 \u6539\u53d8\u5176 \u8d77\u59cb\u5730\u5740 print('[build.py] application %s start with address %s' %(app, hex(base_address+step*app_id))) with open(linker, 'w+') as f: f.writelines(lines_before) # \u5c06 linker.ld \u590d\u539f\uff0c \u73b0\u5728\u7684 base_address = 0x80400000+step*app_id # \u6062\u590d\u4e3a 0x80400000 app_id = app_id + 1 user/src/console.rs use core::fmt::{self, Write}; use super::write; struct Stdout; const STDOUT: usize = 1; impl Write for Stdout { fn write_str(&mut self, s: &str) -> fmt::Result { write(STDOUT, s.as_bytes()); Ok(()) } } pub fn print(args: fmt::Arguments) { Stdout.write_fmt(args).unwrap(); } #[macro_export] macro_rules! print { ($fmt: literal $(, $($arg: tt)+)?) => { $crate::console::print(format_args!($fmt $(, $($arg)+)?)); } } #[macro_export] macro_rules! println { ($fmt: literal $(, $($arg: tt)+)?) => { $crate::console::print(format_args!(concat!($fmt, \"\\n\") $(, $($arg)+)?)); } } user/src/lang_items.rs #[panic_handler] fn panic_handler(panic_info: &core::panic::PanicInfo) -> ! { let err = panic_info.message().unwrap(); if let Some(location) = panic_info.location() { println!(\"Panicked at {}:{}, {}\", location.file(), location.line(), err); } else { println!(\"Panicked: {}\", err); } loop {} } user/src/lib.rs #![no_std] #![feature(linkage)] #![feature(panic_info_message)] #[macro_use] pub mod console; mod syscall; mod lang_items; #[no_mangle] #[link_section = \".text.entry\"] pub extern \"C\" fn _start() -> ! { clear_bss(); exit(main()); panic!(\"unreachable after sys_exit!\"); } #[linkage = \"weak\"] #[no_mangle] fn main() -> i32 { panic!(\"Cannot find main!\"); } fn clear_bss() { extern \"C\" { fn start_bss(); fn end_bss(); } (start_bss as usize..end_bss as usize).for_each(|addr| { unsafe { (addr as *mut u8).write_volatile(0); } }); } use syscall::*; pub fn write(fd: usize, buf: &[u8]) -> isize { sys_write(fd, buf) } pub fn exit(exit_code: i32) -> isize { sys_exit(exit_code) } pub fn yield_() -> isize { sys_yield() } user/src/linker.ld OUTPUT_ARCH(riscv) ENTRY(_start) BASE_ADDRESS = 0x80400000; SECTIONS { . = BASE_ADDRESS; .text : { *(.text.entry) *(.text .text.*) } .rodata : { *(.rodata .rodata.*) *(.srodata .srodata.*) } .data : { *(.data .data.*) *(.sdata .sdata.*) } .bss : { start_bss = .; *(.bss .bss.*) *(.sbss .sbss.*) end_bss = .; } /DISCARD/ : { *(.eh_frame) *(.debug*) } } user/src/syscall.rs use core::arch::asm; const SYSCALL_WRITE: usize = 64; const SYSCALL_EXIT: usize = 93; const SYSCALL_YIELD: usize = 124; fn syscall(id: usize, args: [usize; 3]) -> isize { let mut ret: isize; unsafe { asm!( \"ecall\", inlateout(\"x10\") args[0] => ret, in(\"x11\") args[1], in(\"x12\") args[2], in(\"x17\") id ); } ret } pub fn sys_write(fd: usize, buffer: &[u8]) -> isize { syscall(SYSCALL_WRITE, [fd, buffer.as_ptr() as usize, buffer.len()]) } pub fn sys_exit(exit_code: i32) -> isize { syscall(SYSCALL_EXIT, [exit_code as usize, 0, 0]) } pub fn sys_yield() -> isize { syscall(SYSCALL_YIELD, [0, 0, 0]) } user/src/lib.rs #![no_std] #![feature(linkage)] #![feature(panic_info_message)] #[macro_use] pub mod console; mod syscall; mod lang_items; #[no_mangle] #[link_section = \".text.entry\"] pub extern \"C\" fn _start() -> ! { clear_bss(); exit(main()); panic!(\"unreachable after sys_exit!\"); } #[linkage = \"weak\"] #[no_mangle] fn main() -> i32 { panic!(\"Cannot find main!\"); } fn clear_bss() { extern \"C\" { fn start_bss(); fn end_bss(); } (start_bss as usize..end_bss as usize).for_each(|addr| { unsafe { (addr as *mut u8).write_volatile(0); } }); } use syscall::*; pub fn write(fd: usize, buf: &[u8]) -> isize { sys_write(fd, buf) } pub fn exit(exit_code: i32) -> isize { sys_exit(exit_code) } pub fn yield_() -> isize { sys_yield() } // yield \u662f Rust \u7684\u5173\u952e\u5b57\uff0c\u56e0\u6b64\u6211\u4eec\u53ea\u80fd\u5c06\u5e94\u7528\u76f4\u63a5\u8c03\u7528\u7684\u63a5\u53e3\u547d\u540d\u4e3a yield_ user/src/bin/00write_a.rs #![no_std] #![no_main] #[macro_use] extern crate user_lib; use user_lib::yield_; const WIDTH: usize = 10; const HEIGHT: usize = 5; #[no_mangle] fn main() -> i32 { for i in 0..HEIGHT { for _ in 0..WIDTH { print!(\"A\"); } println!(\" [{}/{}]\", i + 1, HEIGHT); yield_(); } println!(\"Test write_a OK!\"); 0 } user/src/bin/00write_b.rs #![no_std] #![no_main] #[macro_use] extern crate user_lib; use user_lib::yield_; const WIDTH: usize = 10; const HEIGHT: usize = 2; #[no_mangle] fn main() -> i32 { for i in 0..HEIGHT { for _ in 0..WIDTH { print!(\"B\"); } println!(\" [{}/{}]\", i + 1, HEIGHT); yield_(); } println!(\"Test write_b OK!\"); 0 } user/src/bin/00write_c.rs #![no_std] #![no_main] #[macro_use] extern crate user_lib; use user_lib::yield_; const WIDTH: usize = 10; const HEIGHT: usize = 3; #[no_mangle] fn main() -> i32 { for i in 0..HEIGHT { for _ in 0..WIDTH { print!(\"C\"); } println!(\" [{}/{}]\", i + 1, HEIGHT); yield_(); } println!(\"Test write_c OK!\"); 0 } user/Makefile TARGET := riscv64gc-unknown-none-elf MODE := release APP_DIR := src/bin TARGET_DIR := target/$(TARGET)/$(MODE) APPS := $(wildcard $(APP_DIR)/*.rs) ELFS := $(patsubst $(APP_DIR)/%.rs, $(TARGET_DIR)/%, $(APPS)) BINS := $(patsubst $(APP_DIR)/%.rs, $(TARGET_DIR)/%.bin, $(APPS)) OBJDUMP := rust-objdump --arch-name=riscv64 OBJCOPY := rust-objcopy --binary-architecture=riscv64 elf: $(APPS) @python3 build.py binary: elf $(foreach elf, $(ELFS), $(OBJCOPY) $(elf) --strip-all -O binary $(patsubst $(TARGET_DIR)/%, $(TARGET_DIR)/%.bin, $(elf));) build: binary clean: @cargo clean .PHONY: elf binary build clean \u6267\u884c\u6d41\u7a0b os/src/main.rs - \u5bfc\u5165 entry.asm \u8bbe\u7f6e\u51fd\u6570\u6808\uff0c \u8df3\u8f6c\u5230rust_main \u5bfc\u5165 link_app.S \u8fd9\u91cc\u5168\u662f\u6570\u636e\u6bb5\uff0c \u53ef\u6267\u884c\u6587\u4ef6\u5728\u90e8\u5206\u6570\u636e\u6bb5\u4e2d \u8c03\u7528 clear_bass \u51fd\u6570\uff0c \u6e05\u9664 \u9664 .bss.stack \u4ee5\u5916\u7684 .bss \u6bb5 \u8c03\u7528 println! \u6253\u5370 [kernel] Hello, world! , \u6b64\u65f6\u5904\u4e8e\u5185\u6838\u6001 \u8c03\u7528 trap::init os/src/trap/mod.rs \u6211\u4eec\u9700\u8981\u4fee\u6539stvec \u5bc4\u5b58\u5668\u6765\u6307\u5411\u6b63\u786e\u7684Trap\u5904\u7406\u5165\u53e3\u70b9 \u5c06stvec\u8bbe\u7f6e\u4e3aDirect\u6a21\u5f0f\u6307\u5411\u5b83\u7684\u5730\u5740 \u6ce8\u610f\uff1a\u7531\u4e8e\u524d\u9762\u6709\u5bfc\u5165 trap.S\uff0c \u6240\u6709\u8fd9\u91cc\u77e5\u9053 Trap\u7684\u5904\u7406\u5165\u53e3 \u5373 __alltraps \u8c03\u7528 loader::load_apps os/src/loader.rs \u8c03\u7528 get_num_app \u83b7\u53d6\u5e94\u7528\u4e2a\u6570 \u83b7\u53d6\u7b2c\u4e00\u4e2a\u7a0b\u5e8f\u7684\u5165\u53e3\u5730\u5740 \u5237\u65b0\u6307\u4ee4\u7f13\u51b2\u533a \u8c03\u7528 get_base_i \u83b7\u53d6 \u6bcf\u4e2a\u5e94\u7528\u7a0b\u5e8f\u7684\u8d77\u59cb\u5730\u5740 \u5c06\u6bcf\u4e2a\u5e94\u7528\u8d77\u59cb\u5730\u5740\u5230 \u5e94\u7528\u7a7a\u95f4\u9650\u5236\u8303\u56f4\u7684\u5730\u5740\u533a\u95f4 \u7528 0 \u586b\u5145 \u83b7\u53d6\u6bcf\u4e2a\u5e94\u7528\u5728 .data \u6bb5\u7684\u8d77\u59cb\u5730\u5740\u548c\u5927\u5c0f \u548c \u5728\u5c06\u4f1a\u653e\u7f6e\u8be5\u7a0b\u5e8f\u7684\u8d77\u59cb\u5730\u5740\u548c\u7a0b\u5e8f\u5927\u5c0f \u8c03\u7528 copy_from_slice \u5c06\u7a0b\u5e8f\u4ece .data \u6bb5\u590d\u5236\u5230 \u76f8\u5e94\u7684\u5730\u5740\u533a\u95f4 \u81f3\u6b64\uff0c\u7a0b\u5e8f\u52a0\u8f7d\u5b8c\u6bd5 os/src/main.rs - \u8c03\u7528 task \u6a21\u5757\u7684 run_first_task os/src/task/mod.rs \u9996\u5148\uff0c\u9759\u6001\u52a0\u8f7d\u4e00\u4e2a\u5168\u5c40\u7684\u4efb\u52a1\u7ba1\u7406\u5668 TaskManager \u7ed3\u6784 \u7684\u5b9e\u4f8b TASK_MANAGER,\u5305\u542b num_app \u548c inner inner \u5305\u62ec \u6570\u7ec4 tasks \u548c current_task \u6570\u7ec4 tasks \u662f TaskControlBlock \u7ed3\u6784\u7684\u6570\u7ec4 TaskControlBlock \u7ed3\u6784\u4f53 \u5305\u62ec \u4efb\u52a1\u72b6\u6001 task_status \u548c \u4efb\u52a1\u4e0a\u4e0b\u6587 TaskContext TaskContext \u5305\u542b \u90a314\u4e2a\u5bc4\u5b58\u5668 \u5bf9\u4efb\u52a1\u6570\u7ec4\u8fdb\u884c\u521d\u59cb\u5316\uff0c\u5c06\u6bcf\u4e2a\u4efb\u52a1\u90fd\u8fdb\u884c\u521d\u59cb\u5316 \u5bf9\u4efb\u52a1\u4e0a\u4e0b\u6587\u8c03\u7528 zero_init \u8fdb\u884c\u521d\u59cb\u5316\uff0c\u5373\u5c06\u8fd9 14 \u4e2a\u5bc4\u5b58\u5668\u90fd\u521d\u59cb\u5316\u4e3a 0 \u5c06\u4efb\u52a1\u7684\u72b6\u6001 \u8bbe\u7f6e\u4e3a UnInit, \u5373\u672a\u521d\u59cb\u5316 \u5bf9\u4e8e\u6bcf\u4e2a\u4efb\u52a1\uff0c\u5148\u8c03\u7528 init_app_cx, \u6784\u9020\u8be5\u4efb\u52a1\u7684 Trap \u4e0a\u4e0b\u6587 \u5728 os/src/loader.rs \u83b7\u53d6\u6bcf\u4e2a\u5e94\u7528\u7684 \u8d77\u59cb\u5730\u5740 \u548c \u6808\u9488 \u521d\u59cb\u5316\u5b83\u7684 Trap \u4e0a\u4e0b\u6587 \u5728 os/src/trap/context.rs \u83b7\u53d6\u5f53\u524d\u7684 sstatus \u5e76\u5b58\u653e\u5728\u7ed3\u6784\u4e2d \u5c06\u8fd9\u4e2a sstatus \u7ed3\u6784\u7684 SPP\u7f6e\u4f4d User \u5c06\u901a\u7528\u5bc4\u5b58\u5668 \u5168\u7f6e\u4e3a 0 \u5c06 sepc \u8bbe\u4e3a\u4f20\u5165\u7684\u5e94\u7528\u7684\u5730\u5740 entry \u5c06 Trap\u4e0a\u4e0b\u6587\u7684 sp \u7f6e\u4e3a \u4f20\u5165\u7684 \u5185\u6838\u6808\u5730\u5740 sp \u8fd4\u56de Trap \u4e0a\u4e0b\u6587 \u5c06 Trap \u4e0a\u4e0b\u6587 push \u5230\u5185\u6838\u6808\u4e2d \u8fd4\u56de\u4e00\u4e2a \u6267\u884c\u6539\u4e0a\u4e0b\u6587\u7684 \u6307\u9488 \u5c06\u6307\u5411 Trap \u4e0a\u4e0b\u6587\u7684 \u6307\u9488 \u4f20\u5165\u5230 goto_restoren \u51fd\u6570\u4e2d \u7528\u5b83\u521d\u59cb\u5316\u4efb\u52a1\u4e0a\u4e0b\u6587 TaskContext \u5c06\u4efb\u52a1\u4e0a\u4e0b\u6587\u8fd4\u56de\u7ed9\u6bcf\u4e2a\u4efb\u52a1 \u5c06\u6bcf\u4e2a\u4efb\u52a1\u90fd\u7f6e\u4e3a Ready \u6700\u540e\uff0c\u83b7\u5f97\u4e00\u4e2a\u4efb\u52a1\u7ba1\u7406\u5668\uff0c\u5b83\u5305\u542b \u4efb\u52a1\u6570\uff0c\u4efb\u52a1\u6570\u7ec4\uff0c\u5f53\u524d\u4efb\u52a1\u7684\u7f16\u53f7 \u8fd9\u6837\uff0c\u9759\u6001\u52a0\u8f7d\u5668\u7684\u4efb\u52a1\u5b8c\u6210 \u8c03\u7528 run_first_task \u5c06\u7b2c\u4e00\u4e2a\u4efb\u52a1\u7684\u72b6\u6001\u7f6e\u4e3a Running \u521b\u5efa\u4e00\u4e2a\u6307\u9488 \u6307\u5411 \u7b2c\u4e00\u4e2a\u4efb\u52a1\u7684\u4efb\u52a1\u4e0a\u4e0b\u6587 \u6784\u9020\u4e00\u4e2a \u53ea\u6709\u4efb\u52a1\u4e0a\u4e0b\u6587\u7ed3\u6784\u800c\u65e0\u771f\u6b63\u5185\u5bb9\u7684 \u4efb\u52a1\u4e0a\u4e0b\u6587 \u5c06 \u8fd9\u4e24\u4e2a\u4e0a\u4e0b\u6587\u7684 \u6307\u9488\u9001\u7ed9 \u5207\u6362\u51fd\u6570 _switch _switch \u51fd\u6570\u5728\u5c06\u4ed6\u4eec\u9001\u5230 \u6c47\u7f16\u51fd\u6570 _switch \u4e2d \u4fdd\u5b58\u5f53\u524d\u4efb\u52a1\u7684 \u6808\u6bb5\uff0c \u4fdd\u5b58\u5f53\u524d \u4efb\u52a1\u4e0a\u4e0b\u6587\uff0c \u6062\u590d\u4e0b\u4e00\u4e2a\u4efb\u52a1\u4e0a\u4e0b\u6587\uff0c \u6062\u590d\u4e0b\u4e00\u4e2a\u4efb\u52a1\u7684 \u6808\u6bb5 ret \u8fd4\u56de\u5230 \u4e0b\u4e00\u4e2a\u4efb\u52a1\uff0c\u8fdb\u5165\u5230\u7528\u6237\u6001 user/src/bin/00write_a.rs - \u8fd0\u884c\u5b8c\u7b2c\u4e00\u6b21\u5faa\u73af\uff0c \u8c03\u7528 yield_ - \u8c03\u7528 user/src/lib.rs \u7684yield \u63a5\u53e3 - \u8c03\u7528 user/src/syscall.rs \u4e2d\u7684 sys_yield - syscall \u7cfb\u7edf\u8c03\u7528 \u8fdb\u884c Trap \u9677\u5165 - \u8df3\u8f6c\u5230 trap.S \u4e2d\u7684 __alltraps \u4e2d - \u5728\u5185\u6838\u6808\u4e2d\u4fdd\u5b58\u5f53\u524d\u4e0a\u4e0b\u6587 - call trap_handler \u8df3\u8f6c\u7684 trap_handler - \u89e6\u53d1 Trap \u7684 \u539f\u56e0\u662f\u6765\u81ea U\u6001\u7684 \u7cfb\u7edf\u8c03\u7528 - Trap\u4e0a\u4e0b\u6587\u7684 sepc \u5bc4\u5b58\u5668 +4 \uff0c\u6307\u5411syscall \u7684\u4e0b\u4e00\u6761\u6307\u4ee4 - \u4e0b\u4e00\u6761\u6307\u4ee4\u662f ret - \u518d\u6b64syscall\uff0c\u8fdb\u5165\u5185\u6838\u6001\u4e2d\u7cfb\u7edf\u8c03\u7528\u7684\u5904\u7406 - \u5728 os/src/syscall/mod.rs \u4e2d\u53c8\u8c03\u7528 sys_yield - os/src/syscall/process.rs \u4e2d sys_yield \u8c03\u7528 suspend_current_and_run_next - \u5728 os/src/task/mod.rs \u4e2d - \u8c03\u7528 mark_current_suspended - \u5c06\u5f53\u524d\u4efb\u52a1\u7684\u72b6\u6001 task_status \u7f6e\u4e3a Ready - \u8c03\u7528 run_next_task - \u8c03\u7528 find_next_task, \u52a0\u4e00\u518d mod \u5faa\u73af\uff0c\u627e\u5224\u65ad\u4efb\u52a1\u7684\u72b6\u6001\u662f\u5426\u4e3a Ready, - \u5982\u679c\u627e\u5230\u4e0b\u4e00\u4e2a\u4efb\u52a1\uff0c\u5c06\u4e0b\u4e00\u4e2a\u4efb\u52a1\u7684\u72b6\u6001\u7f6e\u4e3a Running - \u83b7\u53d6\u6307\u5411 \u5f53\u524d\u4efb\u52a1 \u548c \u4e0b\u4e00\u4e2a\u4efb\u52a1 \u7684\u5730\u5740\u7684\u6307\u9488 - \u8c03\u7528 _switch \u51fd\u6570 - _switch \u4fdd\u5b58\u6062\u590d\u4e0a\u4e0b\u6587\u540e\uff0cret\uff0c\u8fd4\u56de\u5230\u7528\u6237\u6001 \u5f53\u5e94\u7528\u5b8c\u6210\u4e86\uff0c \u6253\u5370 Test write_a OK! user/src/lib.rs \u8c03\u7528 exit\uff0cexit \u8c03\u7528 sys_exit user/src/syscall.rs \u4e2d sys_exit \u8fdb\u884c \u7cfb\u7edf\u8c03\u7528 syscall , \u5f15\u53d1 ecall \u8df3\u8f6c\u5230 __alltraps \u8df3\u8f6c\u5230 os/src/syscall/mod.rs \u4e2d\u7684 sys_exit os/src/syscall/process.rs \u4e2d\u7684 sys_exit \u5148\u6253\u5370 [kernel] Application exited with code 0 \u7136\u540e\u8c03\u7528 exit_current_and_run_next \u518d\u6b21\u8fd4\u56de\u5230 os/src/task/mod.rs \u5148\u5c06 \u5f53\u524d\u4efb\u52a1\u7684\u72b6\u6001\u6807\u8bb0\u4e3a Exited \u518d\u8c03\u7528 run_next_task \u5982\u679c\u6240\u6709\u7684\u4efb\u52a1\u90fd\u5b8c\u6210\u4e86\uff0c\u5c31 panic \u6253\u5370\u51fa All applications completed! \u6253\u5370 panic \u7684\u4f4d\u7f6e \u8c03\u7528 shutdown \u5173\u673a","title":"\u5b9e\u73b0\u591a\u9053\u7a0b\u5e8f\u4e0e\u534f\u4f5c\u5f0f\u8c03\u7528"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%8D%8F%E4%BD%9C%E5%BC%8F%E8%B0%83%E7%94%A8/#_1","text":"","title":"\u5b9e\u73b0\u591a\u9053\u7a0b\u5e8f\u4e0e\u534f\u4f5c\u5f0f\u8c03\u7528"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%8D%8F%E4%BD%9C%E5%BC%8F%E8%B0%83%E7%94%A8/#_2","text":"\u5206\u65f6\u591a\u4efb\u52a1\u7684\u4e3a\u4f8b ./os/src Rust 18 Files 511 Lines Assembly 3 Files 82 Lines \u251c\u2500\u2500 bootloader \u2502 \u251c\u2500\u2500 rustsbi-k210.bin \u2502 \u2514\u2500\u2500 rustsbi-qemu.bin \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 os \u2502 \u251c\u2500\u2500 build.rs \u2502 \u251c\u2500\u2500 Cargo.toml \u2502 \u251c\u2500\u2500 Makefile \u2502 \u2514\u2500\u2500 src \u2502 \u251c\u2500\u2500 batch.rs(\u79fb\u9664\uff1a\u529f\u80fd\u5206\u522b\u62c6\u5206\u5230 loader \u548c task \u4e24\u4e2a\u5b50\u6a21\u5757) \u2502 \u251c\u2500\u2500 config.rs(\u65b0\u589e\uff1a\u4fdd\u5b58\u5185\u6838\u7684\u4e00\u4e9b\u914d\u7f6e) \u2502 \u251c\u2500\u2500 console.rs \u2502 \u251c\u2500\u2500 entry.asm \u2502 \u251c\u2500\u2500 lang_items.rs \u2502 \u251c\u2500\u2500 link_app.S \u2502 \u251c\u2500\u2500 linker-k210.ld \u2502 \u251c\u2500\u2500 linker-qemu.ld \u2502 \u251c\u2500\u2500 loader.rs(\u65b0\u589e\uff1a\u5c06\u5e94\u7528\u52a0\u8f7d\u5230\u5185\u5b58\u5e76\u8fdb\u884c\u7ba1\u7406) \u2502 \u251c\u2500\u2500 main.rs(\u4fee\u6539\uff1a\u4e3b\u51fd\u6570\u8fdb\u884c\u4e86\u4fee\u6539) \u2502 \u251c\u2500\u2500 sbi.rs(\u4fee\u6539\uff1a\u5f15\u5165\u65b0\u7684 sbi call set_timer) \u2502 \u251c\u2500\u2500 sync \u2502 \u2502 \u251c\u2500\u2500 mod.rs \u2502 \u2502 \u2514\u2500\u2500 up.rs \u2502 \u251c\u2500\u2500 syscall(\u4fee\u6539\uff1a\u65b0\u589e\u82e5\u5e72 syscall) \u2502 \u2502 \u251c\u2500\u2500 fs.rs \u2502 \u2502 \u251c\u2500\u2500 mod.rs \u2502 \u2502 \u2514\u2500\u2500 process.rs \u2502 \u251c\u2500\u2500 task(\u65b0\u589e\uff1atask \u5b50\u6a21\u5757\uff0c\u4e3b\u8981\u8d1f\u8d23\u4efb\u52a1\u7ba1\u7406) \u2502 \u2502 \u251c\u2500\u2500 context.rs(\u5f15\u5165 Task \u4e0a\u4e0b\u6587 TaskContext) \u2502 \u2502 \u251c\u2500\u2500 mod.rs(\u5168\u5c40\u4efb\u52a1\u7ba1\u7406\u5668\u548c\u63d0\u4f9b\u7ed9\u5176\u4ed6\u6a21\u5757\u7684\u63a5\u53e3) \u2502 \u2502 \u251c\u2500\u2500 switch.rs(\u5c06\u4efb\u52a1\u5207\u6362\u7684\u6c47\u7f16\u4ee3\u7801\u89e3\u91ca\u4e3a Rust \u63a5\u53e3 __switch) \u2502 \u2502 \u251c\u2500\u2500 switch.S(\u4efb\u52a1\u5207\u6362\u7684\u6c47\u7f16\u4ee3\u7801) \u2502 \u2502 \u2514\u2500\u2500 task.rs(\u4efb\u52a1\u63a7\u5236\u5757 TaskControlBlock \u548c\u4efb\u52a1\u72b6\u6001 TaskStatus \u7684\u5b9a\u4e49) \u2502 \u251c\u2500\u2500 timer.rs(\u65b0\u589e\uff1a\u8ba1\u65f6\u5668\u76f8\u5173) \u2502 \u2514\u2500\u2500 trap \u2502 \u251c\u2500\u2500 context.rs \u2502 \u251c\u2500\u2500 mod.rs(\u4fee\u6539\uff1a\u65f6\u949f\u4e2d\u65ad\u76f8\u5e94\u5904\u7406) \u2502 \u2514\u2500\u2500 trap.S \u251c\u2500\u2500 README.md \u251c\u2500\u2500 rust-toolchain \u251c\u2500\u2500 tools \u2502 \u251c\u2500\u2500 kflash.py \u2502 \u251c\u2500\u2500 LICENSE \u2502 \u251c\u2500\u2500 package.json \u2502 \u251c\u2500\u2500 README.rst \u2502 \u2514\u2500\u2500 setup.py \u2514\u2500\u2500 user \u251c\u2500\u2500 build.py(\u65b0\u589e\uff1a\u4f7f\u7528 build.py \u6784\u5efa\u5e94\u7528\u4f7f\u5f97\u5b83\u4eec\u5360\u7528\u7684\u7269\u7406\u5730\u5740\u533a\u95f4\u4e0d\u76f8\u4ea4) \u251c\u2500\u2500 Cargo.toml \u251c\u2500\u2500 Makefile(\u4fee\u6539\uff1a\u4f7f\u7528 build.py \u6784\u5efa\u5e94\u7528) \u2514\u2500\u2500 src \u251c\u2500\u2500 bin(\u4fee\u6539\uff1a\u6362\u6210\u7b2c\u4e09\u7ae0\u6d4b\u4f8b) \u2502 \u251c\u2500\u2500 00power_3.rs \u2502 \u251c\u2500\u2500 01power_5.rs \u2502 \u251c\u2500\u2500 02power_7.rs \u2502 \u2514\u2500\u2500 03sleep.rs \u251c\u2500\u2500 console.rs \u251c\u2500\u2500 lang_items.rs \u251c\u2500\u2500 lib.rs \u251c\u2500\u2500 linker.ld \u2514\u2500\u2500 syscall.rs","title":"\u7b2c\u4e09\u7ae0\u4ee3\u7801\u6811"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%8D%8F%E4%BD%9C%E5%BC%8F%E8%B0%83%E7%94%A8/#_3","text":"\u4e0d\u662f\u6240\u6709\u7684\u8d44\u6e90\u90fd\u9700\u8981\u88ab\u4fdd\u5b58\uff0c\u4e8b\u5b9e\u4e0a\u53ea\u6709\u90a3\u4e9b\u5bf9\u4e8e\u7a0b\u5e8f\u63a5\u4e0b\u6765\u7684\u6b63\u786e\u6267\u884c\u4ecd\u7136\u6709\u7528\uff0c\u4e14\u5728\u5b83\u88ab\u5207\u6362\u51fa\u53bb\u7684\u65f6\u5019\u6709\u88ab\u8986\u76d6\u98ce\u9669\u7684\u90a3\u4e9b\u8d44\u6e90\u624d\u6709\u88ab\u4fdd\u5b58\u7684\u4ef7\u503c\u3002\u8fd9\u4e9b\u9700\u8981\u4fdd\u5b58\u4e0e\u6062\u590d\u7684\u8d44\u6e90\u88ab\u79f0\u4e3a \u4efb\u52a1\u4e0a\u4e0b\u6587 (Task Context) \u672c\u8282\u5b9e\u73b0\u4e00\u4e2a\u652f\u6301 \u628a\u591a\u4e2a\u5e94\u7528\u7684\u4ee3\u7801\u548c\u6570\u636e\u653e\u7f6e\u5230\u5185\u5b58\u4e2d\uff0c\u5e76\u80fd\u591f\u6267\u884c\u6bcf\u4e00\u4e2a\u5e94\u7528 \u5728\u5e94\u7528\u7a0b\u5e8f\u53d1\u51fa sys_yeild \u7cfb\u7edf\u8c03\u7528\u65f6\uff0c\u80fd\u5207\u6362\u5e94\u7528\uff0c\u4ece\u800c\u8ba9CPU\u5c3d\u53ef\u80fd\u5fd9\u4e8e\u6bcf\u4e2a\u5e94\u7528\u7684\u8ba1\u7b97\u4efb\u52a1 \u63d0\u9ad8\u4efb\u52a1\u8c03\u5ea6\u7684\u7075\u6d3b\u6027 \u548c CPU \u7684\u4f7f\u7528\u6548\u7387","title":"\u672c\u8282\u7684\u4efb\u52a1"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%8D%8F%E4%BD%9C%E5%BC%8F%E8%B0%83%E7%94%A8/#_4","text":"","title":"\u672c\u8282\u6587\u4ef6\u89e3\u6790"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%8D%8F%E4%BD%9C%E5%BC%8F%E8%B0%83%E7%94%A8/#bootloader","text":"","title":"\u5728bootloader \u6587\u4ef6\u5939\u4e0b"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%8D%8F%E4%BD%9C%E5%BC%8F%E8%B0%83%E7%94%A8/#rustsbi-qemubin","text":"","title":"rustsbi-qemu.bin"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%8D%8F%E4%BD%9C%E5%BC%8F%E8%B0%83%E7%94%A8/#os","text":"","title":"\u5728 os \u6587\u4ef6\u5939\u4e0b"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%8D%8F%E4%BD%9C%E5%BC%8F%E8%B0%83%E7%94%A8/#oscargoconfig","text":"[build] target = \"riscv64gc-unknown-none-elf\" [target.riscv64gc-unknown-none-elf] rustflags = [ \"-Clink-arg=-Tsrc/linker.ld\", \"-Cforce-frame-pointers=yes\" ]","title":"os/.cargo/config"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%8D%8F%E4%BD%9C%E5%BC%8F%E8%B0%83%E7%94%A8/#osbuildrs","text":"use std::io::{Result, Write}; use std::fs::{File, read_dir}; fn main() { println!(\"cargo:rerun-if-changed=../user/src/\"); println!(\"cargo:rerun-if-changed={}\", TARGET_PATH); insert_app_data().unwrap(); } static TARGET_PATH: &str = \"../user/target/riscv64gc-unknown-none-elf/release/\"; fn insert_app_data() -> Result<()> { let mut f = File::create(\"src/link_app.S\").unwrap(); let mut apps: Vec<_> = read_dir(\"../user/src/bin\") .unwrap() .into_iter() .map(|dir_entry| { let mut name_with_ext = dir_entry.unwrap().file_name().into_string().unwrap(); name_with_ext.drain(name_with_ext.find('.').unwrap()..name_with_ext.len()); name_with_ext }) .collect(); apps.sort(); writeln!(f, r#\" .align 3 .section .data .global _num_app _num_app: .quad {}\"#, apps.len())?; for i in 0..apps.len() { writeln!(f, r#\" .quad app_{}_start\"#, i)?; } writeln!(f, r#\" .quad app_{}_end\"#, apps.len() - 1)?; for (idx, app) in apps.iter().enumerate() { println!(\"app_{}: {}\", idx, app); writeln!(f, r#\" .section .data .global app_{0}_start .global app_{0}_end app_{0}_start: .incbin \"{2}{1}.bin\" app_{0}_end:\"#, idx, app, TARGET_PATH)?; } Ok(()) }","title":"os/build.rs"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%8D%8F%E4%BD%9C%E5%BC%8F%E8%B0%83%E7%94%A8/#oscargotoml","text":"[package] name = \"os\" version = \"0.1.0\" authors = [\"Yifan Wu <shinbokuow@163.com>\"] edition = \"2018\" # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html [dependencies] riscv = { git = \"https://github.com/rcore-os/riscv\", features = [\"inline-asm\"] } lazy_static = { version = \"1.4.0\", features = [\"spin_no_std\"] }","title":"os/Cargo.toml"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%8D%8F%E4%BD%9C%E5%BC%8F%E8%B0%83%E7%94%A8/#ossrcconfigrs","text":"pub const USER_STACK_SIZE: usize = 4096 * 2; pub const KERNEL_STACK_SIZE: usize = 4096 * 2; pub const MAX_APP_NUM: usize = 4; pub const APP_BASE_ADDRESS: usize = 0x80400000; pub const APP_SIZE_LIMIT: usize = 0x20000;","title":"os/src/config.rs"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%8D%8F%E4%BD%9C%E5%BC%8F%E8%B0%83%E7%94%A8/#ossrcconsolers","text":"use core::fmt::{self, Write}; use crate::sbi::console_putchar; struct Stdout; impl Write for Stdout { fn write_str(&mut self, s: &str) -> fmt::Result { for c in s.chars() { console_putchar(c as usize); } Ok(()) } } pub fn print(args: fmt::Arguments) { Stdout.write_fmt(args).unwrap(); } #[macro_export] macro_rules! print { ($fmt: literal $(, $($arg: tt)+)?) => { $crate::console::print(format_args!($fmt $(, $($arg)+)?)); } } #[macro_export] macro_rules! println { ($fmt: literal $(, $($arg: tt)+)?) => { $crate::console::print(format_args!(concat!($fmt, \"\\n\") $(, $($arg)+)?)); } }","title":"os/src/console.rs"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%8D%8F%E4%BD%9C%E5%BC%8F%E8%B0%83%E7%94%A8/#ossrcentryasm","text":".section .text.entry .globl _start _start: la sp, boot_stack_top call rust_main .section .bss.stack .globl boot_stack boot_stack: .space 4096 * 16 .globl boot_stack_top boot_stack_top:","title":"os/src/entry.asm"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%8D%8F%E4%BD%9C%E5%BC%8F%E8%B0%83%E7%94%A8/#ossrclang_itemsrs","text":"use core::panic::PanicInfo; use crate::sbi::shutdown; #[panic_handler] fn panic(info: &PanicInfo) -> ! { if let Some(location) = info.location() { println!(\"[kernel] Panicked at {}:{} {}\", location.file(), location.line(), info.message().unwrap()); } else { println!(\"[kernel] Panicked: {}\", info.message().unwrap()); } shutdown() }","title":"os/src/lang_items.rs"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%8D%8F%E4%BD%9C%E5%BC%8F%E8%B0%83%E7%94%A8/#ossrclink_apps","text":".align 3 .section .data .global _num_app _num_app: .quad 3 .quad app_0_start .quad app_1_start .quad app_2_start .quad app_2_end .section .data .global app_0_start .global app_0_end app_0_start: .incbin \"../user/target/riscv64gc-unknown-none-elf/release/00write_a.bin\" app_0_end: .section .data .global app_1_start .global app_1_end app_1_start: .incbin \"../user/target/riscv64gc-unknown-none-elf/release/01write_b.bin\" app_1_end: .section .data .global app_2_start .global app_2_end app_2_start: .incbin \"../user/target/riscv64gc-unknown-none-elf/release/02write_c.bin\" app_2_end:","title":"os/src/link_app.S"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%8D%8F%E4%BD%9C%E5%BC%8F%E8%B0%83%E7%94%A8/#ossrclinker-qemuld","text":"OUTPUT_ARCH(riscv) ENTRY(_start) BASE_ADDRESS = 0x80200000; SECTIONS { . = BASE_ADDRESS; skernel = .; stext = .; .text : { *(.text.entry) *(.text .text.*) } . = ALIGN(4K); etext = .; srodata = .; .rodata : { *(.rodata .rodata.*) *(.srodata .srodata.*) } . = ALIGN(4K); erodata = .; sdata = .; .data : { *(.data .data.*) *(.sdata .sdata.*) } . = ALIGN(4K); edata = .; .bss : { *(.bss.stack) sbss = .; *(.bss .bss.*) *(.sbss .sbss.*) } . = ALIGN(4K); ebss = .; ekernel = .; /DISCARD/ : { *(.eh_frame) } }","title":"os/src/linker-qemu.ld"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%8D%8F%E4%BD%9C%E5%BC%8F%E8%B0%83%E7%94%A8/#ossrcsbirs","text":"#![allow(unused)] use core::arch::asm; const SBI_SET_TIMER: usize = 0; const SBI_CONSOLE_PUTCHAR: usize = 1; const SBI_CONSOLE_GETCHAR: usize = 2; const SBI_CLEAR_IPI: usize = 3; const SBI_SEND_IPI: usize = 4; const SBI_REMOTE_FENCE_I: usize = 5; const SBI_REMOTE_SFENCE_VMA: usize = 6; const SBI_REMOTE_SFENCE_VMA_ASID: usize = 7; const SBI_SHUTDOWN: usize = 8; #[inline(always)] fn sbi_call(which: usize, arg0: usize, arg1: usize, arg2: usize) -> usize { let mut ret; unsafe { asm!( \"ecall\", inlateout(\"x10\") arg0 => ret, in(\"x11\") arg1, in(\"x12\") arg2, in(\"x17\") which, ); } ret } pub fn console_putchar(c: usize) { sbi_call(SBI_CONSOLE_PUTCHAR, c, 0, 0); } pub fn console_getchar() -> usize { sbi_call(SBI_CONSOLE_GETCHAR, 0, 0, 0) } pub fn shutdown() -> ! { sbi_call(SBI_SHUTDOWN, 0, 0, 0); panic!(\"It should shutdown!\"); }","title":"os/src/sbi.rs"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%8D%8F%E4%BD%9C%E5%BC%8F%E8%B0%83%E7%94%A8/#ossrcsyncmodrs","text":"mod up; pub use up::UPSafeCell;","title":"os/src/sync/mod.rs"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%8D%8F%E4%BD%9C%E5%BC%8F%E8%B0%83%E7%94%A8/#ossrcsyncuprs","text":"use core::cell::{RefCell, RefMut}; /// Wrap a static data structure inside it so that we are /// able to access it without any `unsafe`. /// /// We should only use it in uniprocessor. /// /// In order to get mutable reference of inner data, call /// `exclusive_access`. pub struct UPSafeCell<T> { /// inner data inner: RefCell<T>, } unsafe impl<T> Sync for UPSafeCell<T> {} impl<T> UPSafeCell<T> { /// User is responsible to guarantee that inner struct is only used in /// uniprocessor. pub unsafe fn new(value: T) -> Self { Self { inner: RefCell::new(value) } } /// Panic if the data has been borrowed. pub fn exclusive_access(&self) -> RefMut<'_, T> { self.inner.borrow_mut() } }","title":"os/src/sync/up.rs"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%8D%8F%E4%BD%9C%E5%BC%8F%E8%B0%83%E7%94%A8/#ossrcsyscallfsrs","text":"const FD_STDOUT: usize = 1; pub fn sys_write(fd: usize, buf: *const u8, len: usize) -> isize { match fd { FD_STDOUT => { let slice = unsafe { core::slice::from_raw_parts(buf, len) }; let str = core::str::from_utf8(slice).unwrap(); print!(\"{}\", str); len as isize }, _ => { panic!(\"Unsupported fd in sys_write!\"); } } }","title":"os/src/syscall/fs.rs"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%8D%8F%E4%BD%9C%E5%BC%8F%E8%B0%83%E7%94%A8/#ossrcsyscallmodrs","text":"const SYSCALL_WRITE: usize = 64; const SYSCALL_EXIT: usize = 93; const SYSCALL_YIELD: usize = 124; //const SYSCALL_GET_TIME: usize = 169; mod fs; mod process; use fs::*; use process::*; pub fn syscall(syscall_id: usize, args: [usize; 3]) -> isize { match syscall_id { SYSCALL_WRITE => sys_write(args[0], args[1] as *const u8, args[2]), SYSCALL_EXIT => sys_exit(args[0] as i32), SYSCALL_YIELD => sys_yield(), _ => panic!(\"Unsupported syscall_id: {}\", syscall_id), } }","title":"os/src/syscall/mod.rs"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%8D%8F%E4%BD%9C%E5%BC%8F%E8%B0%83%E7%94%A8/#ossrcsyscallprocessrs","text":"use crate::task::{ suspend_current_and_run_next, exit_current_and_run_next, }; pub fn sys_exit(exit_code: i32) -> ! { println!(\"[kernel] Application exited with code {}\", exit_code); // \u5728\u8c03\u7528\u5b83\u4e4b\u524d\u6211\u4eec\u6253\u5370\u5e94\u7528\u7684\u9000\u51fa\u4fe1\u606f\u5e76\u8f93\u51fa\u5b83\u7684\u9000\u51fa\u7801 exit_current_and_run_next(); // \u57fa\u4e8e task \u5b50\u6a21\u5757\u63d0\u4f9b\u7684 exit_current_and_run_next \u63a5\u53e3 panic!(\"Unreachable in sys_exit!\"); } pub fn sys_yield() -> isize { suspend_current_and_run_next(); // task \u5b50\u6a21\u5757\u63d0\u4f9b\u7684 suspend_current_and_run_next \u63a5\u53e3 0 } // sys_yield \u8868\u793a\u5e94\u7528\u81ea\u5df1\u6682\u65f6\u653e\u5f03\u5bf9CPU\u7684\u5f53\u524d\u4f7f\u7528\u6743\uff0c\u8fdb\u5165 Ready \u72b6\u6001","title":"os/src/syscall/process.rs"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%8D%8F%E4%BD%9C%E5%BC%8F%E8%B0%83%E7%94%A8/#ossrctaskcontextrs","text":"#[derive(Copy, Clone)] #[repr(C)] pub struct TaskContext { ra: usize, // \u8bb0\u5f55__switch \u51fd\u6570\u8fd4\u56de\u4e4b\u540e\u5e94\u8be5\u8df3\u8f6c\u5230\u54ea\u91cc\u7ee7\u7eed\u6267\u884c // \u4ece\u800c\u5728\u4efb\u52a1\u5207\u6362\u5b8c\u6210\u5e76 ret \u4e4b\u540e\u80fd\u5230\u6b63\u786e\u7684\u4f4d\u7f6e sp: usize, s: [usize; 12], // \u5bf9\u4e8e\u4e00\u822c\u7684\u51fd\u6570\u800c\u8a00\uff0cRust/C \u7f16\u8bd1\u5668\u4f1a\u5728\u51fd\u6570\u7684\u8d77\u59cb\u4f4d\u7f6e\u81ea\u52a8\u751f\u6210\u4ee3\u7801\u6765\u4fdd\u5b58 s0~s11 \u8fd9\u4e9b\u88ab\u8c03\u7528\u8005\u4fdd\u5b58\u7684\u5bc4\u5b58\u5668\u3002 // \u4f46 __switch \u662f\u4e00\u4e2a\u7528\u6c47\u7f16\u4ee3\u7801\u5199\u7684\u7279\u6b8a\u51fd\u6570\uff0c\u5b83\u4e0d\u4f1a\u88ab Rust/C \u7f16\u8bd1\u5668\u5904\u7406\uff0c // \u6240\u4ee5\u6211\u4eec\u9700\u8981\u5728 __switch \u4e2d\u624b\u52a8\u7f16\u5199\u4fdd\u5b58 s0~s11 \u7684\u6c47\u7f16\u4ee3\u7801 // \u4e0d\u7528\u4fdd\u5b58\u5176\u5b83\u5bc4\u5b58\u5668\u662f\u56e0\u4e3a\uff1a\u5176\u5b83\u5bc4\u5b58\u5668\u4e2d\uff0c // \u5c5e\u4e8e\u8c03\u7528\u8005\u4fdd\u5b58\u7684\u5bc4\u5b58\u5668\u662f\u7531\u7f16\u8bd1\u5668\u5728\u9ad8\u7ea7\u8bed\u8a00\u7f16\u5199\u7684\u8c03\u7528\u51fd\u6570\u4e2d\u81ea\u52a8\u751f\u6210\u7684\u4ee3\u7801\u6765\u5b8c\u6210\u4fdd\u5b58\u7684\uff1b // \u8fd8\u6709\u4e00\u4e9b\u5bc4\u5b58\u5668\u5c5e\u4e8e\u4e34\u65f6\u5bc4\u5b58\u5668\uff0c\u4e0d\u9700\u8981\u4fdd\u5b58\u548c\u6062\u590d\u3002 } impl TaskContext { pub fn zero_init() -> Self { Self { ra: 0, sp: 0, s: [0; 12], } } pub fn goto_restore(kstack_ptr: usize) -> Self { // \u6784\u9020\u6bcf\u4e2a\u4efb\u52a1\u4fdd\u5b58\u5728\u4efb\u52a1\u63a7\u5236\u5757\u4e2d\u7684\u4efb\u52a1\u4e0a\u4e0b\u6587 extern \"C\" { fn __restore(); } Self { ra: __restore as usize, // \u5b83\u8bbe\u7f6e\u4efb\u52a1\u4e0a\u4e0b\u6587\u4e2d\u7684\u5185\u6838\u6808\u6307\u9488\u5c06\u4efb\u52a1\u4e0a\u4e0b\u6587\u7684 ra \u5bc4\u5b58\u5668\u8bbe\u7f6e\u4e3a __restore \u7684\u5165\u53e3\u5730\u5740 // \u8fd9\u6837\uff0c\u5728 __switch \u4ece\u5b83\u4e0a\u9762\u6062\u590d\u5e76\u8fd4\u56de\u4e4b\u540e\u5c31\u4f1a\u76f4\u63a5\u8df3\u8f6c\u5230 __restore \uff0c // \u6b64\u65f6\u6808\u9876\u662f\u4e00\u4e2a\u6211\u4eec\u6784\u9020\u51fa\u6765\u7b2c\u4e00\u6b21\u8fdb\u5165\u7528\u6237\u6001\u6267\u884c\u7684 Trap \u4e0a\u4e0b\u6587 sp: kstack_ptr, s: [0; 12], } } }","title":"os/src/task/context.rs"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%8D%8F%E4%BD%9C%E5%BC%8F%E8%B0%83%E7%94%A8/#ossrctaskswitchrs","text":"use super::TaskContext; use core::arch::global_asm; global_asm!(include_str!(\"switch.S\")); extern \"C\" { pub fn __switch( current_task_cx_ptr: *mut TaskContext, next_task_cx_ptr: *const TaskContext ); // \u6211\u4eec\u4f1a\u5c06\u8fd9\u6bb5\u6c47\u7f16\u4ee3\u7801\u4e2d\u7684\u5168\u5c40\u7b26\u53f7 __switch \u89e3\u91ca\u4e3a\u4e00\u4e2a Rust \u51fd\u6570 // \u6211\u4eec\u4f1a\u8c03\u7528\u8be5\u51fd\u6570\u6765\u5b8c\u6210\u5207\u6362\u529f\u80fd\u800c\u4e0d\u662f\u76f4\u63a5\u8df3\u8f6c\u5230\u7b26\u53f7 __switch \u7684\u5730\u5740\u3002 // \u56e0\u6b64\u5728\u8c03\u7528\u524d\u540e Rust \u7f16\u8bd1\u5668\u4f1a\u81ea\u52a8\u5e2e\u52a9\u6211\u4eec\u63d2\u5165\u4fdd\u5b58/\u6062\u590d\u8c03\u7528\u8005\u4fdd\u5b58\u5bc4\u5b58\u5668\u7684\u6c47\u7f16\u4ee3\u7801 }","title":"os/src/task/switch.rs"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%8D%8F%E4%BD%9C%E5%BC%8F%E8%B0%83%E7%94%A8/#ossrctaskswitchs","text":".altmacro .macro SAVE_SN n sd s\\n, (\\n+2)*8(a0) .endm .macro LOAD_SN n ld s\\n, (\\n+2)*8(a1) .endm .section .text .globl __switch __switch: # __switch( # current_task_cx_ptr: *mut TaskContext, # next_task_cx_ptr: *const TaskContext # ) # \u51fd\u6570\u539f\u578b\u4e2d\u7684\u4e24\u4e2a\u53c2\u6570\u5206\u522b\u662f\u5f53\u524d A \u4efb\u52a1\u4e0a\u4e0b\u6587\u6307\u9488 next_task_cx_ptr # \u548c\u5373\u5c06\u88ab\u5207\u6362\u5230\u7684 B \u4efb\u52a1\u4e0a\u4e0b\u6587\u6307\u9488 next_task_cx_ptr \uff0c # \u4ece RISC-V \u8c03\u7528\u89c4\u8303 \u53ef\u4ee5\u77e5\u9053\u5b83\u4eec\u5206\u522b\u901a\u8fc7\u5bc4\u5b58\u5668 a0/a1 \u4f20\u5165 # save kernel stack of current task # \u4fdd\u5b58\u5f53\u524d\u4efb\u52a1\u7684\u6808\u6bb5 sd sp, 8(a0) # save ra & s0~s11 of current execution # \u4fdd\u5b58\u5f53\u524d \u4efb\u52a1\u4e0a\u4e0b\u6587 sd ra, 0(a0) .set n, 0 .rept 12 SAVE_SN %n .set n, n + 1 .endr # restore ra & s0~s11 of next execution # \u6062\u590d\u4e0b\u4e00\u4e2a\u4efb\u52a1\u7684\u4e0a\u4e0b\u6587 ld ra, 0(a1) .set n, 0 .rept 12 LOAD_SN %n .set n, n + 1 .endr # restore kernel stack of next task # \u6062\u590d\u4e0a\u4e00\u4e2a\u4efb\u52a1\u7684 \u6808\u6bb5 ld sp, 8(a1) ret","title":"os/src/task/switch.S"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%8D%8F%E4%BD%9C%E5%BC%8F%E8%B0%83%E7%94%A8/#ossrctaskrs","text":"use super::TaskContext; #[derive(Copy, Clone)] // \u901a\u8fc7 #[derive(...)] \u53ef\u4ee5\u8ba9\u7f16\u8bd1\u5668\u4e3a\u4f60\u7684\u7c7b\u578b\u63d0\u4f9b\u4e00\u4e9b Trait \u7684\u9ed8\u8ba4\u5b9e\u73b0\u3002 // \u5b9e\u73b0\u4e86 Clone Trait \u4e4b\u540e\u5c31\u53ef\u4ee5\u8c03\u7528 clone \u51fd\u6570\u5b8c\u6210\u62f7\u8d1d\uff1b // \u5b9e\u73b0\u4e86 PartialEq Trait \u4e4b\u540e\u5c31\u53ef\u4ee5\u4f7f\u7528 == \u8fd0\u7b97\u7b26\u6bd4\u8f83\u8be5\u7c7b\u578b\u7684\u4e24\u4e2a\u5b9e\u4f8b\uff0c // \u4ece\u903b\u8f91\u4e0a\u8bf4\u53ea\u6709 \u4e24\u4e2a\u76f8\u7b49\u7684\u5e94\u7528\u6267\u884c\u72b6\u6001\u624d\u4f1a\u88ab\u5224\u4e3a\u76f8\u7b49\uff0c\u800c\u4e8b\u5b9e\u4e0a\u4e5f\u786e\u5b9e\u5982\u6b64\u3002 // Copy \u662f\u4e00\u4e2a\u6807\u8bb0 Trait\uff0c\u51b3\u5b9a\u8be5\u7c7b\u578b\u5728\u6309\u503c\u4f20\u53c2/\u8d4b\u503c\u7684\u65f6\u5019\u91c7\u7528\u79fb\u52a8\u8bed\u4e49\u8fd8\u662f\u590d\u5236\u8bed\u4e49\u3002 pub struct TaskControlBlock { // \u4efb\u52a1\u63a7\u5236\u5757 pub task_status: TaskStatus, // \u4efb\u52a1 \u8fd0\u884c\u72b6\u6001 pub task_cx: TaskContext, // \u4efb\u52a1\u4e0a\u4e0b\u6587 } #[derive(Copy, Clone, PartialEq)] pub enum TaskStatus { UnInit, // \u672a\u521d\u59cb\u5316 Ready, // \u51c6\u5907\u8fd0\u884c Running, // \u6b63\u5728\u8fd0\u884c Exited, // \u5df2\u9000\u51fa }","title":"os/src/task.rs"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%8D%8F%E4%BD%9C%E5%BC%8F%E8%B0%83%E7%94%A8/#ossrctaskmodrs","text":"mod context; mod switch; mod task; use crate::config::MAX_APP_NUM; use crate::loader::{get_num_app, init_app_cx}; use lazy_static::*; use switch::__switch; use task::{TaskControlBlock, TaskStatus}; use crate::sync::UPSafeCell; pub use context::TaskContext; // \u5168\u5c40\u7684\u4efb\u52a1\u7ba1\u7406\u5668 pub struct TaskManager { num_app: usize, // \u4efb\u52a1\u7ba1\u7406\u5668\u7ba1\u7406\u7684\u5e94\u7528\u7684\u6570\u76ee // \u5b83\u5728 TaskManager \u521d\u59cb\u5316\u4e4b\u540e\u5c31\u4e0d\u4f1a\u53d1\u751f\u53d8\u5316 inner: UPSafeCell<TaskManagerInner>, // \u800c\u5305\u88f9\u5728 TaskManagerInner \u5185\u7684\u4efb\u52a1\u63a7\u5236\u5757\u6570\u7ec4 tasks // \u4ee5\u53ca\u8868\u793a CPU \u6b63\u5728\u6267\u884c\u7684\u5e94\u7528\u7f16\u53f7 current_task \u4f1a\u5728\u6267\u884c\u5e94\u7528\u7684\u8fc7\u7a0b\u4e2d\u53d1\u751f\u53d8\u5316\uff1a // \u6bcf\u4e2a\u5e94\u7528\u7684\u8fd0\u884c\u72b6\u6001\u90fd\u4f1a\u53d1\u751f\u53d8\u5316\uff0c\u800c CPU \u6267\u884c\u7684\u5e94\u7528\u4e5f\u5728\u4e0d\u65ad\u5207\u6362\u3002 // \u56e0\u6b64\u6211\u4eec\u9700\u8981\u5c06 TaskManagerInner \u5305\u88f9\u5728 UPSafeCell \u5185 // \u4ee5\u83b7\u53d6\u5176\u5185\u90e8\u53ef\u53d8\u6027\u4ee5\u53ca\u5355\u6838\u4e0a\u5b89\u5168\u7684\u8fd0\u884c\u65f6\u501f\u7528\u68c0\u67e5\u80fd\u529b } struct TaskManagerInner { tasks: [TaskControlBlock; MAX_APP_NUM], current_task: usize, // \u53ea\u80fd\u901a\u8fc7\u5b83\u77e5\u9053 CPU\u6b63\u5728\u6267\u884c\u54ea\u4e2a\u5e94\u7528\uff0c\u800c\u4e0d\u80fd\u63a8\u6d4b\u51fa\u5176\u4ed6\u5e94\u7528\u7684\u4efb\u4f55\u4fe1\u606f } lazy_static! { pub static ref TASK_MANAGER: TaskManager = { let num_app = get_num_app(); // \u8c03\u7528 loader \u5b50\u6a21\u5757\u63d0\u4f9b\u7684 get_num_app \u63a5\u53e3\u83b7\u53d6\u94fe\u63a5\u5230\u5185\u6838\u7684\u5e94\u7528\u603b\u6570 let mut tasks = [ TaskControlBlock { task_cx: TaskContext::zero_init(), task_status: TaskStatus::UnInit }; MAX_APP_NUM ]; // \u521b\u5efa\u4e00\u4e2a\u521d\u59cb\u5316\u7684 tasks \u6570\u7ec4\uff0c\u5176\u4e2d\u7684\u6bcf\u4e2a\u4efb\u52a1\u63a7\u5236\u5757\u7684\u8fd0\u884c\u72b6\u6001\u90fd\u662f UnInit \uff1a\u8868\u793a\u5c1a\u672a\u521d\u59cb\u5316 for i in 0..num_app { tasks[i].task_cx = TaskContext::goto_restore(init_app_cx(i)); // \u5bf9\u4e8e\u6bcf\u4e2a\u4efb\u52a1\uff0c\u6211\u4eec\u5148\u8c03\u7528 init_app_cx \u6784\u9020\u8be5\u4efb\u52a1\u7684 Trap \u4e0a\u4e0b\u6587 // \uff08\u5305\u62ec\u5e94\u7528\u5165\u53e3\u5730\u5740\u548c\u7528\u6237\u6808\u6307\u9488\uff09\u5e76\u5c06\u5176\u538b\u5165\u5230\u5185\u6838\u6808\u9876 // \u63a5\u7740\u8c03\u7528 TaskContext::goto_restore \u6765\u6784\u9020\u6bcf\u4e2a\u4efb\u52a1\u4fdd\u5b58\u5728\u4efb\u52a1\u63a7\u5236\u5757\u4e2d\u7684\u4efb\u52a1\u4e0a\u4e0b\u6587\u3002 // \u5b83\u8bbe\u7f6e\u4efb\u52a1\u4e0a\u4e0b\u6587\u4e2d\u7684\u5185\u6838\u6808\u6307\u9488\u5c06\u4efb\u52a1\u4e0a\u4e0b\u6587\u7684 ra \u5bc4\u5b58\u5668\u8bbe\u7f6e\u4e3a __restore \u7684\u5165\u53e3\u5730\u5740 // \u8fd9\u6837\uff0c\u5728 __switch \u4ece\u5b83\u4e0a\u9762\u6062\u590d\u5e76\u8fd4\u56de\u4e4b\u540e\u5c31\u4f1a\u76f4\u63a5\u8df3\u8f6c\u5230 __restore \uff0c // \u6b64\u65f6\u6808\u9876\u662f\u4e00\u4e2a\u6211\u4eec\u6784\u9020\u51fa\u6765\u7b2c\u4e00\u6b21\u8fdb\u5165\u7528\u6237\u6001\u6267\u884c\u7684 Trap \u4e0a\u4e0b\u6587 tasks[i].task_status = TaskStatus::Ready; } // \u4f9d\u6b21\u5bf9\u6bcf\u4e2a\u4efb\u52a1\u63a7\u5236\u5757\u8fdb\u884c\u521d\u59cb\u5316\uff0c\u5c06\u5176\u8fd0\u884c\u72b6\u6001\u8bbe\u7f6e\u4e3a Ready \uff1a\u8868\u793a\u53ef\u4ee5\u8fd0\u884c\uff0c // \u5e76\u521d\u59cb\u5316\u5b83\u7684 \u4efb\u52a1\u4e0a\u4e0b\u6587 TaskManager { num_app, inner: unsafe { UPSafeCell::new(TaskManagerInner { tasks, current_task: 0, })}, } // \u521b\u5efa TaskManager \u5b9e\u4f8b\u5e76\u8fd4\u56de }; } //\u6ce8\u610f\u6211\u4eec\u65e0\u9700\u548c\u7b2c\u4e8c\u7ae0\u4e00\u6837\u5c06 TaskManager \u6807\u8bb0\u4e3a Sync \uff0c // \u56e0\u4e3a\u7f16\u8bd1\u5668\u53ef\u4ee5\u6839\u636e TaskManager \u5b57\u6bb5\u7684\u60c5\u51b5\u81ea\u52a8\u63a8\u5bfc\u51fa TaskManager \u662f Sync \u7684 impl TaskManager { fn run_first_task(&self) -> ! { let mut inner = self.inner.exclusive_access(); let task0 = &mut inner.tasks[0]; // \u6211\u4eec\u53d6\u51fa\u5373\u5c06\u6700\u5148\u6267\u884c\u7684\u7f16\u53f7\u4e3a 0 \u7684\u5e94\u7528\u7684\u4efb\u52a1\u4e0a\u4e0b\u6587\u6307\u9488 next_task_cx_ptr \u5e76\u5e0c\u671b\u80fd\u591f\u5207\u6362\u8fc7\u53bb\u3002\u6ce8\u610f __switch \u6709\u4e24\u4e2a\u53c2\u6570\u5206\u522b\u8868\u793a\u5f53\u524d\u5e94\u7528\u548c\u5373\u5c06\u5207\u6362\u5230\u7684\u5e94\u7528\u7684\u4efb\u52a1\u4e0a\u4e0b\u6587\u6307\u9488\uff0c\u5176\u7b2c\u4e00\u4e2a\u53c2\u6570\u5b58\u5728\u7684\u610f\u4e49\u662f\u8bb0\u5f55\u5f53\u524d\u5e94\u7528\u7684\u4efb\u52a1\u4e0a\u4e0b\u6587\u88ab\u4fdd\u5b58\u5728\u54ea\u91cc\uff0c\u4e5f\u5c31\u662f\u5f53\u524d\u5e94\u7528\u5185\u6838\u6808\u7684\u6808\u9876\uff0c\u8fd9\u6837\u4e4b\u540e\u624d\u80fd\u7ee7\u7eed\u6267\u884c\u8be5\u5e94\u7528\u3002\u4f46\u5728 run_first_task \u7684\u65f6\u5019\uff0c\u6211\u4eec\u5e76\u6ca1\u6709\u6267\u884c\u4efb\u4f55\u5e94\u7528\uff0c __switch \u524d\u534a\u90e8\u5206\u7684\u4fdd\u5b58\u4ec5\u4ec5\u662f\u5728\u542f\u52a8\u6808\u4e0a\u4fdd\u5b58\u4e86\u4e00\u4e9b\u4e4b\u540e\u4e0d\u4f1a\u7528\u5230\u7684\u6570\u636e\uff0c\u81ea\u7136\u4e5f\u65e0\u9700\u8bb0\u5f55\u542f\u52a8\u6808\u6808\u9876\u7684\u4f4d\u7f6e\u3002 // \u56e0\u6b64\uff0c\u6211\u4eec\u663e\u5f0f\u5728\u542f\u52a8\u6808\u4e0a\u5206\u914d\u4e86\u4e00\u4e2a\u540d\u4e3a _unused \u7684\u4efb\u52a1\u4e0a\u4e0b\u6587\uff0c\u5e76\u5c06\u5b83\u7684\u5730\u5740\u4f5c\u4e3a\u7b2c\u4e00\u4e2a\u53c2\u6570\u4f20\u7ed9 __switch \uff0c\u8fd9\u6837\u4fdd\u5b58\u4e00\u4e9b\u5bc4\u5b58\u5668\u4e4b\u540e\u7684\u542f\u52a8\u6808\u6808\u9876\u7684\u4f4d\u7f6e\u5c06\u4f1a\u4fdd\u5b58\u5728\u6b64\u53d8\u91cf\u4e2d\u3002\u7136\u800c\u65e0\u8bba\u662f\u6b64\u53d8\u91cf\u8fd8\u662f\u542f\u52a8\u6808\u6211\u4eec\u4e4b\u540e\u5747\u4e0d\u4f1a\u6d89\u53ca\u5230\uff0c\u4e00\u65e6\u5e94\u7528\u5f00\u59cb\u8fd0\u884c\uff0c\u6211\u4eec\u5c31\u5f00\u59cb\u5728\u5e94\u7528\u7684\u7528\u6237\u6808\u548c\u5185\u6838\u6808\u4e4b\u95f4\u5f00\u59cb\u5207\u6362\u4e86\u3002\u8fd9\u91cc\u58f0\u660e\u6b64\u53d8\u91cf\u7684\u610f\u4e49\u4ec5\u4ec5\u662f\u4e3a\u4e86\u907f\u514d\u8986\u76d6\u5230\u5176\u4ed6\u6570\u636e task0.task_status = TaskStatus::Running; let next_task_cx_ptr = &task0.task_cx as *const TaskContext; // \u5c06\u7f16\u53f7\u4e3a0 \u7684\u4efb\u52a1 \u6807\u8bb0\u4e3a\u4e0b\u4e00\u4e2a\u8981\u5207\u6362\u5230\u7684\u4efb\u52a1 drop(inner); let mut _unused = TaskContext::zero_init(); // \u521d\u59cb\u5316\u521b\u5efa\u4e00\u4e2a\u4e0d\u4f1a\u7528\u7684\u7684 \u4efb\u52a1\u4e0a\u4e0b\u6587 \u4f5c\u4e3a\u5f53\u524d\u4efb\u52a1\u4e0a\u4e0b\u6587 // \u7531\u4e8e\u4e4b\u540e\u5207\u6362\u65f6 \u627e\u4e0d\u5230\u5b83\u7684 ID\uff0c\u6240\u6709\u4e0d\u7528\u5f53\u5fc3\u5b83\u5bf9\u540e\u7eed\u7a0b\u5e8f\u8fd0\u884c\u7684\u5f71\u54cd // before this, we should drop local variables that must be dropped manually unsafe { __switch( &mut _unused as *mut TaskContext, next_task_cx_ptr, ); } panic!(\"unreachable in run_first_task!\"); } fn mark_current_suspended(&self) { let mut inner = self.inner.exclusive_access(); let current = inner.current_task; inner.tasks[current].task_status = TaskStatus::Ready; // \u5176\u4e2d\uff0c\u9996\u5148\u83b7\u5f97\u91cc\u5c42 TaskManagerInner \u7684\u53ef\u53d8\u5f15\u7528\uff0c // \u901a\u8fc7 sync/up.rs \u91cc UPSafeCell\u7ed3\u6784\u4f53\u7684\u65b9\u6cd5 exclusive_access \u83b7\u53d6 // \u7136\u540e\u6839\u636e\u5176\u4e2d\u8bb0\u5f55\u7684\u5f53\u524d\u6b63\u5728\u6267\u884c\u7684\u5e94\u7528 ID \u5bf9\u5e94\u5728\u4efb\u52a1\u63a7\u5236\u5757\u6570\u7ec4 tasks \u4e2d\u4fee\u6539\u72b6\u6001 } fn mark_current_exited(&self) { let mut inner = self.inner.exclusive_access(); let current = inner.current_task; inner.tasks[current].task_status = TaskStatus::Exited; // \u5176\u4e2d\uff0c\u9996\u5148\u83b7\u5f97\u91cc\u5c42 TaskManagerInner \u7684\u53ef\u53d8\u5f15\u7528\uff0c // \u901a\u8fc7 sync/up.rs \u91cc UPSafeCell\u7ed3\u6784\u4f53\u7684\u65b9\u6cd5 exclusive_access \u83b7\u53d6 // \u7136\u540e\u6839\u636e\u5176\u4e2d\u8bb0\u5f55\u7684\u5f53\u524d\u6b63\u5728\u6267\u884c\u7684\u5e94\u7528 ID \u5bf9\u5e94\u5728\u4efb\u52a1\u63a7\u5236\u5757\u6570\u7ec4 tasks \u4e2d\u4fee\u6539\u72b6\u6001 } fn find_next_task(&self) -> Option<usize> { let inner = self.inner.exclusive_access(); let current = inner.current_task; (current + 1..current + self.num_app + 1) .map(|id| id % self.num_app) .find(|id| { inner.tasks[*id].task_status == TaskStatus::Ready }) // TaskManagerInner \u7684 tasks \u662f\u4e00\u4e2a\u56fa\u5b9a\u7684\u4efb\u52a1\u63a7\u5236\u5757\u7ec4\u6210\u7684\u8868\uff0c\u957f\u5ea6\u4e3a num_app \uff0c // \u53ef\u4ee5\u7528\u4e0b\u6807 0~num_app-1 \u6765\u8bbf\u95ee\u5f97\u5230\u6bcf\u4e2a\u5e94\u7528\u7684\u63a7\u5236\u72b6\u6001\u3002 // \u6211\u4eec\u7684\u4efb\u52a1\u5c31\u662f\u627e\u5230 current_task \u540e\u9762\u7b2c\u4e00\u4e2a\u72b6\u6001\u4e3a Ready \u7684\u5e94\u7528\u3002 // \u56e0\u6b64\u4ece current_task + 1 \u5f00\u59cb\u5faa\u73af\u4e00\u5708\uff0c\u9700\u8981\u9996\u5148\u5bf9 num_app \u53d6\u6a21\u5f97\u5230\u5b9e\u9645\u7684\u4e0b\u6807\uff0c // \u7136\u540e\u68c0\u67e5\u5b83\u7684\u8fd0\u884c\u72b6\u6001 } fn run_next_task(&self) { if let Some(next) = self.find_next_task() { // \u5b83\u4f1a\u8c03\u7528 find_next_task \u65b9\u6cd5\u5c1d\u8bd5\u5bfb\u627e\u4e00\u4e2a\u8fd0\u884c\u72b6\u6001\u4e3a Ready \u7684\u5e94\u7528\u5e76\u8fd4\u56de\u5176 ID let mut inner = self.inner.exclusive_access(); // \u83b7\u53d6\u5168\u5c40\u4efb\u52a1\u7ba1\u7406\u5668\u7684 struct TaskManagerInner { // tasks: [TaskControlBlock; MAX_APP_NUM], // current_task: usize, // } let current = inner.current_task; // \u83b7\u53d6\u5f53\u524d\u4efb\u52a1\u7684 ID inner.tasks[next].task_status = TaskStatus::Running; // \u5c06\u4e0b\u4e00\u4e2a\u4efb\u52a1\u7684\u72b6\u6001\u6807\u6ce8\u4e3a Running inner.current_task = next; // \u5c06\u5f53\u524d\u4efb\u52a1 \u6807\u6ce8\u4e3a\u4e0b\u4e00\u4e2a\u4efb\u52a1\u7684 ID let current_task_cx_ptr = &mut inner.tasks[current].task_cx as *mut TaskContext; // \u83b7\u53d6\u5b58\u653e\u5f53\u524d\u4efb\u52a1\u4e0a\u4e0b\u6587\u7684 \u5730\u5740 let next_task_cx_ptr = &inner.tasks[next].task_cx as *const TaskContext; // \u83b7\u53d6\u5b58\u653e\u4e0b\u4e00\u4e2a\u4efb\u52a1\u4e0a\u4e0b\u6587\u7684 \u5730\u5740 drop(inner); // \u5728\u5b9e\u9645\u5207\u6362\u4e4b\u524d\u6211\u4eec\u9700\u8981\u624b\u52a8 drop \u6389\u6211\u4eec\u83b7\u53d6\u5230\u7684 TaskManagerInner // \u7684\u6765\u81ea UPSafeCell \u7684\u501f\u7528\u6807\u8bb0\u3002 // \u56e0\u4e3a\u4e00\u822c\u60c5\u51b5\u4e0b\u5b83\u662f\u5728\u51fd\u6570\u9000\u51fa\u4e4b\u540e\u624d\u4f1a\u88ab\u81ea\u52a8\u91ca\u653e\uff0c\u4ece\u800c TASK_MANAGER // \u7684 inner \u5b57\u6bb5\u5f97\u4ee5\u56de\u5f52\u5230\u672a\u88ab\u501f\u7528\u7684\u72b6\u6001\uff0c // \u4e4b\u540e\u53ef\u4ee5\u518d\u501f\u7528\u3002\u5982\u679c\u4e0d\u624b\u52a8 drop \u7684\u8bdd\uff0c\u7f16\u8bd1\u5668\u4f1a\u5728 __switch \u8fd4\u56de\u65f6\uff0c // \u4e5f\u5c31\u662f\u5f53\u524d\u5e94\u7528\u88ab\u5207\u6362\u56de\u6765\u7684\u65f6\u5019\u624d drop\uff0c\u8fd9\u671f\u95f4\u6211\u4eec\u90fd\u4e0d\u80fd\u4fee\u6539 TaskManagerInner \uff0c // \u751a\u81f3\u4e0d\u80fd\u8bfb\uff08\u56e0\u4e3a\u4e4b\u524d\u662f\u53ef\u53d8\u501f\u7528\uff09\uff0c\u4f1a\u5bfc\u81f4\u5185\u6838 panic \u62a5\u9519\u9000\u51fa\u3002 // \u6b63\u56e0\u5982\u6b64\uff0c\u6211\u4eec\u9700\u8981\u5728 __switch \u524d\u63d0\u65e9\u624b\u52a8 drop \u6389 inner // before this, we should drop local variables that must be dropped manually unsafe { __switch( current_task_cx_ptr, next_task_cx_ptr, ); } // \u5982\u679c\u80fd\u591f\u627e\u5230\u4e0b\u4e00\u4e2a\u53ef\u8fd0\u884c\u7684\u5e94\u7528\u7684\u8bdd\uff0c // \u6211\u4eec\u5c31\u53ef\u4ee5\u5206\u522b\u62ff\u5230\u5f53\u524d\u5e94\u7528 current_task_cx_ptr // \u548c\u5373\u5c06\u88ab\u5207\u6362\u5230\u7684\u5e94\u7528 next_task_cx_ptr \u7684\u4efb\u52a1\u4e0a\u4e0b\u6587\u6307\u9488\uff0c // \u7136\u540e\u8c03\u7528 __switch \u63a5\u53e3\u8fdb\u884c\u5207\u6362 // go back to user mode } else { // \u627e\u4e0d\u5230\u5c31 panic\uff0c\u6b64\u65f6 panic \u540e\u5c31\u4f1a\u9000\u51fa panic!(\"All applications completed!\"); } } } pub fn run_first_task() { TASK_MANAGER.run_first_task(); // \u5b83\u8c03\u7528\u4e86\u5168\u5c40\u4efb\u52a1\u7ba1\u7406\u5668 TASK_MANAGER \u7684 run_first_task \u65b9\u6cd5\u3002 } fn run_next_task() { TASK_MANAGER.run_next_task(); // \u5b83\u8c03\u7528\u4e86\u5168\u5c40\u4efb\u52a1\u7ba1\u7406\u5668 TASK_MANAGER \u7684 run_next_task \u65b9\u6cd5\u3002 } fn mark_current_suspended() { TASK_MANAGER.mark_current_suspended(); // \u5b83\u8c03\u7528\u4e86\u5168\u5c40\u4efb\u52a1\u7ba1\u7406\u5668 TASK_MANAGER \u7684 mark_current_suspended \u65b9\u6cd5\u3002 } fn mark_current_exited() { TASK_MANAGER.mark_current_exited(); // \u5b83\u8c03\u7528\u4e86\u5168\u5c40\u4efb\u52a1\u7ba1\u7406\u5668 TASK_MANAGER \u7684 mark_current_exited \u65b9\u6cd5\u3002 } pub fn suspend_current_and_run_next() { mark_current_suspended(); // \u5148\u4fee\u6539\u5f53\u524d\u5e94\u7528\u7684\u8fd0\u884c\u72b6\u6001 run_next_task(); // \u7136\u540e\u5c1d\u8bd5\u5207\u6362\u5230\u4e0b\u4e00\u4e2a\u5e94\u7528 } pub fn exit_current_and_run_next() { mark_current_exited(); // \u5148\u4fee\u6539\u5f53\u524d\u5e94\u7528\u7684\u8fd0\u884c\u72b6\u6001 run_next_task(); // \u7136\u540e\u5c1d\u8bd5\u5207\u6362\u5230\u4e0b\u4e00\u4e2a\u5e94\u7528 }","title":"os/src/task/mod.rs"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%8D%8F%E4%BD%9C%E5%BC%8F%E8%B0%83%E7%94%A8/#ossrctrapcontextrs","text":"use riscv::register::sstatus::{Sstatus, self, SPP}; #[repr(C)] pub struct TrapContext { pub x: [usize; 32], pub sstatus: Sstatus, pub sepc: usize, } impl TrapContext { pub fn set_sp(&mut self, sp: usize) { self.x[2] = sp; } pub fn app_init_context(entry: usize, sp: usize) -> Self { let mut sstatus = sstatus::read(); sstatus.set_spp(SPP::User); let mut cx = Self { x: [0; 32], sstatus, sepc: entry, }; cx.set_sp(sp); cx } }","title":"os/src/trap/context.rs"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%8D%8F%E4%BD%9C%E5%BC%8F%E8%B0%83%E7%94%A8/#ossrctrapmodrs","text":"mod context; use riscv::register::{ mtvec::TrapMode, stvec, scause::{ self, Trap, Exception, }, stval, }; use crate::syscall::syscall; use core::arch::global_asm; global_asm!(include_str!(\"trap.S\")); pub fn init() { extern \"C\" { fn __alltraps(); } unsafe { stvec::write(__alltraps as usize, TrapMode::Direct); } } #[no_mangle] pub fn trap_handler(cx: &mut TrapContext) -> &mut TrapContext { let scause = scause::read(); let stval = stval::read(); match scause.cause() { Trap::Exception(Exception::UserEnvCall) => { cx.sepc += 4; cx.x[10] = syscall(cx.x[17], [cx.x[10], cx.x[11], cx.x[12]]) as usize; } Trap::Exception(Exception::StoreFault) | Trap::Exception(Exception::StorePageFault) => { println!(\"[kernel] PageFault in application, bad addr = {:#x}, bad instruction = {:#x}, kernel killed it.\", stval, cx.sepc); panic!(\"[kernel] Cannot continue!\"); //run_next_app(); } Trap::Exception(Exception::IllegalInstruction) => { println!(\"[kernel] IllegalInstruction in application, kernel killed it.\"); panic!(\"[kernel] Cannot continue!\"); //run_next_app(); } _ => { panic!(\"Unsupported trap {:?}, stval = {:#x}!\", scause.cause(), stval); } } cx } pub use context::TrapContext;","title":"os/src/trap/mod.rs"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%8D%8F%E4%BD%9C%E5%BC%8F%E8%B0%83%E7%94%A8/#ossrctraptraps","text":".altmacro .macro SAVE_GP n sd x\\n, \\n*8(sp) .endm .macro LOAD_GP n ld x\\n, \\n*8(sp) .endm .section .text .globl __alltraps .globl __restore .align 2 __alltraps: csrrw sp, sscratch, sp # now sp->kernel stack, sscratch->user stack # allocate a TrapContext on kernel stack addi sp, sp, -34*8 # save general-purpose registers sd x1, 1*8(sp) # skip sp(x2), we will save it later sd x3, 3*8(sp) # skip tp(x4), application does not use it # save x5~x31 .set n, 5 .rept 27 SAVE_GP %n .set n, n+1 .endr # we can use t0/t1/t2 freely, because they were saved on kernel stack csrr t0, sstatus csrr t1, sepc sd t0, 32*8(sp) sd t1, 33*8(sp) # read user stack from sscratch and save it on the kernel stack csrr t2, sscratch sd t2, 2*8(sp) # set input argument of trap_handler(cx: &mut TrapContext) mv a0, sp call trap_handler __restore: # now sp->kernel stack(after allocated), sscratch->user stack # restore sstatus/sepc # \u5b83 \u4e0d\u518d\u9700\u8981 \u5728\u5f00\u5934 mv sp, a0 \u4e86\u3002\u56e0\u4e3a\u5728 __switch \u4e4b\u540e\uff0c # sp \u5c31\u5df2\u7ecf\u6b63\u786e\u6307\u5411\u4e86\u6211\u4eec\u9700\u8981\u7684 Trap \u4e0a\u4e0b\u6587\u5730\u5740 ld t0, 32*8(sp) ld t1, 33*8(sp) ld t2, 2*8(sp) csrw sstatus, t0 csrw sepc, t1 csrw sscratch, t2 # restore general-purpuse registers except sp/tp ld x1, 1*8(sp) ld x3, 3*8(sp) .set n, 5 .rept 27 LOAD_GP %n .set n, n+1 .endr # release TrapContext on kernel stack addi sp, sp, 34*8 # now sp->kernel stack, sscratch->user stack csrrw sp, sscratch, sp sret","title":"os/src/trap/trap.S"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%8D%8F%E4%BD%9C%E5%BC%8F%E8%B0%83%E7%94%A8/#ossrcloaderrs","text":"use crate::trap::TrapContext; use crate::config::*; use core::arch::asm; #[repr(align(4096))] #[derive(Copy, Clone)] struct KernelStack { data: [u8; KERNEL_STACK_SIZE], } #[repr(align(4096))] #[derive(Copy, Clone)] struct UserStack { data: [u8; USER_STACK_SIZE], } static KERNEL_STACK: [KernelStack; MAX_APP_NUM] = [ KernelStack { data: [0; KERNEL_STACK_SIZE], }; MAX_APP_NUM ]; static USER_STACK: [UserStack; MAX_APP_NUM] = [ UserStack { data: [0; USER_STACK_SIZE], }; MAX_APP_NUM ]; impl KernelStack { fn get_sp(&self) -> usize { self.data.as_ptr() as usize + KERNEL_STACK_SIZE } pub fn push_context(&self, trap_cx: TrapContext) -> usize { let trap_cx_ptr = (self.get_sp() - core::mem::size_of::<TrapContext>()) as *mut TrapContext; unsafe { *trap_cx_ptr = trap_cx; } trap_cx_ptr as usize } } impl UserStack { fn get_sp(&self) -> usize { self.data.as_ptr() as usize + USER_STACK_SIZE } } fn get_base_i(app_id: usize) -> usize { APP_BASE_ADDRESS + app_id * APP_SIZE_LIMIT } // \u83b7\u53d6\u7b2c i \u4e2a\u5e94\u7528\u7684\u8d77\u59cb\u5730\u5740 pub fn get_num_app() -> usize { extern \"C\" { fn _num_app(); } unsafe { (_num_app as usize as *const usize).read_volatile() } } // \u83b7\u53d6 _num_app, \u5373\u5e94\u7528\u7684\u4e2a\u6570 pub fn load_apps() { extern \"C\" { fn _num_app(); } let num_app_ptr = _num_app as usize as *const usize; let num_app = get_num_app(); let app_start = unsafe { core::slice::from_raw_parts(num_app_ptr.add(1), num_app + 1) }; // clear i-cache first unsafe { asm!(\"fence.i\"); } // load apps for i in 0..num_app { let base_i = get_base_i(i); // \u83b7\u53d6\u7b2c i \u4e2a\u5e94\u7528\u7684\u8d77\u59cb\u5730\u5740 (base_i..base_i + APP_SIZE_LIMIT).for_each(|addr| unsafe { (addr as *mut u8).write_volatile(0) }); // \u5c06\u7528\u4e8e\u5b58\u653e\u7b2c i \u4e2a\u5e94\u7528\u7684\u5730\u5740\u533a\u95f4 \u7528 0 \u586b\u5145 let src = unsafe { core::slice::from_raw_parts(app_start[i] as *const u8, app_start[i + 1] - app_start[i]) }; // \u83b7\u53d6\u7b2c i \u4e2a\u5e94\u7528\u5728 .data \u6bb5\u4e2d\u7684\u8d77\u59cb\u5730\u5740 \u548c \u957f\u5ea6 let dst = unsafe { core::slice::from_raw_parts_mut(base_i as *mut u8, src.len()) }; // \u5c06\u521a\u624d\u7528 0 \u586b\u5145\u7684\u8d77\u59cb\u5730\u5740 \u548c \u5e94\u7528\u7684\u957f\u5ea6\u5c01\u88c5\u8d77\u6765 dst.copy_from_slice(src); // \u5c06\u7b2c i \u4e2a\u5e94\u7528 \u4ece .data \u6bb5\u52a0\u8f7d\u5230 \u4e0a\u9762\u5bf9\u5e94\u7684\u5730\u5740\u7a7a\u95f4 } } pub fn init_app_cx(app_id: usize) -> usize { // \u6784\u9020\u8be5\u4efb\u52a1\u7684 Trap \u4e0a\u4e0b\u6587\uff08\u5305\u62ec\u5e94\u7528\u5165\u53e3\u5730\u5740\u548c\u7528\u6237\u6808\u6307\u9488\uff09\u5e76\u5c06\u5176\u538b\u5165\u5230\u5185\u6838\u6808\u9876 KERNEL_STACK[app_id].push_context( TrapContext::app_init_context(get_base_i(app_id), USER_STACK[app_id].get_sp()), ) }","title":"os/src/loader.rs"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%8D%8F%E4%BD%9C%E5%BC%8F%E8%B0%83%E7%94%A8/#ossrcmainrs","text":"#![no_std] #![no_main] #![feature(panic_info_message)] use core::arch::global_asm; #[macro_use] mod console; mod lang_items; mod sbi; mod syscall; mod trap; mod loader; mod config; mod task; mod sync; global_asm!(include_str!(\"entry.asm\")); global_asm!(include_str!(\"link_app.S\")); fn clear_bss() { extern \"C\" { fn sbss(); fn ebss(); } unsafe { core::slice::from_raw_parts_mut( sbss as usize as *mut u8, ebss as usize - sbss as usize, ).fill(0); } } #[no_mangle] pub fn rust_main() -> ! { clear_bss(); println!(\"[kernel] Hello, world!\"); trap::init(); loader::load_apps(); task::run_first_task(); panic!(\"Unreachable in rust_main!\"); }","title":"os/src/main.rs"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%8D%8F%E4%BD%9C%E5%BC%8F%E8%B0%83%E7%94%A8/#osmakefile","text":"# Building TARGET := riscv64gc-unknown-none-elf MODE := release KERNEL_ELF := target/$(TARGET)/$(MODE)/os KERNEL_BIN := $(KERNEL_ELF).bin DISASM_TMP := target/$(TARGET)/$(MODE)/asm # BOARD BOARD ?= qemu SBI ?= rustsbi BOOTLOADER := ../bootloader/$(SBI)-$(BOARD).bin K210_BOOTLOADER_SIZE := 131072 # KERNEL ENTRY ifeq ($(BOARD), qemu) KERNEL_ENTRY_PA := 0x80200000 else ifeq ($(BOARD), k210) KERNEL_ENTRY_PA := 0x80020000 endif # Run K210 K210-SERIALPORT = /dev/ttyUSB0 K210-BURNER = ../tools/kflash.py # Binutils OBJDUMP := rust-objdump --arch-name=riscv64 OBJCOPY := rust-objcopy --binary-architecture=riscv64 # Disassembly DISASM ?= -x build: env switch-check $(KERNEL_BIN) switch-check: ifeq ($(BOARD), qemu) (which last-qemu) || (rm last-k210 -f && touch last-qemu && make clean) else ifeq ($(BOARD), k210) (which last-k210) || (rm last-qemu -f && touch last-k210 && make clean) endif env: rustup component add rust-src rustup component add llvm-tools-preview cargo install cargo-binutils --vers =0.3.3 rustup target add riscv64gc-unknown-none-elf $(KERNEL_BIN): kernel @$(OBJCOPY) $(KERNEL_ELF) --strip-all -O binary $@ kernel: @cd ../user && make build @echo Platform: $(BOARD) @cp src/linker-$(BOARD).ld src/linker.ld @cargo build --release @rm src/linker.ld clean: @cargo clean disasm: kernel @$(OBJDUMP) $(DISASM) $(KERNEL_ELF) | less disasm-vim: kernel @$(OBJDUMP) $(DISASM) $(KERNEL_ELF) > $(DISASM_TMP) @vim $(DISASM_TMP) @rm $(DISASM_TMP) run: run-inner run-inner: build ifeq ($(BOARD),qemu) @qemu-system-riscv64 \\ -machine virt \\ -nographic \\ -bios $(BOOTLOADER) \\ -device loader,file=$(KERNEL_BIN),addr=$(KERNEL_ENTRY_PA) else (which $(K210-BURNER)) || (cd .. && git clone https://github.com/sipeed/kflash.py.git && mv kflash.py tools) @cp $(BOOTLOADER) $(BOOTLOADER).copy @dd if=$(KERNEL_BIN) of=$(BOOTLOADER).copy bs=$(K210_BOOTLOADER_SIZE) seek=1 @mv $(BOOTLOADER).copy $(KERNEL_BIN) @sudo chmod 777 $(K210-SERIALPORT) python3 $(K210-BURNER) -p $(K210-SERIALPORT) -b 1500000 $(KERNEL_BIN) python3 -m serial.tools.miniterm --eol LF --dtr 0 --rts 0 --filter direct $(K210-SERIALPORT) 115200 endif debug: build @tmux new-session -d \\ \"qemu-system-riscv64 -machine virt -nographic -bios $(BOOTLOADER) -device loader,file=$(KERNEL_BIN),addr=$(KERNEL_ENTRY_PA) -s -S\" && \\ tmux split-window -h \"riscv64-unknown-elf-gdb -ex 'file $(KERNEL_ELF)' -ex 'set arch riscv:rv64' -ex 'target remote localhost:1234'\" && \\ tmux -2 attach-session -d .PHONY: build env kernel clean disasm disasm-vim run-inner switch-check","title":"os/Makefile"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%8D%8F%E4%BD%9C%E5%BC%8F%E8%B0%83%E7%94%A8/#user","text":"","title":"\u5728 user \u6587\u4ef6\u5939\u4e0b"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%8D%8F%E4%BD%9C%E5%BC%8F%E8%B0%83%E7%94%A8/#usercargoconfig","text":"[build] target = \"riscv64gc-unknown-none-elf\" [target.riscv64gc-unknown-none-elf] rustflags = [ \"-Clink-args=-Tsrc/linker.ld\", ]","title":"user/.cargo/config"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%8D%8F%E4%BD%9C%E5%BC%8F%E8%B0%83%E7%94%A8/#usercargotoml","text":"[package] name = \"user_lib\" version = \"0.1.0\" authors = [\"Yifan Wu <shinbokuow@163.com>\"] edition = \"2018\" # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html [dependencies]","title":"user/Cargo.toml"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%8D%8F%E4%BD%9C%E5%BC%8F%E8%B0%83%E7%94%A8/#userbuildpy","text":"import os base_address = 0x80400000 step = 0x20000 linker = 'src/linker.ld' app_id = 0 apps = os.listdir('src/bin') # \u5f97\u5230\u4e00\u4e2a\u5217\u8868\uff0c \u91cc\u9762\u662f \u6587\u4ef6\u540d apps.sort() for app in apps: app = app[:app.find('.')] # app \u53d8\u6210\u4e0d\u5e26\u540e\u7f00\u7684\u6587\u4ef6\u540d lines = [] lines_before = [] with open(linker, 'r') as f: for line in f.readlines(): lines_before.append(line) line = line.replace(hex(base_address), hex(base_address+step*app_id)) lines.append(line) with open(linker, 'w+') as f: f.writelines(lines) # \u627e\u5230 src/linker.ld \u4e2d\u7684 BASE_ADDRESS = 0x80400000; # \u8fd9\u4e00\u884c\uff0c\u5e76\u5c06\u540e\u9762\u7684\u5730\u5740\u66ff\u6362\u4e3a\u548c\u5f53\u524d\u5e94\u7528\u5bf9\u5e94\u7684\u4e00\u4e2a\u5730\u5740 os.system('cargo build --bin %s --release' % app) # \u4f7f\u7528 --bin \u53c2\u6570\u6765\u53ea\u6784\u5efa\u67d0\u4e00\u4e2a\u5e94\u7528 # \u90a3\u5c31\u662f\u5bf9\u6bcf\u4e2a\u5e94\u7528\u5206\u522b\u8fdb\u884c\u7f16\u8bd1 \u6539\u53d8\u5176 \u8d77\u59cb\u5730\u5740 print('[build.py] application %s start with address %s' %(app, hex(base_address+step*app_id))) with open(linker, 'w+') as f: f.writelines(lines_before) # \u5c06 linker.ld \u590d\u539f\uff0c \u73b0\u5728\u7684 base_address = 0x80400000+step*app_id # \u6062\u590d\u4e3a 0x80400000 app_id = app_id + 1","title":"user/build.py"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%8D%8F%E4%BD%9C%E5%BC%8F%E8%B0%83%E7%94%A8/#usersrcconsolers","text":"use core::fmt::{self, Write}; use super::write; struct Stdout; const STDOUT: usize = 1; impl Write for Stdout { fn write_str(&mut self, s: &str) -> fmt::Result { write(STDOUT, s.as_bytes()); Ok(()) } } pub fn print(args: fmt::Arguments) { Stdout.write_fmt(args).unwrap(); } #[macro_export] macro_rules! print { ($fmt: literal $(, $($arg: tt)+)?) => { $crate::console::print(format_args!($fmt $(, $($arg)+)?)); } } #[macro_export] macro_rules! println { ($fmt: literal $(, $($arg: tt)+)?) => { $crate::console::print(format_args!(concat!($fmt, \"\\n\") $(, $($arg)+)?)); } }","title":"user/src/console.rs"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%8D%8F%E4%BD%9C%E5%BC%8F%E8%B0%83%E7%94%A8/#usersrclang_itemsrs","text":"#[panic_handler] fn panic_handler(panic_info: &core::panic::PanicInfo) -> ! { let err = panic_info.message().unwrap(); if let Some(location) = panic_info.location() { println!(\"Panicked at {}:{}, {}\", location.file(), location.line(), err); } else { println!(\"Panicked: {}\", err); } loop {} }","title":"user/src/lang_items.rs"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%8D%8F%E4%BD%9C%E5%BC%8F%E8%B0%83%E7%94%A8/#usersrclibrs","text":"#![no_std] #![feature(linkage)] #![feature(panic_info_message)] #[macro_use] pub mod console; mod syscall; mod lang_items; #[no_mangle] #[link_section = \".text.entry\"] pub extern \"C\" fn _start() -> ! { clear_bss(); exit(main()); panic!(\"unreachable after sys_exit!\"); } #[linkage = \"weak\"] #[no_mangle] fn main() -> i32 { panic!(\"Cannot find main!\"); } fn clear_bss() { extern \"C\" { fn start_bss(); fn end_bss(); } (start_bss as usize..end_bss as usize).for_each(|addr| { unsafe { (addr as *mut u8).write_volatile(0); } }); } use syscall::*; pub fn write(fd: usize, buf: &[u8]) -> isize { sys_write(fd, buf) } pub fn exit(exit_code: i32) -> isize { sys_exit(exit_code) } pub fn yield_() -> isize { sys_yield() }","title":"user/src/lib.rs"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%8D%8F%E4%BD%9C%E5%BC%8F%E8%B0%83%E7%94%A8/#usersrclinkerld","text":"OUTPUT_ARCH(riscv) ENTRY(_start) BASE_ADDRESS = 0x80400000; SECTIONS { . = BASE_ADDRESS; .text : { *(.text.entry) *(.text .text.*) } .rodata : { *(.rodata .rodata.*) *(.srodata .srodata.*) } .data : { *(.data .data.*) *(.sdata .sdata.*) } .bss : { start_bss = .; *(.bss .bss.*) *(.sbss .sbss.*) end_bss = .; } /DISCARD/ : { *(.eh_frame) *(.debug*) } }","title":"user/src/linker.ld"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%8D%8F%E4%BD%9C%E5%BC%8F%E8%B0%83%E7%94%A8/#usersrcsyscallrs","text":"use core::arch::asm; const SYSCALL_WRITE: usize = 64; const SYSCALL_EXIT: usize = 93; const SYSCALL_YIELD: usize = 124; fn syscall(id: usize, args: [usize; 3]) -> isize { let mut ret: isize; unsafe { asm!( \"ecall\", inlateout(\"x10\") args[0] => ret, in(\"x11\") args[1], in(\"x12\") args[2], in(\"x17\") id ); } ret } pub fn sys_write(fd: usize, buffer: &[u8]) -> isize { syscall(SYSCALL_WRITE, [fd, buffer.as_ptr() as usize, buffer.len()]) } pub fn sys_exit(exit_code: i32) -> isize { syscall(SYSCALL_EXIT, [exit_code as usize, 0, 0]) } pub fn sys_yield() -> isize { syscall(SYSCALL_YIELD, [0, 0, 0]) }","title":"user/src/syscall.rs"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%8D%8F%E4%BD%9C%E5%BC%8F%E8%B0%83%E7%94%A8/#usersrclibrs_1","text":"#![no_std] #![feature(linkage)] #![feature(panic_info_message)] #[macro_use] pub mod console; mod syscall; mod lang_items; #[no_mangle] #[link_section = \".text.entry\"] pub extern \"C\" fn _start() -> ! { clear_bss(); exit(main()); panic!(\"unreachable after sys_exit!\"); } #[linkage = \"weak\"] #[no_mangle] fn main() -> i32 { panic!(\"Cannot find main!\"); } fn clear_bss() { extern \"C\" { fn start_bss(); fn end_bss(); } (start_bss as usize..end_bss as usize).for_each(|addr| { unsafe { (addr as *mut u8).write_volatile(0); } }); } use syscall::*; pub fn write(fd: usize, buf: &[u8]) -> isize { sys_write(fd, buf) } pub fn exit(exit_code: i32) -> isize { sys_exit(exit_code) } pub fn yield_() -> isize { sys_yield() } // yield \u662f Rust \u7684\u5173\u952e\u5b57\uff0c\u56e0\u6b64\u6211\u4eec\u53ea\u80fd\u5c06\u5e94\u7528\u76f4\u63a5\u8c03\u7528\u7684\u63a5\u53e3\u547d\u540d\u4e3a yield_","title":"user/src/lib.rs"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%8D%8F%E4%BD%9C%E5%BC%8F%E8%B0%83%E7%94%A8/#usersrcbin00write_ars","text":"#![no_std] #![no_main] #[macro_use] extern crate user_lib; use user_lib::yield_; const WIDTH: usize = 10; const HEIGHT: usize = 5; #[no_mangle] fn main() -> i32 { for i in 0..HEIGHT { for _ in 0..WIDTH { print!(\"A\"); } println!(\" [{}/{}]\", i + 1, HEIGHT); yield_(); } println!(\"Test write_a OK!\"); 0 } user/src/bin/00write_b.rs #![no_std] #![no_main] #[macro_use] extern crate user_lib; use user_lib::yield_; const WIDTH: usize = 10; const HEIGHT: usize = 2; #[no_mangle] fn main() -> i32 { for i in 0..HEIGHT { for _ in 0..WIDTH { print!(\"B\"); } println!(\" [{}/{}]\", i + 1, HEIGHT); yield_(); } println!(\"Test write_b OK!\"); 0 } user/src/bin/00write_c.rs #![no_std] #![no_main] #[macro_use] extern crate user_lib; use user_lib::yield_; const WIDTH: usize = 10; const HEIGHT: usize = 3; #[no_mangle] fn main() -> i32 { for i in 0..HEIGHT { for _ in 0..WIDTH { print!(\"C\"); } println!(\" [{}/{}]\", i + 1, HEIGHT); yield_(); } println!(\"Test write_c OK!\"); 0 }","title":"user/src/bin/00write_a.rs"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%8D%8F%E4%BD%9C%E5%BC%8F%E8%B0%83%E7%94%A8/#usermakefile","text":"TARGET := riscv64gc-unknown-none-elf MODE := release APP_DIR := src/bin TARGET_DIR := target/$(TARGET)/$(MODE) APPS := $(wildcard $(APP_DIR)/*.rs) ELFS := $(patsubst $(APP_DIR)/%.rs, $(TARGET_DIR)/%, $(APPS)) BINS := $(patsubst $(APP_DIR)/%.rs, $(TARGET_DIR)/%.bin, $(APPS)) OBJDUMP := rust-objdump --arch-name=riscv64 OBJCOPY := rust-objcopy --binary-architecture=riscv64 elf: $(APPS) @python3 build.py binary: elf $(foreach elf, $(ELFS), $(OBJCOPY) $(elf) --strip-all -O binary $(patsubst $(TARGET_DIR)/%, $(TARGET_DIR)/%.bin, $(elf));) build: binary clean: @cargo clean .PHONY: elf binary build clean","title":"user/Makefile"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%8D%8F%E4%BD%9C%E5%BC%8F%E8%B0%83%E7%94%A8/#_5","text":"os/src/main.rs - \u5bfc\u5165 entry.asm \u8bbe\u7f6e\u51fd\u6570\u6808\uff0c \u8df3\u8f6c\u5230rust_main \u5bfc\u5165 link_app.S \u8fd9\u91cc\u5168\u662f\u6570\u636e\u6bb5\uff0c \u53ef\u6267\u884c\u6587\u4ef6\u5728\u90e8\u5206\u6570\u636e\u6bb5\u4e2d \u8c03\u7528 clear_bass \u51fd\u6570\uff0c \u6e05\u9664 \u9664 .bss.stack \u4ee5\u5916\u7684 .bss \u6bb5 \u8c03\u7528 println! \u6253\u5370 [kernel] Hello, world! , \u6b64\u65f6\u5904\u4e8e\u5185\u6838\u6001 \u8c03\u7528 trap::init os/src/trap/mod.rs \u6211\u4eec\u9700\u8981\u4fee\u6539stvec \u5bc4\u5b58\u5668\u6765\u6307\u5411\u6b63\u786e\u7684Trap\u5904\u7406\u5165\u53e3\u70b9 \u5c06stvec\u8bbe\u7f6e\u4e3aDirect\u6a21\u5f0f\u6307\u5411\u5b83\u7684\u5730\u5740 \u6ce8\u610f\uff1a\u7531\u4e8e\u524d\u9762\u6709\u5bfc\u5165 trap.S\uff0c \u6240\u6709\u8fd9\u91cc\u77e5\u9053 Trap\u7684\u5904\u7406\u5165\u53e3 \u5373 __alltraps \u8c03\u7528 loader::load_apps os/src/loader.rs \u8c03\u7528 get_num_app \u83b7\u53d6\u5e94\u7528\u4e2a\u6570 \u83b7\u53d6\u7b2c\u4e00\u4e2a\u7a0b\u5e8f\u7684\u5165\u53e3\u5730\u5740 \u5237\u65b0\u6307\u4ee4\u7f13\u51b2\u533a \u8c03\u7528 get_base_i \u83b7\u53d6 \u6bcf\u4e2a\u5e94\u7528\u7a0b\u5e8f\u7684\u8d77\u59cb\u5730\u5740 \u5c06\u6bcf\u4e2a\u5e94\u7528\u8d77\u59cb\u5730\u5740\u5230 \u5e94\u7528\u7a7a\u95f4\u9650\u5236\u8303\u56f4\u7684\u5730\u5740\u533a\u95f4 \u7528 0 \u586b\u5145 \u83b7\u53d6\u6bcf\u4e2a\u5e94\u7528\u5728 .data \u6bb5\u7684\u8d77\u59cb\u5730\u5740\u548c\u5927\u5c0f \u548c \u5728\u5c06\u4f1a\u653e\u7f6e\u8be5\u7a0b\u5e8f\u7684\u8d77\u59cb\u5730\u5740\u548c\u7a0b\u5e8f\u5927\u5c0f \u8c03\u7528 copy_from_slice \u5c06\u7a0b\u5e8f\u4ece .data \u6bb5\u590d\u5236\u5230 \u76f8\u5e94\u7684\u5730\u5740\u533a\u95f4 \u81f3\u6b64\uff0c\u7a0b\u5e8f\u52a0\u8f7d\u5b8c\u6bd5 os/src/main.rs - \u8c03\u7528 task \u6a21\u5757\u7684 run_first_task os/src/task/mod.rs \u9996\u5148\uff0c\u9759\u6001\u52a0\u8f7d\u4e00\u4e2a\u5168\u5c40\u7684\u4efb\u52a1\u7ba1\u7406\u5668 TaskManager \u7ed3\u6784 \u7684\u5b9e\u4f8b TASK_MANAGER,\u5305\u542b num_app \u548c inner inner \u5305\u62ec \u6570\u7ec4 tasks \u548c current_task \u6570\u7ec4 tasks \u662f TaskControlBlock \u7ed3\u6784\u7684\u6570\u7ec4 TaskControlBlock \u7ed3\u6784\u4f53 \u5305\u62ec \u4efb\u52a1\u72b6\u6001 task_status \u548c \u4efb\u52a1\u4e0a\u4e0b\u6587 TaskContext TaskContext \u5305\u542b \u90a314\u4e2a\u5bc4\u5b58\u5668 \u5bf9\u4efb\u52a1\u6570\u7ec4\u8fdb\u884c\u521d\u59cb\u5316\uff0c\u5c06\u6bcf\u4e2a\u4efb\u52a1\u90fd\u8fdb\u884c\u521d\u59cb\u5316 \u5bf9\u4efb\u52a1\u4e0a\u4e0b\u6587\u8c03\u7528 zero_init \u8fdb\u884c\u521d\u59cb\u5316\uff0c\u5373\u5c06\u8fd9 14 \u4e2a\u5bc4\u5b58\u5668\u90fd\u521d\u59cb\u5316\u4e3a 0 \u5c06\u4efb\u52a1\u7684\u72b6\u6001 \u8bbe\u7f6e\u4e3a UnInit, \u5373\u672a\u521d\u59cb\u5316 \u5bf9\u4e8e\u6bcf\u4e2a\u4efb\u52a1\uff0c\u5148\u8c03\u7528 init_app_cx, \u6784\u9020\u8be5\u4efb\u52a1\u7684 Trap \u4e0a\u4e0b\u6587 \u5728 os/src/loader.rs \u83b7\u53d6\u6bcf\u4e2a\u5e94\u7528\u7684 \u8d77\u59cb\u5730\u5740 \u548c \u6808\u9488 \u521d\u59cb\u5316\u5b83\u7684 Trap \u4e0a\u4e0b\u6587 \u5728 os/src/trap/context.rs \u83b7\u53d6\u5f53\u524d\u7684 sstatus \u5e76\u5b58\u653e\u5728\u7ed3\u6784\u4e2d \u5c06\u8fd9\u4e2a sstatus \u7ed3\u6784\u7684 SPP\u7f6e\u4f4d User \u5c06\u901a\u7528\u5bc4\u5b58\u5668 \u5168\u7f6e\u4e3a 0 \u5c06 sepc \u8bbe\u4e3a\u4f20\u5165\u7684\u5e94\u7528\u7684\u5730\u5740 entry \u5c06 Trap\u4e0a\u4e0b\u6587\u7684 sp \u7f6e\u4e3a \u4f20\u5165\u7684 \u5185\u6838\u6808\u5730\u5740 sp \u8fd4\u56de Trap \u4e0a\u4e0b\u6587 \u5c06 Trap \u4e0a\u4e0b\u6587 push \u5230\u5185\u6838\u6808\u4e2d \u8fd4\u56de\u4e00\u4e2a \u6267\u884c\u6539\u4e0a\u4e0b\u6587\u7684 \u6307\u9488 \u5c06\u6307\u5411 Trap \u4e0a\u4e0b\u6587\u7684 \u6307\u9488 \u4f20\u5165\u5230 goto_restoren \u51fd\u6570\u4e2d \u7528\u5b83\u521d\u59cb\u5316\u4efb\u52a1\u4e0a\u4e0b\u6587 TaskContext \u5c06\u4efb\u52a1\u4e0a\u4e0b\u6587\u8fd4\u56de\u7ed9\u6bcf\u4e2a\u4efb\u52a1 \u5c06\u6bcf\u4e2a\u4efb\u52a1\u90fd\u7f6e\u4e3a Ready \u6700\u540e\uff0c\u83b7\u5f97\u4e00\u4e2a\u4efb\u52a1\u7ba1\u7406\u5668\uff0c\u5b83\u5305\u542b \u4efb\u52a1\u6570\uff0c\u4efb\u52a1\u6570\u7ec4\uff0c\u5f53\u524d\u4efb\u52a1\u7684\u7f16\u53f7 \u8fd9\u6837\uff0c\u9759\u6001\u52a0\u8f7d\u5668\u7684\u4efb\u52a1\u5b8c\u6210 \u8c03\u7528 run_first_task \u5c06\u7b2c\u4e00\u4e2a\u4efb\u52a1\u7684\u72b6\u6001\u7f6e\u4e3a Running \u521b\u5efa\u4e00\u4e2a\u6307\u9488 \u6307\u5411 \u7b2c\u4e00\u4e2a\u4efb\u52a1\u7684\u4efb\u52a1\u4e0a\u4e0b\u6587 \u6784\u9020\u4e00\u4e2a \u53ea\u6709\u4efb\u52a1\u4e0a\u4e0b\u6587\u7ed3\u6784\u800c\u65e0\u771f\u6b63\u5185\u5bb9\u7684 \u4efb\u52a1\u4e0a\u4e0b\u6587 \u5c06 \u8fd9\u4e24\u4e2a\u4e0a\u4e0b\u6587\u7684 \u6307\u9488\u9001\u7ed9 \u5207\u6362\u51fd\u6570 _switch _switch \u51fd\u6570\u5728\u5c06\u4ed6\u4eec\u9001\u5230 \u6c47\u7f16\u51fd\u6570 _switch \u4e2d \u4fdd\u5b58\u5f53\u524d\u4efb\u52a1\u7684 \u6808\u6bb5\uff0c \u4fdd\u5b58\u5f53\u524d \u4efb\u52a1\u4e0a\u4e0b\u6587\uff0c \u6062\u590d\u4e0b\u4e00\u4e2a\u4efb\u52a1\u4e0a\u4e0b\u6587\uff0c \u6062\u590d\u4e0b\u4e00\u4e2a\u4efb\u52a1\u7684 \u6808\u6bb5 ret \u8fd4\u56de\u5230 \u4e0b\u4e00\u4e2a\u4efb\u52a1\uff0c\u8fdb\u5165\u5230\u7528\u6237\u6001 user/src/bin/00write_a.rs - \u8fd0\u884c\u5b8c\u7b2c\u4e00\u6b21\u5faa\u73af\uff0c \u8c03\u7528 yield_ - \u8c03\u7528 user/src/lib.rs \u7684yield \u63a5\u53e3 - \u8c03\u7528 user/src/syscall.rs \u4e2d\u7684 sys_yield - syscall \u7cfb\u7edf\u8c03\u7528 \u8fdb\u884c Trap \u9677\u5165 - \u8df3\u8f6c\u5230 trap.S \u4e2d\u7684 __alltraps \u4e2d - \u5728\u5185\u6838\u6808\u4e2d\u4fdd\u5b58\u5f53\u524d\u4e0a\u4e0b\u6587 - call trap_handler \u8df3\u8f6c\u7684 trap_handler - \u89e6\u53d1 Trap \u7684 \u539f\u56e0\u662f\u6765\u81ea U\u6001\u7684 \u7cfb\u7edf\u8c03\u7528 - Trap\u4e0a\u4e0b\u6587\u7684 sepc \u5bc4\u5b58\u5668 +4 \uff0c\u6307\u5411syscall \u7684\u4e0b\u4e00\u6761\u6307\u4ee4 - \u4e0b\u4e00\u6761\u6307\u4ee4\u662f ret - \u518d\u6b64syscall\uff0c\u8fdb\u5165\u5185\u6838\u6001\u4e2d\u7cfb\u7edf\u8c03\u7528\u7684\u5904\u7406 - \u5728 os/src/syscall/mod.rs \u4e2d\u53c8\u8c03\u7528 sys_yield - os/src/syscall/process.rs \u4e2d sys_yield \u8c03\u7528 suspend_current_and_run_next - \u5728 os/src/task/mod.rs \u4e2d - \u8c03\u7528 mark_current_suspended - \u5c06\u5f53\u524d\u4efb\u52a1\u7684\u72b6\u6001 task_status \u7f6e\u4e3a Ready - \u8c03\u7528 run_next_task - \u8c03\u7528 find_next_task, \u52a0\u4e00\u518d mod \u5faa\u73af\uff0c\u627e\u5224\u65ad\u4efb\u52a1\u7684\u72b6\u6001\u662f\u5426\u4e3a Ready, - \u5982\u679c\u627e\u5230\u4e0b\u4e00\u4e2a\u4efb\u52a1\uff0c\u5c06\u4e0b\u4e00\u4e2a\u4efb\u52a1\u7684\u72b6\u6001\u7f6e\u4e3a Running - \u83b7\u53d6\u6307\u5411 \u5f53\u524d\u4efb\u52a1 \u548c \u4e0b\u4e00\u4e2a\u4efb\u52a1 \u7684\u5730\u5740\u7684\u6307\u9488 - \u8c03\u7528 _switch \u51fd\u6570 - _switch \u4fdd\u5b58\u6062\u590d\u4e0a\u4e0b\u6587\u540e\uff0cret\uff0c\u8fd4\u56de\u5230\u7528\u6237\u6001 \u5f53\u5e94\u7528\u5b8c\u6210\u4e86\uff0c \u6253\u5370 Test write_a OK! user/src/lib.rs \u8c03\u7528 exit\uff0cexit \u8c03\u7528 sys_exit user/src/syscall.rs \u4e2d sys_exit \u8fdb\u884c \u7cfb\u7edf\u8c03\u7528 syscall , \u5f15\u53d1 ecall \u8df3\u8f6c\u5230 __alltraps \u8df3\u8f6c\u5230 os/src/syscall/mod.rs \u4e2d\u7684 sys_exit os/src/syscall/process.rs \u4e2d\u7684 sys_exit \u5148\u6253\u5370 [kernel] Application exited with code 0 \u7136\u540e\u8c03\u7528 exit_current_and_run_next \u518d\u6b21\u8fd4\u56de\u5230 os/src/task/mod.rs \u5148\u5c06 \u5f53\u524d\u4efb\u52a1\u7684\u72b6\u6001\u6807\u8bb0\u4e3a Exited \u518d\u8c03\u7528 run_next_task \u5982\u679c\u6240\u6709\u7684\u4efb\u52a1\u90fd\u5b8c\u6210\u4e86\uff0c\u5c31 panic \u6253\u5370\u51fa All applications completed! \u6253\u5370 panic \u7684\u4f4d\u7f6e \u8c03\u7528 shutdown \u5173\u673a","title":"\u6267\u884c\u6d41\u7a0b"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E6%94%AF%E6%8C%81%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F/","text":"\u5b9e\u73b0\u652f\u6301\u591a\u9053\u7a0b\u5e8f\u7684\u64cd\u4f5c\u7cfb\u7edf \u7b2c\u4e09\u7ae0\u4ee3\u7801\u6811 \u5206\u65f6\u591a\u4efb\u52a1\u7684\u4e3a\u4f8b ./os/src Rust 18 Files 511 Lines Assembly 3 Files 82 Lines \u251c\u2500\u2500 bootloader \u2502 \u251c\u2500\u2500 rustsbi-k210.bin \u2502 \u2514\u2500\u2500 rustsbi-qemu.bin \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 os \u2502 \u251c\u2500\u2500 build.rs \u2502 \u251c\u2500\u2500 Cargo.toml \u2502 \u251c\u2500\u2500 Makefile \u2502 \u2514\u2500\u2500 src \u2502 \u251c\u2500\u2500 batch.rs(\u79fb\u9664\uff1a\u529f\u80fd\u5206\u522b\u62c6\u5206\u5230 loader \u548c task \u4e24\u4e2a\u5b50\u6a21\u5757) \u2502 \u251c\u2500\u2500 config.rs(\u65b0\u589e\uff1a\u4fdd\u5b58\u5185\u6838\u7684\u4e00\u4e9b\u914d\u7f6e) \u2502 \u251c\u2500\u2500 console.rs \u2502 \u251c\u2500\u2500 entry.asm \u2502 \u251c\u2500\u2500 lang_items.rs \u2502 \u251c\u2500\u2500 link_app.S \u2502 \u251c\u2500\u2500 linker-k210.ld \u2502 \u251c\u2500\u2500 linker-qemu.ld \u2502 \u251c\u2500\u2500 loader.rs(\u65b0\u589e\uff1a\u5c06\u5e94\u7528\u52a0\u8f7d\u5230\u5185\u5b58\u5e76\u8fdb\u884c\u7ba1\u7406) \u2502 \u251c\u2500\u2500 main.rs(\u4fee\u6539\uff1a\u4e3b\u51fd\u6570\u8fdb\u884c\u4e86\u4fee\u6539) \u2502 \u251c\u2500\u2500 sbi.rs(\u4fee\u6539\uff1a\u5f15\u5165\u65b0\u7684 sbi call set_timer) \u2502 \u251c\u2500\u2500 sync \u2502 \u2502 \u251c\u2500\u2500 mod.rs \u2502 \u2502 \u2514\u2500\u2500 up.rs \u2502 \u251c\u2500\u2500 syscall(\u4fee\u6539\uff1a\u65b0\u589e\u82e5\u5e72 syscall) \u2502 \u2502 \u251c\u2500\u2500 fs.rs \u2502 \u2502 \u251c\u2500\u2500 mod.rs \u2502 \u2502 \u2514\u2500\u2500 process.rs \u2502 \u251c\u2500\u2500 task(\u65b0\u589e\uff1atask \u5b50\u6a21\u5757\uff0c\u4e3b\u8981\u8d1f\u8d23\u4efb\u52a1\u7ba1\u7406) \u2502 \u2502 \u251c\u2500\u2500 context.rs(\u5f15\u5165 Task \u4e0a\u4e0b\u6587 TaskContext) \u2502 \u2502 \u251c\u2500\u2500 mod.rs(\u5168\u5c40\u4efb\u52a1\u7ba1\u7406\u5668\u548c\u63d0\u4f9b\u7ed9\u5176\u4ed6\u6a21\u5757\u7684\u63a5\u53e3) \u2502 \u2502 \u251c\u2500\u2500 switch.rs(\u5c06\u4efb\u52a1\u5207\u6362\u7684\u6c47\u7f16\u4ee3\u7801\u89e3\u91ca\u4e3a Rust \u63a5\u53e3 __switch) \u2502 \u2502 \u251c\u2500\u2500 switch.S(\u4efb\u52a1\u5207\u6362\u7684\u6c47\u7f16\u4ee3\u7801) \u2502 \u2502 \u2514\u2500\u2500 task.rs(\u4efb\u52a1\u63a7\u5236\u5757 TaskControlBlock \u548c\u4efb\u52a1\u72b6\u6001 TaskStatus \u7684\u5b9a\u4e49) \u2502 \u251c\u2500\u2500 timer.rs(\u65b0\u589e\uff1a\u8ba1\u65f6\u5668\u76f8\u5173) \u2502 \u2514\u2500\u2500 trap \u2502 \u251c\u2500\u2500 context.rs \u2502 \u251c\u2500\u2500 mod.rs(\u4fee\u6539\uff1a\u65f6\u949f\u4e2d\u65ad\u76f8\u5e94\u5904\u7406) \u2502 \u2514\u2500\u2500 trap.S \u251c\u2500\u2500 README.md \u251c\u2500\u2500 rust-toolchain \u251c\u2500\u2500 tools \u2502 \u251c\u2500\u2500 kflash.py \u2502 \u251c\u2500\u2500 LICENSE \u2502 \u251c\u2500\u2500 package.json \u2502 \u251c\u2500\u2500 README.rst \u2502 \u2514\u2500\u2500 setup.py \u2514\u2500\u2500 user \u251c\u2500\u2500 build.py(\u65b0\u589e\uff1a\u4f7f\u7528 build.py \u6784\u5efa\u5e94\u7528\u4f7f\u5f97\u5b83\u4eec\u5360\u7528\u7684\u7269\u7406\u5730\u5740\u533a\u95f4\u4e0d\u76f8\u4ea4) \u251c\u2500\u2500 Cargo.toml \u251c\u2500\u2500 Makefile(\u4fee\u6539\uff1a\u4f7f\u7528 build.py \u6784\u5efa\u5e94\u7528) \u2514\u2500\u2500 src \u251c\u2500\u2500 bin(\u4fee\u6539\uff1a\u6362\u6210\u7b2c\u4e09\u7ae0\u6d4b\u4f8b) \u2502 \u251c\u2500\u2500 00power_3.rs \u2502 \u251c\u2500\u2500 01power_5.rs \u2502 \u251c\u2500\u2500 02power_7.rs \u2502 \u2514\u2500\u2500 03sleep.rs \u251c\u2500\u2500 console.rs \u251c\u2500\u2500 lang_items.rs \u251c\u2500\u2500 lib.rs \u251c\u2500\u2500 linker.ld \u2514\u2500\u2500 syscall.rs \u672c\u8282\u7684\u4efb\u52a1 \u672c\u7ae0\u6240\u4ecb\u7ecd\u7684\u591a\u9053\u7a0b\u5e8f\u548c\u5206\u65f6\u591a\u4efb\u52a1\u7cfb\u7edf\u90fd\u6709\u4e00\u4e9b\u5171\u540c\u7684\u7279\u70b9\uff1a\u5728\u5185\u5b58\u4e2d\u540c\u4e00\u65f6\u95f4\u53ef\u4ee5\u9a7b\u7559\u591a\u4e2a\u5e94\u7528\uff0c\u800c\u4e14\u6240\u6709\u7684\u5e94\u7528\u90fd\u662f\u5728\u7cfb\u7edf\u542f\u52a8\u7684\u65f6\u5019\u5206\u522b\u52a0\u8f7d\u5230\u5185\u5b58\u7684\u4e0d\u540c\u533a\u57df\u4e2d\u3002\u7531\u4e8e\u76ee\u524d\u8ba1\u7b97\u673a\u7cfb\u7edf\u4e2d\u53ea\u6709\u4e00\u4e2a\u5904\u7406\u5668\u6838\uff0c\u6240\u4ee5\u540c\u4e00\u65f6\u95f4\u6700\u591a\u53ea\u6709\u4e00\u4e2a\u5e94\u7528\u5728\u6267\u884c\uff08\u5373\u5904\u4e8e\u8fd0\u884c\u72b6\u6001\uff09\uff0c\u5269\u4e0b\u7684\u5e94\u7528\u5904\u4e8e\u5c31\u7eea\u72b6\u6001\u6216\u7b49\u5f85\u72b6\u6001\uff0c\u9700\u8981\u5185\u6838\u5c06\u5904\u7406\u5668\u5206\u914d\u7ed9\u5b83\u4eec\u624d\u80fd\u5f00\u59cb\u6267\u884c\u3002\u4e00\u65e6\u5e94\u7528\u5f00\u59cb\u6267\u884c\uff0c\u5b83\u5c31\u5904\u4e8e\u8fd0\u884c\u72b6\u6001\u4e86 \u672c\u8282\u7684\u4efb\u52a1\u662f\u5b9e\u73b0\u4e00\u4e2a\u53ef\u4ee5\u628a\u591a\u4e2a\u5e94\u7528\u653e\u7f6e\u5728\u5185\u5b58\u4e2d\u7684\u64cd\u4f5c\u7cfb\u7edf \u6211\u4eec\u9700\u8981\u5c06\u6bcf\u4e2a\u5e94\u7528\u6309\u5b83\u7684\u7f16\u53f7\u5206\u522b\u653e\u7f6e\u5e76\u52a0\u8f7d\u5230\u5185\u5b58\u4e2d\u7684\u4e0d\u540c\u4f4d\u7f6e \u8fd9\u91cc\uff0c\u6bcf\u4e2a\u5e94\u7528\u9700\u8981\u77e5\u9053\u81ea\u5df1\u8fd0\u884c\u65f6\u5728\u5185\u5b58\u4e2d\u7684\u4e0d\u540c\u4f4d\u7f6e\uff0c \u64cd\u4f5c\u7cfb\u7edf\u4e5f\u8981\u77e5\u9053\u6bcf\u4e2a\u5e94\u7528\u7a0b\u5e8f\u8fd0\u884c\u65f6\u7684\u4f4d\u7f6e\uff0c\u4e0d\u80fd\u4efb\u610f\u79fb\u52a8\u5e94\u7528\u7a0b\u5e8f\u6240\u5728\u7684\u5185\u5b58\u7a7a\u95f4\uff0c\u5373\u4e0d\u80fd\u5728\u8fd0\u884c\u65f6\u6839\u636e\u5185\u5b58\u7a7a\u95f4\u7684\u52a8\u6001\u7a7a\u95f2\u60c5\u51b5\uff0c\u628a\u5e94\u7528\u7a0b\u5e8f\u8c03\u6574\u5230\u5408\u9002\u7684\u7a7a\u95f2\u7a7a\u95f4\u4e2d \u672c\u8282\u6587\u4ef6\u89e3\u6790 \u5728 os \u6587\u4ef6\u5939\u4e0b os/src/loader.rs use crate::trap::TrapContext; use crate::config::*; use core::arch::asm; #[repr(align(4096))] #[derive(Copy, Clone)] struct KernelStack { data: [u8; KERNEL_STACK_SIZE], } #[repr(align(4096))] #[derive(Copy, Clone)] struct UserStack { data: [u8; USER_STACK_SIZE], } static KERNEL_STACK: [KernelStack; MAX_APP_NUM] = [ KernelStack { data: [0; KERNEL_STACK_SIZE], }; MAX_APP_NUM ]; static USER_STACK: [UserStack; MAX_APP_NUM] = [ UserStack { data: [0; USER_STACK_SIZE], }; MAX_APP_NUM ]; impl KernelStack { fn get_sp(&self) -> usize { self.data.as_ptr() as usize + KERNEL_STACK_SIZE } pub fn push_context(&self, trap_cx: TrapContext) -> usize { let trap_cx_ptr = (self.get_sp() - core::mem::size_of::<TrapContext>()) as *mut TrapContext; unsafe { *trap_cx_ptr = trap_cx; } trap_cx_ptr as usize } } impl UserStack { fn get_sp(&self) -> usize { self.data.as_ptr() as usize + USER_STACK_SIZE } } fn get_base_i(app_id: usize) -> usize { APP_BASE_ADDRESS + app_id * APP_SIZE_LIMIT } // \u83b7\u53d6\u7b2c i \u4e2a\u5e94\u7528\u7684\u8d77\u59cb\u5730\u5740 pub fn get_num_app() -> usize { extern \"C\" { fn _num_app(); } unsafe { (_num_app as usize as *const usize).read_volatile() } } // \u83b7\u53d6 _num_app, \u5373\u5e94\u7528\u7684\u4e2a\u6570 pub fn load_apps() { extern \"C\" { fn _num_app(); } let num_app_ptr = _num_app as usize as *const usize; let num_app = get_num_app(); let app_start = unsafe { core::slice::from_raw_parts(num_app_ptr.add(1), num_app + 1) }; // clear i-cache first unsafe { asm!(\"fence.i\"); } // load apps for i in 0..num_app { let base_i = get_base_i(i); // \u83b7\u53d6\u7b2c i \u4e2a\u5e94\u7528\u7684\u8d77\u59cb\u5730\u5740 (base_i..base_i + APP_SIZE_LIMIT).for_each(|addr| unsafe { (addr as *mut u8).write_volatile(0) }); // \u5c06\u7528\u4e8e\u5b58\u653e\u7b2c i \u4e2a\u5e94\u7528\u7684\u5730\u5740\u533a\u95f4 \u7528 0 \u586b\u5145 let src = unsafe { core::slice::from_raw_parts(app_start[i] as *const u8, app_start[i + 1] - app_start[i]) }; // \u83b7\u53d6\u7b2c i \u4e2a\u5e94\u7528\u5728 .data \u6bb5\u4e2d\u7684\u8d77\u59cb\u5730\u5740 \u548c \u957f\u5ea6 let dst = unsafe { core::slice::from_raw_parts_mut(base_i as *mut u8, src.len()) }; // \u5c06\u521a\u624d\u7528 0 \u586b\u5145\u7684\u8d77\u59cb\u5730\u5740 \u548c \u5e94\u7528\u7684\u957f\u5ea6\u5c01\u88c5\u8d77\u6765 dst.copy_from_slice(src); // \u5c06\u7b2c i \u4e2a\u5e94\u7528 \u4ece .data \u6bb5\u52a0\u8f7d\u5230 \u4e0a\u9762\u5bf9\u5e94\u7684\u5730\u5740\u7a7a\u95f4 } } pub fn init_app_cx(app_id: usize) -> usize { KERNEL_STACK[app_id].push_context( TrapContext::app_init_context(get_base_i(app_id), USER_STACK[app_id].get_sp()), ) } \u5728 user \u6587\u4ef6\u5939\u4e0b user/build.py import os base_address = 0x80400000 step = 0x20000 linker = 'src/linker.ld' app_id = 0 apps = os.listdir('src/bin') # \u5f97\u5230\u4e00\u4e2a\u5217\u8868\uff0c \u91cc\u9762\u662f \u6587\u4ef6\u540d apps.sort() for app in apps: app = app[:app.find('.')] # app \u53d8\u6210\u4e0d\u5e26\u540e\u7f00\u7684\u6587\u4ef6\u540d lines = [] lines_before = [] with open(linker, 'r') as f: for line in f.readlines(): lines_before.append(line) line = line.replace(hex(base_address), hex(base_address+step*app_id)) lines.append(line) with open(linker, 'w+') as f: f.writelines(lines) # \u627e\u5230 src/linker.ld \u4e2d\u7684 BASE_ADDRESS = 0x80400000; # \u8fd9\u4e00\u884c\uff0c\u5e76\u5c06\u540e\u9762\u7684\u5730\u5740\u66ff\u6362\u4e3a\u548c\u5f53\u524d\u5e94\u7528\u5bf9\u5e94\u7684\u4e00\u4e2a\u5730\u5740 os.system('cargo build --bin %s --release' % app) # \u4f7f\u7528 --bin \u53c2\u6570\u6765\u53ea\u6784\u5efa\u67d0\u4e00\u4e2a\u5e94\u7528 # \u90a3\u5c31\u662f\u5bf9\u6bcf\u4e2a\u5e94\u7528\u5206\u522b\u8fdb\u884c\u7f16\u8bd1 \u6539\u53d8\u5176 \u8d77\u59cb\u5730\u5740 print('[build.py] application %s start with address %s' %(app, hex(base_address+step*app_id))) with open(linker, 'w+') as f: f.writelines(lines_before) # \u5c06 linker.ld \u590d\u539f\uff0c \u73b0\u5728\u7684 base_address = 0x80400000+step*app_id # \u6062\u590d\u4e3a 0x80400000 app_id = app_id + 1","title":"\u5b9e\u73b0\u652f\u6301\u591a\u9053\u7a0b\u5e8f"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E6%94%AF%E6%8C%81%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F/#_1","text":"","title":"\u5b9e\u73b0\u652f\u6301\u591a\u9053\u7a0b\u5e8f\u7684\u64cd\u4f5c\u7cfb\u7edf"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E6%94%AF%E6%8C%81%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F/#_2","text":"\u5206\u65f6\u591a\u4efb\u52a1\u7684\u4e3a\u4f8b ./os/src Rust 18 Files 511 Lines Assembly 3 Files 82 Lines \u251c\u2500\u2500 bootloader \u2502 \u251c\u2500\u2500 rustsbi-k210.bin \u2502 \u2514\u2500\u2500 rustsbi-qemu.bin \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 os \u2502 \u251c\u2500\u2500 build.rs \u2502 \u251c\u2500\u2500 Cargo.toml \u2502 \u251c\u2500\u2500 Makefile \u2502 \u2514\u2500\u2500 src \u2502 \u251c\u2500\u2500 batch.rs(\u79fb\u9664\uff1a\u529f\u80fd\u5206\u522b\u62c6\u5206\u5230 loader \u548c task \u4e24\u4e2a\u5b50\u6a21\u5757) \u2502 \u251c\u2500\u2500 config.rs(\u65b0\u589e\uff1a\u4fdd\u5b58\u5185\u6838\u7684\u4e00\u4e9b\u914d\u7f6e) \u2502 \u251c\u2500\u2500 console.rs \u2502 \u251c\u2500\u2500 entry.asm \u2502 \u251c\u2500\u2500 lang_items.rs \u2502 \u251c\u2500\u2500 link_app.S \u2502 \u251c\u2500\u2500 linker-k210.ld \u2502 \u251c\u2500\u2500 linker-qemu.ld \u2502 \u251c\u2500\u2500 loader.rs(\u65b0\u589e\uff1a\u5c06\u5e94\u7528\u52a0\u8f7d\u5230\u5185\u5b58\u5e76\u8fdb\u884c\u7ba1\u7406) \u2502 \u251c\u2500\u2500 main.rs(\u4fee\u6539\uff1a\u4e3b\u51fd\u6570\u8fdb\u884c\u4e86\u4fee\u6539) \u2502 \u251c\u2500\u2500 sbi.rs(\u4fee\u6539\uff1a\u5f15\u5165\u65b0\u7684 sbi call set_timer) \u2502 \u251c\u2500\u2500 sync \u2502 \u2502 \u251c\u2500\u2500 mod.rs \u2502 \u2502 \u2514\u2500\u2500 up.rs \u2502 \u251c\u2500\u2500 syscall(\u4fee\u6539\uff1a\u65b0\u589e\u82e5\u5e72 syscall) \u2502 \u2502 \u251c\u2500\u2500 fs.rs \u2502 \u2502 \u251c\u2500\u2500 mod.rs \u2502 \u2502 \u2514\u2500\u2500 process.rs \u2502 \u251c\u2500\u2500 task(\u65b0\u589e\uff1atask \u5b50\u6a21\u5757\uff0c\u4e3b\u8981\u8d1f\u8d23\u4efb\u52a1\u7ba1\u7406) \u2502 \u2502 \u251c\u2500\u2500 context.rs(\u5f15\u5165 Task \u4e0a\u4e0b\u6587 TaskContext) \u2502 \u2502 \u251c\u2500\u2500 mod.rs(\u5168\u5c40\u4efb\u52a1\u7ba1\u7406\u5668\u548c\u63d0\u4f9b\u7ed9\u5176\u4ed6\u6a21\u5757\u7684\u63a5\u53e3) \u2502 \u2502 \u251c\u2500\u2500 switch.rs(\u5c06\u4efb\u52a1\u5207\u6362\u7684\u6c47\u7f16\u4ee3\u7801\u89e3\u91ca\u4e3a Rust \u63a5\u53e3 __switch) \u2502 \u2502 \u251c\u2500\u2500 switch.S(\u4efb\u52a1\u5207\u6362\u7684\u6c47\u7f16\u4ee3\u7801) \u2502 \u2502 \u2514\u2500\u2500 task.rs(\u4efb\u52a1\u63a7\u5236\u5757 TaskControlBlock \u548c\u4efb\u52a1\u72b6\u6001 TaskStatus \u7684\u5b9a\u4e49) \u2502 \u251c\u2500\u2500 timer.rs(\u65b0\u589e\uff1a\u8ba1\u65f6\u5668\u76f8\u5173) \u2502 \u2514\u2500\u2500 trap \u2502 \u251c\u2500\u2500 context.rs \u2502 \u251c\u2500\u2500 mod.rs(\u4fee\u6539\uff1a\u65f6\u949f\u4e2d\u65ad\u76f8\u5e94\u5904\u7406) \u2502 \u2514\u2500\u2500 trap.S \u251c\u2500\u2500 README.md \u251c\u2500\u2500 rust-toolchain \u251c\u2500\u2500 tools \u2502 \u251c\u2500\u2500 kflash.py \u2502 \u251c\u2500\u2500 LICENSE \u2502 \u251c\u2500\u2500 package.json \u2502 \u251c\u2500\u2500 README.rst \u2502 \u2514\u2500\u2500 setup.py \u2514\u2500\u2500 user \u251c\u2500\u2500 build.py(\u65b0\u589e\uff1a\u4f7f\u7528 build.py \u6784\u5efa\u5e94\u7528\u4f7f\u5f97\u5b83\u4eec\u5360\u7528\u7684\u7269\u7406\u5730\u5740\u533a\u95f4\u4e0d\u76f8\u4ea4) \u251c\u2500\u2500 Cargo.toml \u251c\u2500\u2500 Makefile(\u4fee\u6539\uff1a\u4f7f\u7528 build.py \u6784\u5efa\u5e94\u7528) \u2514\u2500\u2500 src \u251c\u2500\u2500 bin(\u4fee\u6539\uff1a\u6362\u6210\u7b2c\u4e09\u7ae0\u6d4b\u4f8b) \u2502 \u251c\u2500\u2500 00power_3.rs \u2502 \u251c\u2500\u2500 01power_5.rs \u2502 \u251c\u2500\u2500 02power_7.rs \u2502 \u2514\u2500\u2500 03sleep.rs \u251c\u2500\u2500 console.rs \u251c\u2500\u2500 lang_items.rs \u251c\u2500\u2500 lib.rs \u251c\u2500\u2500 linker.ld \u2514\u2500\u2500 syscall.rs","title":"\u7b2c\u4e09\u7ae0\u4ee3\u7801\u6811"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E6%94%AF%E6%8C%81%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F/#_3","text":"\u672c\u7ae0\u6240\u4ecb\u7ecd\u7684\u591a\u9053\u7a0b\u5e8f\u548c\u5206\u65f6\u591a\u4efb\u52a1\u7cfb\u7edf\u90fd\u6709\u4e00\u4e9b\u5171\u540c\u7684\u7279\u70b9\uff1a\u5728\u5185\u5b58\u4e2d\u540c\u4e00\u65f6\u95f4\u53ef\u4ee5\u9a7b\u7559\u591a\u4e2a\u5e94\u7528\uff0c\u800c\u4e14\u6240\u6709\u7684\u5e94\u7528\u90fd\u662f\u5728\u7cfb\u7edf\u542f\u52a8\u7684\u65f6\u5019\u5206\u522b\u52a0\u8f7d\u5230\u5185\u5b58\u7684\u4e0d\u540c\u533a\u57df\u4e2d\u3002\u7531\u4e8e\u76ee\u524d\u8ba1\u7b97\u673a\u7cfb\u7edf\u4e2d\u53ea\u6709\u4e00\u4e2a\u5904\u7406\u5668\u6838\uff0c\u6240\u4ee5\u540c\u4e00\u65f6\u95f4\u6700\u591a\u53ea\u6709\u4e00\u4e2a\u5e94\u7528\u5728\u6267\u884c\uff08\u5373\u5904\u4e8e\u8fd0\u884c\u72b6\u6001\uff09\uff0c\u5269\u4e0b\u7684\u5e94\u7528\u5904\u4e8e\u5c31\u7eea\u72b6\u6001\u6216\u7b49\u5f85\u72b6\u6001\uff0c\u9700\u8981\u5185\u6838\u5c06\u5904\u7406\u5668\u5206\u914d\u7ed9\u5b83\u4eec\u624d\u80fd\u5f00\u59cb\u6267\u884c\u3002\u4e00\u65e6\u5e94\u7528\u5f00\u59cb\u6267\u884c\uff0c\u5b83\u5c31\u5904\u4e8e\u8fd0\u884c\u72b6\u6001\u4e86 \u672c\u8282\u7684\u4efb\u52a1\u662f\u5b9e\u73b0\u4e00\u4e2a\u53ef\u4ee5\u628a\u591a\u4e2a\u5e94\u7528\u653e\u7f6e\u5728\u5185\u5b58\u4e2d\u7684\u64cd\u4f5c\u7cfb\u7edf \u6211\u4eec\u9700\u8981\u5c06\u6bcf\u4e2a\u5e94\u7528\u6309\u5b83\u7684\u7f16\u53f7\u5206\u522b\u653e\u7f6e\u5e76\u52a0\u8f7d\u5230\u5185\u5b58\u4e2d\u7684\u4e0d\u540c\u4f4d\u7f6e \u8fd9\u91cc\uff0c\u6bcf\u4e2a\u5e94\u7528\u9700\u8981\u77e5\u9053\u81ea\u5df1\u8fd0\u884c\u65f6\u5728\u5185\u5b58\u4e2d\u7684\u4e0d\u540c\u4f4d\u7f6e\uff0c \u64cd\u4f5c\u7cfb\u7edf\u4e5f\u8981\u77e5\u9053\u6bcf\u4e2a\u5e94\u7528\u7a0b\u5e8f\u8fd0\u884c\u65f6\u7684\u4f4d\u7f6e\uff0c\u4e0d\u80fd\u4efb\u610f\u79fb\u52a8\u5e94\u7528\u7a0b\u5e8f\u6240\u5728\u7684\u5185\u5b58\u7a7a\u95f4\uff0c\u5373\u4e0d\u80fd\u5728\u8fd0\u884c\u65f6\u6839\u636e\u5185\u5b58\u7a7a\u95f4\u7684\u52a8\u6001\u7a7a\u95f2\u60c5\u51b5\uff0c\u628a\u5e94\u7528\u7a0b\u5e8f\u8c03\u6574\u5230\u5408\u9002\u7684\u7a7a\u95f2\u7a7a\u95f4\u4e2d","title":"\u672c\u8282\u7684\u4efb\u52a1"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E6%94%AF%E6%8C%81%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F/#_4","text":"","title":"\u672c\u8282\u6587\u4ef6\u89e3\u6790"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E6%94%AF%E6%8C%81%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F/#os","text":"","title":"\u5728 os \u6587\u4ef6\u5939\u4e0b"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E6%94%AF%E6%8C%81%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F/#ossrcloaderrs","text":"use crate::trap::TrapContext; use crate::config::*; use core::arch::asm; #[repr(align(4096))] #[derive(Copy, Clone)] struct KernelStack { data: [u8; KERNEL_STACK_SIZE], } #[repr(align(4096))] #[derive(Copy, Clone)] struct UserStack { data: [u8; USER_STACK_SIZE], } static KERNEL_STACK: [KernelStack; MAX_APP_NUM] = [ KernelStack { data: [0; KERNEL_STACK_SIZE], }; MAX_APP_NUM ]; static USER_STACK: [UserStack; MAX_APP_NUM] = [ UserStack { data: [0; USER_STACK_SIZE], }; MAX_APP_NUM ]; impl KernelStack { fn get_sp(&self) -> usize { self.data.as_ptr() as usize + KERNEL_STACK_SIZE } pub fn push_context(&self, trap_cx: TrapContext) -> usize { let trap_cx_ptr = (self.get_sp() - core::mem::size_of::<TrapContext>()) as *mut TrapContext; unsafe { *trap_cx_ptr = trap_cx; } trap_cx_ptr as usize } } impl UserStack { fn get_sp(&self) -> usize { self.data.as_ptr() as usize + USER_STACK_SIZE } } fn get_base_i(app_id: usize) -> usize { APP_BASE_ADDRESS + app_id * APP_SIZE_LIMIT } // \u83b7\u53d6\u7b2c i \u4e2a\u5e94\u7528\u7684\u8d77\u59cb\u5730\u5740 pub fn get_num_app() -> usize { extern \"C\" { fn _num_app(); } unsafe { (_num_app as usize as *const usize).read_volatile() } } // \u83b7\u53d6 _num_app, \u5373\u5e94\u7528\u7684\u4e2a\u6570 pub fn load_apps() { extern \"C\" { fn _num_app(); } let num_app_ptr = _num_app as usize as *const usize; let num_app = get_num_app(); let app_start = unsafe { core::slice::from_raw_parts(num_app_ptr.add(1), num_app + 1) }; // clear i-cache first unsafe { asm!(\"fence.i\"); } // load apps for i in 0..num_app { let base_i = get_base_i(i); // \u83b7\u53d6\u7b2c i \u4e2a\u5e94\u7528\u7684\u8d77\u59cb\u5730\u5740 (base_i..base_i + APP_SIZE_LIMIT).for_each(|addr| unsafe { (addr as *mut u8).write_volatile(0) }); // \u5c06\u7528\u4e8e\u5b58\u653e\u7b2c i \u4e2a\u5e94\u7528\u7684\u5730\u5740\u533a\u95f4 \u7528 0 \u586b\u5145 let src = unsafe { core::slice::from_raw_parts(app_start[i] as *const u8, app_start[i + 1] - app_start[i]) }; // \u83b7\u53d6\u7b2c i \u4e2a\u5e94\u7528\u5728 .data \u6bb5\u4e2d\u7684\u8d77\u59cb\u5730\u5740 \u548c \u957f\u5ea6 let dst = unsafe { core::slice::from_raw_parts_mut(base_i as *mut u8, src.len()) }; // \u5c06\u521a\u624d\u7528 0 \u586b\u5145\u7684\u8d77\u59cb\u5730\u5740 \u548c \u5e94\u7528\u7684\u957f\u5ea6\u5c01\u88c5\u8d77\u6765 dst.copy_from_slice(src); // \u5c06\u7b2c i \u4e2a\u5e94\u7528 \u4ece .data \u6bb5\u52a0\u8f7d\u5230 \u4e0a\u9762\u5bf9\u5e94\u7684\u5730\u5740\u7a7a\u95f4 } } pub fn init_app_cx(app_id: usize) -> usize { KERNEL_STACK[app_id].push_context( TrapContext::app_init_context(get_base_i(app_id), USER_STACK[app_id].get_sp()), ) }","title":"os/src/loader.rs"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E6%94%AF%E6%8C%81%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F/#user","text":"","title":"\u5728 user \u6587\u4ef6\u5939\u4e0b"},{"location":"ch3%E5%AE%9E%E7%8E%B0%E6%94%AF%E6%8C%81%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F/#userbuildpy","text":"import os base_address = 0x80400000 step = 0x20000 linker = 'src/linker.ld' app_id = 0 apps = os.listdir('src/bin') # \u5f97\u5230\u4e00\u4e2a\u5217\u8868\uff0c \u91cc\u9762\u662f \u6587\u4ef6\u540d apps.sort() for app in apps: app = app[:app.find('.')] # app \u53d8\u6210\u4e0d\u5e26\u540e\u7f00\u7684\u6587\u4ef6\u540d lines = [] lines_before = [] with open(linker, 'r') as f: for line in f.readlines(): lines_before.append(line) line = line.replace(hex(base_address), hex(base_address+step*app_id)) lines.append(line) with open(linker, 'w+') as f: f.writelines(lines) # \u627e\u5230 src/linker.ld \u4e2d\u7684 BASE_ADDRESS = 0x80400000; # \u8fd9\u4e00\u884c\uff0c\u5e76\u5c06\u540e\u9762\u7684\u5730\u5740\u66ff\u6362\u4e3a\u548c\u5f53\u524d\u5e94\u7528\u5bf9\u5e94\u7684\u4e00\u4e2a\u5730\u5740 os.system('cargo build --bin %s --release' % app) # \u4f7f\u7528 --bin \u53c2\u6570\u6765\u53ea\u6784\u5efa\u67d0\u4e00\u4e2a\u5e94\u7528 # \u90a3\u5c31\u662f\u5bf9\u6bcf\u4e2a\u5e94\u7528\u5206\u522b\u8fdb\u884c\u7f16\u8bd1 \u6539\u53d8\u5176 \u8d77\u59cb\u5730\u5740 print('[build.py] application %s start with address %s' %(app, hex(base_address+step*app_id))) with open(linker, 'w+') as f: f.writelines(lines_before) # \u5c06 linker.ld \u590d\u539f\uff0c \u73b0\u5728\u7684 base_address = 0x80400000+step*app_id # \u6062\u590d\u4e3a 0x80400000 app_id = app_id + 1","title":"user/build.py"},{"location":"ch4%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/","text":"os\u5b9e\u73b0\u5206\u65f6\u591a\u4efb\u52a1\u7cfb\u7edf\u4e0e\u62a2\u5360\u5f0f\u8c03\u7528 \u7b2c\u4e09\u7ae0\u4ee3\u7801\u6811 \u5206\u65f6\u591a\u4efb\u52a1\u7684\u4e3a\u4f8b 1 ./os/src 2 Rust 25 Files 1415 Lines 3 Assembly 3 Files 88 Lines 4 5 \u251c\u2500\u2500 bootloader 6 \u2502 \u251c\u2500\u2500 rustsbi-k210.bin 7 \u2502 \u2514\u2500\u2500 rustsbi-qemu.bin 8 \u251c\u2500\u2500 LICENSE 9 \u251c\u2500\u2500 os 10 \u2502 \u251c\u2500\u2500 build.rs 11 \u2502 \u251c\u2500\u2500 Cargo.lock 12 \u2502 \u251c\u2500\u2500 Cargo.toml 13 \u2502 \u251c\u2500\u2500 Makefile 14 \u2502 \u2514\u2500\u2500 src 15 \u2502 \u251c\u2500\u2500 config.rs(\u4fee\u6539\uff1a\u65b0\u589e\u4e00\u4e9b\u5185\u5b58\u7ba1\u7406\u7684\u76f8\u5173\u914d\u7f6e) 16 \u2502 \u251c\u2500\u2500 console.rs 17 \u2502 \u251c\u2500\u2500 entry.asm 18 \u2502 \u251c\u2500\u2500 lang_items.rs 19 \u2502 \u251c\u2500\u2500 link_app.S 20 \u2502 \u251c\u2500\u2500 linker-k210.ld(\u4fee\u6539\uff1a\u5c06\u8df3\u677f\u9875\u5f15\u5165\u5185\u5b58\u5e03\u5c40) 21 \u2502 \u251c\u2500\u2500 linker-qemu.ld(\u4fee\u6539\uff1a\u5c06\u8df3\u677f\u9875\u5f15\u5165\u5185\u5b58\u5e03\u5c40) 22 \u2502 \u251c\u2500\u2500 loader.rs(\u4fee\u6539\uff1a\u4ec5\u4fdd\u7559\u83b7\u53d6\u5e94\u7528\u6570\u91cf\u548c\u6570\u636e\u7684\u529f\u80fd) 23 \u2502 \u251c\u2500\u2500 main.rs(\u4fee\u6539) 24 \u2502 \u251c\u2500\u2500 mm(\u65b0\u589e\uff1a\u5185\u5b58\u7ba1\u7406\u7684 mm \u5b50\u6a21\u5757) 25 \u2502 \u2502 \u251c\u2500\u2500 address.rs(\u7269\u7406/\u865a\u62df \u5730\u5740/\u9875\u53f7\u7684 Rust \u62bd\u8c61) 26 \u2502 \u2502 \u251c\u2500\u2500 frame_allocator.rs(\u7269\u7406\u9875\u5e27\u5206\u914d\u5668) 27 \u2502 \u2502 \u251c\u2500\u2500 heap_allocator.rs(\u5185\u6838\u52a8\u6001\u5185\u5b58\u5206\u914d\u5668) 28 \u2502 \u2502 \u251c\u2500\u2500 memory_set.rs(\u5f15\u5165\u5730\u5740\u7a7a\u95f4 MemorySet \u53ca\u903b\u8f91\u6bb5 MemoryArea \u7b49) 29 \u2502 \u2502 \u251c\u2500\u2500 mod.rs(\u5b9a\u4e49\u4e86 mm \u6a21\u5757\u521d\u59cb\u5316\u65b9\u6cd5 init) 30 \u2502 \u2502 \u2514\u2500\u2500 page_table.rs(\u591a\u7ea7\u9875\u8868\u62bd\u8c61 PageTable \u4ee5\u53ca\u5176\u4ed6\u5185\u5bb9) 31 \u2502 \u251c\u2500\u2500 sbi.rs 32 \u2502 \u251c\u2500\u2500 sync 33 \u2502 \u2502 \u251c\u2500\u2500 mod.rs 34 \u2502 \u2502 \u2514\u2500\u2500 up.rs 35 \u2502 \u251c\u2500\u2500 syscall 36 \u2502 \u2502 \u251c\u2500\u2500 fs.rs(\u4fee\u6539\uff1a\u57fa\u4e8e\u5730\u5740\u7a7a\u95f4\u7684 sys_write \u5b9e\u73b0) 37 \u2502 \u2502 \u251c\u2500\u2500 mod.rs 38 \u2502 \u2502 \u2514\u2500\u2500 process.rs 39 \u2502 \u251c\u2500\u2500 task 40 \u2502 \u2502 \u251c\u2500\u2500 context.rs(\u4fee\u6539\uff1a\u6784\u9020\u4e00\u4e2a\u8df3\u8f6c\u5230\u4e0d\u540c\u4f4d\u7f6e\u7684\u521d\u59cb\u4efb\u52a1\u4e0a\u4e0b\u6587) 41 \u2502 \u2502 \u251c\u2500\u2500 mod.rs(\u4fee\u6539\uff0c\u8be6\u89c1\u6587\u6863) 42 \u2502 \u2502 \u251c\u2500\u2500 switch.rs 43 \u2502 \u2502 \u251c\u2500\u2500 switch.S 44 \u2502 \u2502 \u2514\u2500\u2500 task.rs(\u4fee\u6539\uff0c\u8be6\u89c1\u6587\u6863) 45 \u2502 \u251c\u2500\u2500 timer.rs 46 \u2502 \u2514\u2500\u2500 trap 47 \u2502 \u251c\u2500\u2500 context.rs(\u4fee\u6539\uff1a\u5728 Trap \u4e0a\u4e0b\u6587\u4e2d\u52a0\u5165\u4e86\u66f4\u591a\u5185\u5bb9) 48 \u2502 \u251c\u2500\u2500 mod.rs(\u4fee\u6539\uff1a\u57fa\u4e8e\u5730\u5740\u7a7a\u95f4\u4fee\u6539\u4e86 Trap \u673a\u5236\uff0c\u8be6\u89c1\u6587\u6863) 49 \u2502 \u2514\u2500\u2500 trap.S(\u4fee\u6539\uff1a\u57fa\u4e8e\u5730\u5740\u7a7a\u95f4\u4fee\u6539\u4e86 Trap \u4e0a\u4e0b\u6587\u4fdd\u5b58\u4e0e\u6062\u590d\u6c47\u7f16\u4ee3\u7801) 50 \u251c\u2500\u2500 README.md 51 \u251c\u2500\u2500 rust-toolchain 52 \u251c\u2500\u2500 tools 53 \u2502 \u251c\u2500\u2500 kflash.py 54 \u2502 \u251c\u2500\u2500 LICENSE 55 \u2502 \u251c\u2500\u2500 package.json 56 \u2502 \u251c\u2500\u2500 README.rst 57 \u2502 \u2514\u2500\u2500 setup.py 58 \u2514\u2500\u2500 user 59 \u251c\u2500\u2500 build.py(\u79fb\u9664) 60 \u251c\u2500\u2500 Cargo.toml 61 \u251c\u2500\u2500 Makefile 62 \u2514\u2500\u2500 src 63 \u251c\u2500\u2500 bin 64 \u2502 \u251c\u2500\u2500 00power_3.rs 65 \u2502 \u251c\u2500\u2500 01power_5.rs 66 \u2502 \u251c\u2500\u2500 02power_7.rs 67 \u2502 \u2514\u2500\u2500 03sleep.rs 68 \u251c\u2500\u2500 console.rs 69 \u251c\u2500\u2500 lang_items.rs 70 \u251c\u2500\u2500 lib.rs 71 \u251c\u2500\u2500 linker.ld(\u4fee\u6539\uff1a\u5c06\u6240\u6709\u5e94\u7528\u653e\u5728\u5404\u81ea\u5730\u5740\u7a7a\u95f4\u4e2d\u56fa\u5b9a\u7684\u4f4d\u7f6e) 72 \u2514\u2500\u2500 syscall.rs \u672c\u8282\u7684\u4efb\u52a1 \u672c\u8282\u5b9e\u73b0\u4e00\u4e2a\u652f\u6301 \u5bf9\u4e2d\u65ad\u7684\u5904\u7406\u548c\u5bf9\u5e94\u7528\u7a0b\u5e8f\u7684\u62a2\u5360\uff0c\u8bbe\u8ba1\u5b9e\u73b0\u66f4\u52a0\u516c\u5e73\u548c\u9ad8\u6548\u4ea4\u4e92\u7684\u62a2\u5360\u5f0f\u64cd\u4f5c\u7cfb\u7edf \u5f53\u5916\u8bbe\u60f3\u8981\u89e6\u53d1\u4e2d\u65ad\u7684\u65f6\u5019\u5219\u8f93\u5165\u4e00\u4e2a\u9ad8\u7535\u5e73\u6216\u6b63\u8fb9\u6cbf\uff0c\u5904\u7406\u5668\u4f1a\u5728\u6bcf\u6267\u884c\u5b8c\u4e00\u6761\u6307\u4ee4\u4e4b\u540e\u68c0\u67e5\u4e00\u4e0b\u8fd9\u6839\u7ebf\uff0c\u770b\u60c5\u51b5\u51b3\u5b9a\u662f\u7ee7\u7eed\u6267\u884c\u63a5\u4e0b\u6765\u7684\u6307\u4ee4\u8fd8\u662f\u8fdb\u5165\u4e2d\u65ad\u5904\u7406\u6d41\u7a0b \u672c\u7ae0\u7684\u64cd\u4f5c\u7cfb\u7edf\u652f\u6301\u628a\u591a\u4e2a\u5e94\u7528\u7684\u4ee3\u7801\u548c\u6570\u636e\u653e\u7f6e\u5230\u5185\u5b58\u4e2d\uff1b\u5e76\u80fd\u591f\u6267\u884c\u6bcf\u4e2a\u5e94\u7528\uff1b\u5728\u5e94\u7528\u7a0b\u5e8f\u53d1\u51fa sys_yeild \u7cfb\u7edf\u8c03\u7528\u65f6\uff0c\u534f\u4f5c\u5f0f\u5730\u5207\u6362\u5e94\u7528\uff1b\u5e76\u80fd\u901a\u8fc7\u65f6\u949f\u4e2d\u65ad\u6765\u5b9e\u73b0\u62a2\u5360\u5f0f\u8c03\u5ea6\u5e76\u5f3a\u884c\u5207\u6362\u5e94\u7528\uff0c\u4ece\u800c\u63d0\u9ad8\u4e86\u5e94\u7528\u6267\u884c\u7684\u7075\u6d3b\u6027\u3001\u516c\u5e73\u6027\u548c\u4ea4\u4e92\u6548\u7387\u3002 \u672c\u8282\u6587\u4ef6\u89e3\u6790 \u5728bootloader \u6587\u4ef6\u5939\u4e0b rustsbi-qemu.bin \u5728 os \u6587\u4ef6\u5939\u4e0b os/.cargo/config [build] target = \"riscv64gc-unknown-none-elf\" [target.riscv64gc-unknown-none-elf] rustflags = [ \"-Clink-arg=-Tsrc/linker.ld\", \"-Cforce-frame-pointers=yes\" ] os/build.rs use std::io::{Result, Write}; use std::fs::{File, read_dir}; fn main() { println!(\"cargo:rerun-if-changed=../user/src/\"); println!(\"cargo:rerun-if-changed={}\", TARGET_PATH); insert_app_data().unwrap(); } static TARGET_PATH: &str = \"../user/target/riscv64gc-unknown-none-elf/release/\"; fn insert_app_data() -> Result<()> { let mut f = File::create(\"src/link_app.S\").unwrap(); let mut apps: Vec<_> = read_dir(\"../user/src/bin\") .unwrap() .into_iter() .map(|dir_entry| { let mut name_with_ext = dir_entry.unwrap().file_name().into_string().unwrap(); name_with_ext.drain(name_with_ext.find('.').unwrap()..name_with_ext.len()); name_with_ext }) .collect(); apps.sort(); writeln!(f, r#\" .align 3 .section .data .global _num_app _num_app: .quad {}\"#, apps.len())?; for i in 0..apps.len() { writeln!(f, r#\" .quad app_{}_start\"#, i)?; } writeln!(f, r#\" .quad app_{}_end\"#, apps.len() - 1)?; for (idx, app) in apps.iter().enumerate() { println!(\"app_{}: {}\", idx, app); writeln!(f, r#\" .section .data .global app_{0}_start .global app_{0}_end app_{0}_start: .incbin \"{2}{1}.bin\" app_{0}_end:\"#, idx, app, TARGET_PATH)?; } Ok(()) } os/Cargo.toml [package] name = \"os\" version = \"0.1.0\" authors = [\"Yifan Wu <shinbokuow@163.com>\"] edition = \"2018\" # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html [dependencies] riscv = { git = \"https://github.com/rcore-os/riscv\", features = [\"inline-asm\"] } lazy_static = { version = \"1.4.0\", features = [\"spin_no_std\"] } buddy_system_allocator = \"0.6\" # \u9700\u5c06\u6211\u4eec\u7684\u52a8\u6001\u5185\u5b58\u5206\u914d\u5668\u7c7b\u578b\u5b9e\u4f8b\u5316\u4e3a\u4e00\u4e2a\u5168\u5c40\u53d8\u91cf\uff0c\u5e76\u4f7f\u7528 #[global_allocator] \u8bed\u4e49\u9879\u6807\u8bb0\u5373\u53ef\u3002 # \u7531\u4e8e\u8be5\u5206\u914d\u5668\u7684\u5b9e\u73b0\u6bd4\u8f83\u590d\u6742\uff0c\u6211\u4eec\u8fd9\u91cc\u76f4\u63a5\u4f7f\u7528\u4e00\u4e2a\u5df2\u6709\u7684\u4f19\u4f34\u5206\u914d\u5668\u5b9e\u73b0 bitflags = \"1.2.1\" xmas-elf = \"0.7.0\" [features] board_qemu = [] board_k210 = [] os/src/config.rs pub const USER_STACK_SIZE: usize = 4096 * 2; pub const KERNEL_STACK_SIZE: usize = 4096 * 2; pub const KERNEL_HEAP_SIZE: usize = 0x30_0000; pub const MEMORY_END: usize = 0x80800000; // \u6211\u4eec\u786c\u7f16\u7801\u6574\u5757\u7269\u7406\u5185\u5b58\u7684\u7ec8\u6b62\u7269\u7406\u5730\u5740\u4e3a 0x80800000 \u3002 // \u800c \u4e4b\u524d \u63d0\u5230\u8fc7\u7269\u7406\u5185\u5b58\u7684\u8d77\u59cb\u7269\u7406\u5730\u5740\u4e3a 0x80000000 \uff0c\u8fd9\u610f\u5473\u7740\u6211\u4eec\u5c06\u53ef\u7528\u5185\u5b58\u5927\u5c0f\u8bbe\u7f6e\u4e3a 8 MB pub const PAGE_SIZE: usize = 0x1000; pub const PAGE_SIZE_BITS: usize = 0xc; pub const TRAMPOLINE: usize = usize::MAX - PAGE_SIZE + 1; pub const TRAP_CONTEXT: usize = TRAMPOLINE - PAGE_SIZE; /// Return (bottom, top) of a kernel stack in kernel space. pub fn kernel_stack_position(app_id: usize) -> (usize, usize) { let top = TRAMPOLINE - app_id * (KERNEL_STACK_SIZE + PAGE_SIZE); let bottom = top - KERNEL_STACK_SIZE; (bottom, top) } #[cfg(feature = \"board_k210\")] pub const CLOCK_FREQ: usize = 403000000 / 62; #[cfg(feature = \"board_qemu\")] pub const CLOCK_FREQ: usize = 12500000; os/src/console.rs use core::fmt::{self, Write}; use crate::sbi::console_putchar; struct Stdout; impl Write for Stdout { fn write_str(&mut self, s: &str) -> fmt::Result { for c in s.chars() { console_putchar(c as usize); } Ok(()) } } pub fn print(args: fmt::Arguments) { Stdout.write_fmt(args).unwrap(); } #[macro_export] macro_rules! print { ($fmt: literal $(, $($arg: tt)+)?) => { $crate::console::print(format_args!($fmt $(, $($arg)+)?)); } } #[macro_export] macro_rules! println { ($fmt: literal $(, $($arg: tt)+)?) => { $crate::console::print(format_args!(concat!($fmt, \"\\n\") $(, $($arg)+)?)); } } os/src/entry.asm .section .text.entry .globl _start _start: la sp, boot_stack_top call rust_main .section .bss.stack .globl boot_stack boot_stack: .space 4096 * 16 .globl boot_stack_top boot_stack_top: os/src/lang_items.rs use core::panic::PanicInfo; use crate::sbi::shutdown; #[panic_handler] fn panic(info: &PanicInfo) -> ! { if let Some(location) = info.location() { println!(\"[kernel] Panicked at {}:{} {}\", location.file(), location.line(), info.message().unwrap()); } else { println!(\"[kernel] Panicked: {}\", info.message().unwrap()); } shutdown() } os/src/link_app.S .align 3 .section .data .global _num_app _num_app: .quad 3 .quad app_0_start .quad app_1_start .quad app_2_start .quad app_2_end .section .data .global app_0_start .global app_0_end app_0_start: .incbin \"../user/target/riscv64gc-unknown-none-elf/release/00write_a.bin\" app_0_end: .section .data .global app_1_start .global app_1_end app_1_start: .incbin \"../user/target/riscv64gc-unknown-none-elf/release/01write_b.bin\" app_1_end: .section .data .global app_2_start .global app_2_end app_2_start: .incbin \"../user/target/riscv64gc-unknown-none-elf/release/02write_c.bin\" app_2_end: os/src/linker-qemu.ld OUTPUT_ARCH(riscv) ENTRY(_start) BASE_ADDRESS = 0x80200000; SECTIONS { . = BASE_ADDRESS; skernel = .; stext = .; .text : { *(.text.entry) . = ALIGN(4K); strampoline = .; *(.text.trampoline); . = ALIGN(4K); *(.text .text.*) } . = ALIGN(4K); etext = .; srodata = .; .rodata : { *(.rodata .rodata.*) *(.srodata .srodata.*) } . = ALIGN(4K); erodata = .; sdata = .; .data : { *(.data .data.*) *(.sdata .sdata.*) } . = ALIGN(4K); edata = .; sbss_with_stack = .; .bss : { *(.bss.stack) sbss = .; *(.bss .bss.*) *(.sbss .sbss.*) } . = ALIGN(4K); ebss = .; ekernel = .; /DISCARD/ : { *(.eh_frame) } } os/src/sbi.rs #![allow(unused)] const SBI_SET_TIMER:usize = 0; const SBI_CONSOLE_PUTCHAR:usize = 1; const SBI_CONSOLE_GETCHAR:usize = 2; const SBI_CLEAR_IPI:usize = 3; const SBI_SEND_IPI:usize = 4; const SBI_REMOTE_FENCE_I:usize = 5; const SBI_REMOTE_SFENCE_VMA:usize = 6; const SBI_REMOTE_SFENCE_VMA_ASID:usize = 7; const SBI_SHUTDOWN:usize = 8; use core::arch::asm; #[inline(always)] fn sbi_call(which:usize, arg0:usize, arg1:usize, arg2: usize) -> usize{ let mut ret; unsafe{ asm!( \"ecall\", inlateout(\"x10\") arg0 => ret, in(\"x11\") arg1, in(\"x12\") arg2, in(\"x17\") which, ); } ret } pub fn console_putchar(c:usize){ sbi_call(SBI_CONSOLE_PUTCHAR, c, 0, 0); } pub fn console_getchar() -> usize { sbi_call(SBI_CONSOLE_GETCHAR, 0, 0, 0) } pub fn shutdown() -> ! { sbi_call(SBI_SHUTDOWN, 0, 0, 0); panic!(\"It should shutdown!\"); } pub fn set_timer(timer: usize) { sbi_call(SBI_SET_TIMER, timer, 0, 0); } // sbi \u5b50\u6a21\u5757\u6709\u4e00\u4e2a set_timer \u8c03\u7528\uff0c\u662f\u4e00\u4e2a\u7531 SEE \u63d0\u4f9b\u7684\u6807\u51c6 SBI \u63a5\u53e3\u51fd\u6570\uff0c\u5b83\u53ef\u4ee5\u7528\u6765\u8bbe\u7f6e mtimecmp \u7684\u503c\u3002 os/src/timer.rs use riscv::register::time; use crate::sbi::set_timer; pub fn get_time() -> usize{ time::read() } // timer \u5b50\u6a21\u5757\u7684 get_time \u51fd\u6570\u53ef\u4ee5\u53d6\u5f97\u5f53\u524d mtime \u8ba1\u6570\u5668\u7684\u503c\uff1b use crate::config::CLOCK_FREQ; const TICKS_PER_SEC: usize = 100; pub fn set_next_trigger() { set_timer(get_time() + CLOCK_FREQ / TICKS_PER_SEC); } // timer \u5b50\u6a21\u5757\u7684 set_next_trigger \u51fd\u6570\u5bf9 set_timer \u8fdb\u884c\u4e86\u5c01\u88c5\uff0c // \u5b83\u9996\u5148\u8bfb\u53d6\u5f53\u524d mtime \u7684\u503c\uff0c\u7136\u540e\u8ba1\u7b97\u51fa 10ms \u4e4b\u5185\u8ba1\u6570\u5668\u7684\u589e\u91cf\uff0c // \u518d\u5c06 mtimecmp \u8bbe\u7f6e\u4e3a\u4e8c\u8005\u7684\u548c\u3002\u8fd9\u6837\uff0c10ms \u4e4b\u540e\u4e00\u4e2a S \u7279\u6743\u7ea7\u65f6\u949f\u4e2d\u65ad\u5c31\u4f1a\u88ab\u89e6\u53d1\u3002 // \u81f3\u4e8e\u589e\u91cf\u7684\u8ba1\u7b97\u65b9\u5f0f\uff0c\u5e38\u6570 CLOCK_FREQ \u662f\u4e00\u4e2a\u9884\u5148\u83b7\u53d6\u5230\u7684\u5404\u5e73\u53f0\u4e0d\u540c\u7684\u65f6\u949f\u9891\u7387\uff0c // \u5355\u4f4d\u4e3a\u8d6b\u5179\uff0c\u4e5f\u5c31\u662f\u4e00\u79d2\u949f\u4e4b\u5185\u8ba1\u6570\u5668\u7684\u589e\u91cf\u3002\u5b83\u53ef\u4ee5\u5728 config \u5b50\u6a21\u5757\u4e2d\u627e\u5230\u3002 // CLOCK_FREQ \u9664\u4ee5\u5e38\u6570 TICKS_PER_SEC \u5373\u662f\u4e0b\u4e00\u6b21\u65f6\u949f\u4e2d\u65ad\u7684\u8ba1\u6570\u5668\u589e\u91cf\u503c\u3002 const MICRO_PRE_SEC: usize = 1_000_000; pub fn get_time_ms() -> usize { time::read() / (CLOCK_FREQ / MICRO_PRE_SEC) } // timer \u5b50\u6a21\u5757\u7684 get_time_us \u4ee5\u5fae\u79d2\u4e3a\u5355\u4f4d\u8fd4\u56de\u5f53\u524d\u8ba1\u6570\u5668\u7684\u503c\uff0c\u8fd9\u8ba9\u6211\u4eec\u7ec8\u4e8e\u80fd\u5bf9\u65f6\u95f4\u6709\u4e00\u4e2a\u5177\u4f53\u6982\u5ff5\u4e86 os/src/mm/address.rs Virtual Address (39bits) 38 12 11 0 Virtual Page Number Page Offset(\u9875\u5185\u504f\u79fb) VPN\uff1a27 Physical Address (56bits) 55 12 11 0 Physical Page Number Page Offsett(\u9875\u5185\u504f\u79fb ) PPN\uff1a44 // \u9875\u8868\u4e2d\u7684\u9875\u8868\u9879\u7684\u7d22\u5f15\u5176\u5b9e\u662f\u865a\u62df\u5730\u5740\u4e2d\u7684\u865a\u62df\u9875\u53f7\uff0c\u9875\u8868\u9879\u7684\u91cd\u8981\u5185\u5bb9\u662f\u7269\u7406\u5730\u5740\u7684\u7269\u7406\u9875\u5e27\u53f7\u3002 // \u4e3a\u4e86\u80fd\u591f\u7075\u6d3b\u5730\u5728\u865a\u62df\u5730\u5740\u3001\u7269\u7406\u5730\u5740\u3001\u865a\u62df\u9875\u53f7\u3001\u7269\u7406\u9875\u53f7\u4e4b\u95f4\u8fdb\u884c\u5404\u79cd\u8f6c\u6362 // \u8fd9\u91cc\u5b9e\u73b0\u4e86\u5404\u79cd\u8f6c\u6362\u51fd\u6570 use crate::config::{PAGE_SIZE, PAGE_SIZE_BITS}; use super::PageTableEntry; use core::fmt::{self, Debug, Formatter}; const PA_WIDTH_SV39: usize = 56; const VA_WIDTH_SV39: usize = 39; const PPN_WIDTH_SV39: usize = PA_WIDTH_SV39 - PAGE_SIZE_BITS; const VPN_WIDTH_SV39: usize = VA_WIDTH_SV39 - PAGE_SIZE_BITS; // \u5728\u5206\u9875\u5185\u5b58\u7ba1\u7406\u4e2d\uff0c\u5730\u5740\u8f6c\u6362\u7684\u6838\u5fc3\u4efb\u52a1\u5728\u4e8e\u5982\u4f55\u7ef4\u62a4\u865a\u62df\u9875\u53f7\u5230\u7269\u7406\u9875\u53f7\u7684\u6620\u5c04\u2014\u2014\u4e5f\u5c31\u662f\u9875\u8868\u3002 // \u4e0d\u8fc7\u5728\u5177\u4f53\u5b9e\u73b0\u5b83\u4e4b\u524d\uff0c\u6211\u4eec\u5148\u5c06\u5730\u5740\u548c\u9875\u53f7\u7684\u6982\u5ff5\u62bd\u8c61\u4e3a Rust \u4e2d\u7684\u7c7b\u578b\uff0c // \u501f\u52a9 Rust \u7684\u7c7b\u578b\u5b89\u5168\u7279\u6027\u6765\u786e\u4fdd\u5b83\u4eec\u88ab\u6b63\u786e\u5b9e\u73b0 /// Definitions #[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq)] pub struct PhysAddr(pub usize); #[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq)] pub struct VirtAddr(pub usize); #[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq)] pub struct PhysPageNum(pub usize); #[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq)] pub struct VirtPageNum(pub usize); // \u4e0a\u9762\u5206\u522b\u7ed9\u51fa\u4e86\u7269\u7406\u5730\u5740\u3001\u865a\u62df\u5730\u5740\u3001\u7269\u7406\u9875\u53f7\u3001\u865a\u62df\u9875\u53f7\u7684 Rust \u7c7b\u578b\u58f0\u660e\uff0c // \u5b83\u4eec\u90fd\u662f Rust \u7684\u5143\u7ec4\u5f0f\u7ed3\u6784\u4f53\uff0c\u53ef\u4ee5\u770b\u6210 usize \u7684\u4e00\u79cd\u7b80\u5355\u5305\u88c5\u3002 // \u6211\u4eec\u523b\u610f\u5c06\u5b83\u4eec\u5404\u81ea\u62bd\u8c61\u51fa\u4e0d\u540c\u7684\u7c7b\u578b\u800c\u4e0d\u662f\u90fd\u4f7f\u7528\u4e0eRISC-V 64\u786c\u4ef6\u76f4\u63a5\u5bf9\u5e94\u7684 usize \u57fa\u672c\u7c7b\u578b\uff0c // \u5c31\u662f\u4e3a\u4e86\u5728 Rust \u7f16\u8bd1\u5668\u7684\u5e2e\u52a9\u4e0b\uff0c\u901a\u8fc7\u591a\u79cd\u65b9\u4fbf\u4e14\u5b89\u5168\u7684 \u7c7b\u578b\u8f6c\u6362 (Type Convertion) \u6765\u6784\u5efa\u9875\u8868 /// Debugging impl Debug for VirtAddr { fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result { f.write_fmt(format_args!(\"VA:{:#x}\", self.0)) } } impl Debug for VirtPageNum { fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result { f.write_fmt(format_args!(\"VPN:{:#x}\", self.0)) } } impl Debug for PhysAddr { fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result { f.write_fmt(format_args!(\"PA:{:#x}\", self.0)) } } impl Debug for PhysPageNum { fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result { f.write_fmt(format_args!(\"PPN:{:#x}\", self.0)) } } /// T: {PhysAddr, VirtAddr, PhysPageNum, VirtPageNum} /// T -> usize: T.0 /// usize -> T: usize.into() // \u4e00\u822c\u800c\u8a00\uff0c\u5f53\u6211\u4eec\u4e3a\u7c7b\u578b U \u5b9e\u73b0\u4e86 From<T> Trait \u4e4b\u540e\uff0c // \u53ef\u4ee5\u4f7f\u7528 U::from(_: T) \u6765\u4ece\u4e00\u4e2a T \u7c7b\u578b\u7684\u5b9e\u4f8b\u6765\u6784\u9020\u4e00\u4e2a U \u7c7b\u578b\u7684\u5b9e\u4f8b\uff1b // \u800c\u5f53\u6211\u4eec\u4e3a\u7c7b\u578b U \u5b9e\u73b0\u4e86 Into<T> Trait \u4e4b\u540e\uff0c\u5bf9\u4e8e\u4e00\u4e2a U \u7c7b\u578b\u7684\u5b9e\u4f8b u \uff0c // \u53ef\u4ee5\u4f7f\u7528 u.into() \u6765\u5c06\u5176\u8f6c\u5316\u4e3a\u4e00\u4e2a\u7c7b\u578b\u4e3a T \u7684\u5b9e\u4f8b\u3002 // \u5f53\u6211\u4eec\u4e3a U \u5b9e\u73b0\u4e86 From<T> \u4e4b\u540e\uff0cRust \u4f1a\u81ea\u52a8\u4e3a T \u5b9e\u73b0 Into<U> Trait\uff0c // \u56e0\u4e3a\u5b83\u4eec\u4e24\u4e2a\u672c\u6765\u5c31\u662f\u5728\u505a\u76f8\u540c\u7684\u4e8b\u60c5\u3002\u56e0\u6b64\u6211\u4eec\u53ea\u9700\u76f8\u4e92\u5b9e\u73b0 From \u5c31\u53ef\u4ee5\u76f8\u4e92 From/Into \u4e86 // \u8fd9\u4e9b\u7c7b\u578b\u672c\u8eab\u53ef\u4ee5\u548c usize \u4e4b\u95f4\u4e92\u76f8\u8f6c\u6362 impl From<usize> for PhysAddr { fn from(v: usize) -> Self { Self(v & ( (1 << PA_WIDTH_SV39) - 1 )) } // \u548c 56 \u4e2a 1 \u76f8\u4e0e } impl From<usize> for PhysPageNum { fn from(v: usize) -> Self { Self(v & ( (1 << PPN_WIDTH_SV39) - 1 )) } } impl From<usize> for VirtAddr { fn from(v: usize) -> Self { Self(v & ( (1 << VA_WIDTH_SV39) - 1 )) } // \u548c 39 \u4e2a 1 \u76f8\u4e0e } impl From<usize> for VirtPageNum { fn from(v: usize) -> Self { Self(v & ( (1 << VPN_WIDTH_SV39) - 1 )) } } impl From<PhysAddr> for usize { fn from(v: PhysAddr) -> Self { v.0 } } impl From<PhysPageNum> for usize { fn from(v: PhysPageNum) -> Self { v.0 } } impl From<VirtAddr> for usize { fn from(v: VirtAddr) -> Self { v.0 } } impl From<VirtPageNum> for usize { fn from(v: VirtPageNum) -> Self { v.0 } } impl VirtAddr { // \u4ece\u7269\u7406\u9875\u53f7\u5230\u7269\u7406\u5730\u5740\u7684\u8f6c\u6362\u53ea\u9700\u5de6\u79fb \u4f4d\u5373\u53ef\uff0c // \u4f46\u662f\u7269\u7406\u5730\u5740\u9700\u8981\u4fdd\u8bc1\u5b83\u4e0e\u9875\u9762\u5927\u5c0f\u5bf9\u9f50\u624d\u80fd\u901a\u8fc7\u53f3\u79fb\u8f6c\u6362\u4e3a\u7269\u7406\u9875\u53f7\u3002 // \u5bf9\u4e8e\u4e0d\u5bf9\u9f50\u7684\u60c5\u51b5\uff0c\u7269\u7406\u5730\u5740\u4e0d\u80fd\u901a\u8fc7 From/Into \u8f6c\u6362\u4e3a\u7269\u7406\u9875\u53f7\uff0c // \u800c\u662f\u9700\u8981\u901a\u8fc7\u5b83\u81ea\u5df1\u7684 floor \u6216 ceil \u65b9\u6cd5\u6765\u8fdb\u884c\u4e0b\u53d6\u6574\u6216\u4e0a\u53d6\u6574\u7684\u8f6c\u6362 pub fn floor(&self) -> VirtPageNum { VirtPageNum(self.0 / PAGE_SIZE) } pub fn ceil(&self) -> VirtPageNum { VirtPageNum((self.0 - 1 + PAGE_SIZE) / PAGE_SIZE) } pub fn page_offset(&self) -> usize { self.0 & (PAGE_SIZE - 1) } pub fn aligned(&self) -> bool { self.page_offset() == 0 } } impl From<VirtAddr> for VirtPageNum { fn from(v: VirtAddr) -> Self { assert_eq!(v.page_offset(), 0); v.floor() } } impl From<VirtPageNum> for VirtAddr { fn from(v: VirtPageNum) -> Self { Self(v.0 << PAGE_SIZE_BITS) } // 12 } impl PhysAddr { pub fn floor(&self) -> PhysPageNum { PhysPageNum(self.0 / PAGE_SIZE) } // \u6574\u9664 pub fn ceil(&self) -> PhysPageNum { PhysPageNum((self.0 - 1 + PAGE_SIZE) / PAGE_SIZE) } // 4096 pub fn page_offset(&self) -> usize { self.0 & (PAGE_SIZE - 1) } // \u4e0e 12 \u4e2a 1 \u76f8\u4e0e pub fn aligned(&self) -> bool { self.page_offset() == 0 } } // \u5730\u5740\u548c\u9875\u53f7\u4e4b\u95f4\u53ef\u4ee5\u76f8\u4e92\u8f6c\u6362 impl From<PhysAddr> for PhysPageNum { fn from(v: PhysAddr) -> Self { assert_eq!(v.page_offset(), 0); // \u4f46\u662f\u7269\u7406\u5730\u5740\u9700\u8981\u4fdd\u8bc1\u5b83\u4e0e\u9875\u9762\u5927\u5c0f\u5bf9\u9f50\u624d\u80fd\u901a\u8fc7\u53f3\u79fb\u8f6c\u6362\u4e3a\u7269\u7406\u9875\u53f7 // \u5373\u9700\u8981\u4fdd\u8bc1\u8fd9\u4e2a\u5730\u5740\u662f\u4e00\u4e2a\u9875\u7684\u5f00\u5934\uff0c\u5373\u672b\u5c3e12\u4f4d\u4e3a 0 v.floor() } } // \u4ece\u7269\u7406\u9875\u53f7\u5230\u7269\u7406\u5730\u5740\u7684\u8f6c\u6362\u53ea\u9700\u5de6\u79fb12\u4f4d\u5373\u53ef\uff0c impl From<PhysPageNum> for PhysAddr { fn from(v: PhysPageNum) -> Self { Self(v.0 << PAGE_SIZE_BITS) } // 12 } impl VirtPageNum { // \u53ef\u4ee5\u53d6\u51fa\u865a\u62df\u9875\u53f7\u7684\u4e09\u7ea7\u9875\u7d22\u5f15\uff0c\u5e76\u6309\u7167\u4ece\u9ad8\u5230\u4f4e\u7684\u987a\u5e8f\u8fd4\u56de\u3002\u6ce8\u610f\u5b83\u91cc\u9762\u5305\u88f9\u7684 usize \u53ef\u80fd\u6709 27 \u4f4d\uff0c // \u4e5f\u6709\u53ef\u80fd\u6709 64 - 12 = 52 \u4f4d\uff0c\u4f46\u8fd9\u91cc\u6211\u4eec\u662f\u7528\u6765\u5728\u591a\u7ea7\u9875\u8868\u4e0a\u8fdb\u884c\u904d\u5386\uff0c\u56e0\u6b64\u53ea\u53d6\u51fa\u4f4e 27 \u4f4d\u3002 pub fn indexes(&self) -> [usize; 3] { let mut vpn = self.0; let mut idx = [0usize; 3]; for i in (0..3).rev() { // \u6ce8\u610f\uff1a\u8fd9\u91cc\u662f\u9006\u5e8f\u5b58\u653e // \u5148\u653e \u7b2c\u4e09\u7ea7\u5730\u5740\uff0c\u5b58\u653e\u7684\u662f\u4e0b\u4e00\u4e2a\u76ee\u5f55\u7684\u5730\u5740 idx[i] = vpn & 511; // 9 \u4e2a 1 vpn >>= 9; } idx } } // \u6211\u4eec\u6784\u9020\u53ef\u53d8\u5f15\u7528\u6765\u76f4\u63a5\u8bbf\u95ee\u4e00\u4e2a\u7269\u7406\u9875\u53f7 PhysPageNum \u5bf9\u5e94\u7684\u7269\u7406\u9875\u5e27\uff0c // \u4e0d\u540c\u7684\u5f15\u7528\u7c7b\u578b\u5bf9\u5e94\u4e8e\u7269\u7406\u9875\u5e27\u4e0a\u7684\u4e00\u79cd\u4e0d\u540c\u7684\u5185\u5b58\u5e03\u5c40 impl PhysPageNum { // get_pte_array \u8fd4\u56de\u7684\u662f\u4e00\u4e2a\u9875\u8868\u9879\u5b9a\u957f\u6570\u7ec4\u7684\u53ef\u53d8\u5f15\u7528\uff0c\u4ee3\u8868\u591a\u7ea7\u9875\u8868\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9 pub fn get_pte_array(&self) -> &'static mut [PageTableEntry] { let pa: PhysAddr = self.clone().into(); // \u90fd\u662f\u5148\u628a\u7269\u7406\u9875\u53f7\u8f6c\u4e3a\u7269\u7406\u5730\u5740 PhysAddr \uff0c\u7136\u540e\u518d\u8f6c\u6210 usize \u5f62\u5f0f\u7684\u7269\u7406\u5730\u5740 unsafe { core::slice::from_raw_parts_mut(pa.0 as *mut PageTableEntry, 512) // \u6211\u4eec\u76f4\u63a5\u5c06\u5b83\u8f6c\u4e3a\u88f8\u6307\u9488\u7528\u6765\u8bbf\u95ee\u7269\u7406\u5730\u5740\u6307\u5411\u7684\u7269\u7406\u5185\u5b58\u3002 // \u5728\u5206\u9875\u673a\u5236\u5f00\u542f\u524d\uff0c\u8fd9\u6837\u505a\u81ea\u7136\u6210\u7acb\uff1b\u800c\u5f00\u542f\u4e4b\u540e\uff0c\u867d\u7136\u88f8\u6307\u9488\u88ab\u89c6\u4e3a\u4e00\u4e2a\u865a\u62df\u5730\u5740\uff0c // \u4f46\u662f\u4e0a\u9762\u5df2\u7ecf\u63d0\u5230\uff0c\u57fa\u4e8e\u6052\u7b49\u6620\u5c04\uff0c\u865a\u62df\u5730\u5740\u4f1a\u6620\u5c04\u5230\u4e00\u4e2a\u76f8\u540c\u7684\u7269\u7406\u5730\u5740\uff0c // \u56e0\u6b64\u5728\u4e5f\u662f\u6210\u7acb\u7684\u3002\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fd4\u56de\u503c\u7c7b\u578b\u4e0a\u9644\u52a0\u4e86\u9759\u6001\u751f\u547d\u5468\u671f\u6cdb\u578b 'static \uff0c // \u8fd9\u662f\u4e3a\u4e86\u7ed5\u8fc7 Rust \u7f16\u8bd1\u5668\u7684\u501f\u7528\u68c0\u67e5\uff0c\u5b9e\u8d28\u4e0a\u53ef\u4ee5\u5c06\u8fd4\u56de\u7684\u7c7b\u578b\u4e5f\u770b\u6210\u4e00\u4e2a\u88f8\u6307\u9488\uff0c // \u56e0\u4e3a\u5b83\u4e5f\u53ea\u662f\u6807\u8bc6\u6570\u636e\u5b58\u653e\u7684\u4f4d\u7f6e\u4ee5\u53ca\u7c7b\u578b\u3002\u4f46\u4e0e\u88f8\u6307\u9488\u4e0d\u540c\u7684\u662f\uff0c // \u65e0\u9700\u901a\u8fc7 unsafe \u7684\u89e3\u5f15\u7528\u8bbf\u95ee\u5b83\u6307\u5411\u7684\u6570\u636e\uff0c\u800c\u662f\u53ef\u4ee5\u50cf\u4e00\u4e2a\u6b63\u5e38\u7684\u53ef\u53d8\u5f15\u7528\u4e00\u6837\u76f4\u63a5\u8bbf\u95ee } } // get_bytes_array \u8fd4\u56de\u7684\u662f\u4e00\u4e2a\u5b57\u8282\u6570\u7ec4\u7684\u53ef\u53d8\u5f15\u7528\uff0c\u53ef\u4ee5\u4ee5\u5b57\u8282\u4e3a\u7c92\u5ea6\u5bf9\u7269\u7406\u9875\u5e27\u4e0a\u7684\u6570\u636e\u8fdb\u884c\u8bbf\u95ee\uff0c // \u524d\u9762\u8fdb\u884c\u6570\u636e\u6e05\u96f6\u5c31\u7528\u5230\u4e86\u8fd9\u4e2a\u65b9\u6cd5 pub fn get_bytes_array(&self) -> &'static mut [u8] { // \u6211\u4eec\u5728\u8fd4\u56de\u503c\u7c7b\u578b\u4e0a\u9644\u52a0\u4e86\u9759\u6001\u751f\u547d\u5468\u671f\u6cdb\u578b 'static \uff0c\u8fd9\u662f\u4e3a\u4e86\u7ed5\u8fc7 Rust \u7f16\u8bd1\u5668\u7684\u501f\u7528\u68c0\u67e5\uff0c // \u5b9e\u8d28\u4e0a\u53ef\u4ee5\u5c06\u8fd4\u56de\u7684\u7c7b\u578b\u4e5f\u770b\u6210\u4e00\u4e2a\u88f8\u6307\u9488\uff0c\u56e0\u4e3a\u5b83\u4e5f\u53ea\u662f\u6807\u8bc6\u6570\u636e\u5b58\u653e\u7684\u4f4d\u7f6e\u4ee5\u53ca\u7c7b\u578b\u3002 // \u4f46\u4e0e\u88f8\u6307\u9488\u4e0d\u540c\u7684\u662f\uff0c\u65e0\u9700\u901a\u8fc7 unsafe \u7684\u89e3\u5f15\u7528\u8bbf\u95ee\u5b83\u6307\u5411\u7684\u6570\u636e\uff0c // \u800c\u662f\u53ef\u4ee5\u50cf\u4e00\u4e2a\u6b63\u5e38\u7684\u53ef\u53d8\u5f15\u7528\u4e00\u6837\u76f4\u63a5\u8bbf\u95ee let pa: PhysAddr = self.clone().into(); // \u5148\u5c06\u7269\u7406\u9875\u53f7 \u8f6c\u6362\u4e3a \u7269\u7406\u5730\u5740 unsafe { core::slice::from_raw_parts_mut(pa.0 as *mut u8, 4096) // \u518d\u8f6c\u6210 usize \u5f62\u5f0f\u7684\u7269\u7406\u5730\u5740\uff0c\u76f4\u63a5\u5c06\u5b83\u8f6c\u4e3a\u88f8\u6307\u9488\u7528\u6765\u8bbf\u95ee\u7269\u7406\u5730\u5740\u6307\u5411\u7684\u7269\u7406\u5185\u5b58 } } // get_mut \u662f\u4e2a\u6cdb\u578b\u51fd\u6570\uff0c\u53ef\u4ee5\u83b7\u53d6\u4e00\u4e2a\u6070\u597d\u653e\u5728\u4e00\u4e2a\u7269\u7406\u9875\u5e27\u5f00\u5934\u7684\u7c7b\u578b\u4e3a T \u7684\u6570\u636e\u7684\u53ef\u53d8\u5f15\u7528 pub fn get_mut<T>(&self) -> &'static mut T { let pa: PhysAddr = self.clone().into(); // \u5148\u5c06\u7269\u7406\u9875\u53f7 \u8f6c\u6362\u4e3a \u7269\u7406\u5730\u5740 unsafe { (pa.0 as *mut T).as_mut().unwrap() } } } pub trait StepByOne { fn step(&mut self); } impl StepByOne for VirtPageNum { fn step(&mut self) { self.0 += 1; } } #[derive(Copy, Clone)] pub struct SimpleRange<T> where T: StepByOne + Copy + PartialEq + PartialOrd + Debug, { l: T, r: T, } impl<T> SimpleRange<T> where T: StepByOne + Copy + PartialEq + PartialOrd + Debug, { pub fn new(start: T, end: T) -> Self { assert!(start <= end, \"start {:?} > end {:?}!\", start, end); Self { l: start, r: end } } pub fn get_start(&self) -> T { self.l } pub fn get_end(&self) -> T { self.r } } impl<T> IntoIterator for SimpleRange<T> where T: StepByOne + Copy + PartialEq + PartialOrd + Debug, { type Item = T; type IntoIter = SimpleRangeIterator<T>; fn into_iter(self) -> Self::IntoIter { SimpleRangeIterator::new(self.l, self.r) } } pub struct SimpleRangeIterator<T> where T: StepByOne + Copy + PartialEq + PartialOrd + Debug, { current: T, end: T, } impl<T> SimpleRangeIterator<T> where T: StepByOne + Copy + PartialEq + PartialOrd + Debug, { pub fn new(l: T, r: T) -> Self { Self { current: l, end: r, } } } impl<T> Iterator for SimpleRangeIterator<T> where T: StepByOne + Copy + PartialEq + PartialOrd + Debug, { type Item = T; fn next(&mut self) -> Option<Self::Item> { if self.current == self.end { None } else { let t = self.current; self.current.step(); Some(t) } } } pub type VPNRange = SimpleRange<VirtPageNum>; os/src/mm/frame_allocator.rs // \u64cd\u4f5c\u7cfb\u7edf\u5982\u679c\u8981\u5efa\u7acb\u9875\u8868\uff08\u6784\u5efa\u865a\u5b9e\u5730\u5740\u6620\u5c04\u5173\u7cfb\uff09\uff0c\u9996\u5148\u8981\u80fd\u7ba1\u7406\u6574\u4e2a\u7cfb\u7edf\u7684\u7269\u7406\u5185\u5b58\uff0c // \u8fd9\u5c31\u9700\u8981\u77e5\u9053\u6574\u4e2a\u8ba1\u7b97\u673a\u7cfb\u7edf\u7684\u7269\u7406\u5185\u5b58\u7a7a\u95f4\u7684\u8303\u56f4\uff0c\u7269\u7406\u5185\u5b58\u4e2d\u54ea\u4e9b\u533a\u57df\u662f\u7a7a\u95f2\u53ef\u7528\u7684\uff0c // \u54ea\u4e9b\u533a\u57df\u653e\u7f6e\u5185\u6838/\u5e94\u7528\u7684\u4ee3\u7801\u548c\u6570\u636e\u3002\u64cd\u4f5c\u7cfb\u7edf\u5185\u6838\u80fd\u591f\u4ee5\u7269\u7406\u9875\u5e27\u4e3a\u5355\u4f4d\u5206\u914d\u548c\u56de\u6536\u7269\u7406\u5185\u5b58 use super::{PhysAddr, PhysPageNum}; use alloc::vec::Vec; use crate::sync::UPSafeCell; use crate::config::MEMORY_END; use lazy_static::*; use core::fmt::{self, Debug, Formatter}; // \u6211\u4eec\u58f0\u660e\u4e00\u4e2a FrameAllocator Trait \u6765\u63cf\u8ff0\u4e00\u4e2a\u7269\u7406\u9875\u5e27\u7ba1\u7406\u5668\u9700\u8981\u63d0\u4f9b\u54ea\u4e9b\u529f\u80fd trait FrameAllocator { fn new() -> Self; fn alloc(&mut self) -> Option<PhysPageNum>; fn dealloc(&mut self, ppn: PhysPageNum); } pub struct FrameTracker { pub ppn: PhysPageNum, } impl FrameTracker { pub fn new(ppn: PhysPageNum) -> Self { // page cleaning let bytes_array = ppn.get_bytes_array(); // ppn \u662f\u4e00\u4e2a\u7ed3\u6784\u4f53\uff0c\u5143\u7ec4\u7ed3\u6784\u4f53\uff0c\u91cc\u9762\u662f\u4e2a usize \u7c7b\u578b\u7684\u6574\u6570 // \u5b83\u6709\u4e2a get_bytes_array \u65b9\u6cd5\uff0c\u8fd4\u56de\u4e00\u4e2a\u5b57\u8282\u6570\u7ec4\u7684\u53ef\u53d8\u5f15\u7528\uff0c // \u8fd4\u56de\u4e00\u4e2a\u6307\u9488\uff0c\u6307\u5411\u5b83\u6240\u5bf9\u5e94\u7684\u7269\u7406\u9875\u7684\u5730\u5740 // \u4ee5\u4ee5\u5b57\u8282\u4e3a\u7c92\u5ea6\u5bf9\u7269\u7406\u9875\u5e27\u4e0a\u7684\u6570\u636e\u8fdb\u884c\u8bbf\u95ee for i in bytes_array { *i = 0; } // \u6211\u4eec\u5c06\u5206\u914d\u6765\u7684\u7269\u7406\u9875\u5e27\u7684\u7269\u7406\u9875\u53f7\u4f5c\u4e3a\u53c2\u6570\u4f20\u7ed9 FrameTracker \u7684 new \u65b9\u6cd5\u6765\u521b\u5efa\u4e00\u4e2a FrameTracker \u5b9e\u4f8b\u3002 // \u7531\u4e8e\u8fd9\u4e2a\u7269\u7406\u9875\u5e27\u4e4b\u524d\u53ef\u80fd\u88ab\u5206\u914d\u8fc7\u5e76\u7528\u505a\u5176\u4ed6\u7528\u9014\uff0c\u6211\u4eec\u5728\u8fd9\u91cc\u76f4\u63a5\u5c06\u8fd9\u4e2a\u7269\u7406\u9875\u5e27\u4e0a\u7684\u6240\u6709\u5b57\u8282\u6e05\u96f6 Self { ppn } } } impl Debug for FrameTracker { fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result { f.write_fmt(format_args!(\"FrameTracker:PPN={:#x}\", self.ppn.0)) } } impl Drop for FrameTracker { fn drop(&mut self) { frame_dealloc(self.ppn); } // \u5f53\u4e00\u4e2a FrameTracker \u751f\u547d\u5468\u671f\u7ed3\u675f\u88ab\u7f16\u8bd1\u5668\u56de\u6536\u7684\u65f6\u5019\uff0c\u6211\u4eec\u9700\u8981\u5c06\u5b83\u63a7\u5236\u7684\u7269\u7406\u9875\u5e27\u56de\u6536\u6389 // \u8fd9\u91cc\u6211\u4eec\u53ea\u9700\u4e3a FrameTracker \u5b9e\u73b0 Drop Trait \u5373\u53ef\u3002\u5f53\u4e00\u4e2a FrameTracker \u5b9e\u4f8b\u88ab\u56de\u6536\u7684\u65f6\u5019\uff0c // \u5b83\u7684 drop \u65b9\u6cd5\u4f1a\u81ea\u52a8\u88ab\u7f16\u8bd1\u5668\u8c03\u7528\uff0c // \u901a\u8fc7\u4e4b\u524d\u5b9e\u73b0\u7684 frame_dealloc \u6211\u4eec\u5c31\u5c06\u5b83\u63a7\u5236\u7684\u7269\u7406\u9875\u5e27\u56de\u6536\u4ee5\u4f9b\u540e\u7eed\u4f7f\u7528\u4e86 } // \u5b9e\u73b0\u4e00\u79cd\u6700\u7b80\u5355\u7684\u6808\u5f0f\u7269\u7406\u9875\u5e27\u7ba1\u7406\u7b56\u7565 StackFrameAllocator pub struct StackFrameAllocator { current: usize, end: usize, // \u7269\u7406\u9875\u53f7\u533a\u95f4 [ current , end ) \u6b64\u524d\u5747 \u4ece\u672a \u88ab\u5206\u914d\u51fa\u53bb\u8fc7 recycled: Vec<usize>, // \u5411\u91cf recycled \u4ee5\u540e\u5165\u5148\u51fa\u7684\u65b9\u5f0f\u4fdd\u5b58\u4e86\u88ab\u56de\u6536\u7684\u7269\u7406\u9875\u53f7 } impl StackFrameAllocator { pub fn init(&mut self, l: PhysPageNum, r: PhysPageNum) { self.current = l.0; self.end = r.0; } // \u800c\u5728\u5b83\u771f\u6b63\u88ab\u4f7f\u7528\u8d77\u6765\u4e4b\u524d\uff0c\u9700\u8981\u8c03\u7528 init \u65b9\u6cd5\u5c06\u81ea\u8eab\u7684 [current, end) \u521d\u59cb\u5316\u4e3a\u53ef\u7528\u7269\u7406\u9875\u53f7\u533a\u95f4 } impl FrameAllocator for StackFrameAllocator { fn new() -> Self { Self { current: 0, end: 0, recycled: Vec::new(), } } // \u521d\u59cb\u5316\u975e\u5e38\u7b80\u5355\u3002\u5728\u901a\u8fc7 FrameAllocator \u7684 new \u65b9\u6cd5\u521b\u5efa\u5b9e\u4f8b\u7684\u65f6\u5019\uff0c\u53ea\u9700\u5c06\u533a\u95f4\u4e24\u7aef\u5747\u8bbe\u4e3a \uff0c\u7136\u540e\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u5411\u91cf fn alloc(&mut self) -> Option<PhysPageNum> { if let Some(ppn) = self.recycled.pop() { // \u5728\u5206\u914d alloc \u7684\u65f6\u5019\uff0c\u9996\u5148\u4f1a\u68c0\u67e5\u6808 recycled \u5185\u6709\u6ca1\u6709\u4e4b\u524d\u56de\u6536\u7684\u7269\u7406\u9875\u53f7\uff0c // \u5982\u679c\u6709\u7684\u8bdd\u76f4\u63a5\u5f39\u51fa\u6808\u9876\u5e76\u8fd4\u56de Some(ppn.into()) } else { if self.current == self.end { None // \u6781\u7aef\u60c5\u51b5\u4e0b\u53ef\u80fd\u51fa\u73b0\u5185\u5b58\u8017\u5c3d\u5206\u914d\u5931\u8d25\u7684\u60c5\u51b5\uff1a\u5373 recycled \u4e3a\u7a7a\u4e14 current == end // \u4e3a\u4e86\u6db5\u76d6\u8fd9\u79cd\u60c5\u51b5\uff0c alloc \u7684\u8fd4\u56de\u503c\u88ab Option \u5305\u88f9\uff0c\u6211\u4eec\u8fd4\u56de None \u5373\u53ef } else { self.current += 1; Some((self.current - 1).into()) // \u5426\u5219\u7684\u8bdd\u6211\u4eec\u53ea\u80fd\u4ece\u4e4b\u524d\u4ece\u672a\u5206\u914d\u8fc7\u7684\u7269\u7406\u9875\u53f7\u533a\u95f4 [ current , end ) \u4e0a\u8fdb\u884c\u5206\u914d\uff0c // \u6211\u4eec\u5206\u914d\u5b83\u7684\u5de6\u7aef\u70b9 current \uff0c\u540c\u65f6\u5c06\u7ba1\u7406\u5668\u5185\u90e8\u7ef4\u62a4\u7684 current \u52a0 1 \u4ee3\u8868 current \u5df2\u88ab\u5206\u914d\u4e86\u3002 // \u5728\u5373\u5c06\u8fd4\u56de\u7684\u65f6\u5019\uff0c\u6211\u4eec\u4f7f\u7528 into \u65b9\u6cd5\u5c06 usize \u8f6c\u6362\u6210\u4e86\u7269\u7406\u9875\u53f7 PhysPageNum } } } fn dealloc(&mut self, ppn: PhysPageNum) // \u5143\u7ec4\u7c7b\u578b // \u5728\u56de\u6536 dealloc \u7684\u65f6\u5019\uff0c\u6211\u4eec\u9700\u8981\u68c0\u67e5\u56de\u6536\u9875\u9762\u7684\u5408\u6cd5\u6027\uff0c\u7136\u540e\u5c06\u5176\u538b\u5165 recycled \u6808\u4e2d let ppn = ppn.0; // validity check // \u8be5\u9875\u9762\u4e4b\u524d\u4e00\u5b9a\u88ab\u5206\u914d\u51fa\u53bb\u8fc7\uff0c\u56e0\u6b64\u5b83\u7684\u7269\u7406\u9875\u53f7\u4e00\u5b9a current \uff1b // \u8be5\u9875\u9762\u6ca1\u6709\u6b63\u5904\u5728\u56de\u6536\u72b6\u6001\uff0c\u5373\u5b83\u7684\u7269\u7406\u9875\u53f7\u4e0d\u80fd\u5728\u6808 recycled \u4e2d\u627e\u5230 if ppn >= self.current || self.recycled .iter() .find(|&v| {*v == ppn}) .is_some() { panic!(\"Frame ppn={:#x} has not been allocated!\", ppn); // \u6211\u4eec\u901a\u8fc7 recycled.iter() \u83b7\u53d6\u6808\u4e0a\u5185\u5bb9\u7684\u8fed\u4ee3\u5668\uff0c // \u7136\u540e\u901a\u8fc7\u8fed\u4ee3\u5668\u7684 find \u65b9\u6cd5\u8bd5\u56fe\u5bfb\u627e\u4e00\u4e2a\u4e0e\u8f93\u5165\u7269\u7406\u9875\u53f7\u76f8\u540c\u7684\u5143\u7d20\u3002 // \u5176\u8fd4\u56de\u503c\u662f\u4e00\u4e2a Option \uff0c\u5982\u679c\u627e\u5230\u4e86\u5c31\u4f1a\u662f\u4e00\u4e2a Option::Some \uff0c // \u8fd9\u79cd\u60c5\u51b5\u8bf4\u660e\u6211\u4eec\u5185\u6838\u5176\u4ed6\u90e8\u5206\u5b9e\u73b0\u6709\u8bef\uff0c\u76f4\u63a5\u62a5\u9519\u9000\u51fa } // recycle self.recycled.push(ppn); } } type FrameAllocatorImpl = StackFrameAllocator; lazy_static! { // \u8fd9\u91cc\u6211\u4eec\u4f7f\u7528 UPSafeCell<T> \u6765\u5305\u88f9\u6808\u5f0f\u7269\u7406\u9875\u5e27\u5206\u914d\u5668\u3002\u6bcf\u6b21\u5bf9\u8be5\u5206\u914d\u5668\u8fdb\u884c\u64cd\u4f5c\u4e4b\u524d\uff0c // \u6211\u4eec\u90fd\u9700\u8981\u5148\u901a\u8fc7 FRAME_ALLOCATOR.exclusive_access() \u62ff\u5230\u5206\u914d\u5668\u7684\u53ef\u53d8\u501f\u7528 pub static ref FRAME_ALLOCATOR: UPSafeCell<FrameAllocatorImpl> = unsafe { // \u5b83\u7684\u672c\u8d28\u662f\u4e00\u4e2a\u6307\u9488\uff0c\u4e00\u4e2a\u5f15\u7528\uff0c \u6307\u5411\u7684\u662f FrameAllocatorImpl \u7c7b\u578b // \u5373 StackFrameAllocator \u7c7b\u578b UPSafeCell::new(FrameAllocatorImpl::new()) // \u521b\u5efa StackFrameAllocator \u7684\u5b9e\u4f8b\uff0c\u5e76\u521b\u5efa\u5b83\u7684\u5f15\u7528 \u518d \u8fd4\u56de\u51fa\u53bb }; } pub fn init_frame_allocator() { extern \"C\" { fn ekernel(); } // \u5728\u6b63\u5f0f\u5206\u914d\u7269\u7406\u9875\u5e27\u4e4b\u524d\uff0c\u6211\u4eec\u9700\u8981\u5c06\u7269\u7406\u9875\u5e27\u5168\u5c40\u7ba1\u7406\u5668 FRAME_ALLOCATOR \u521d\u59cb\u5316 FRAME_ALLOCATOR .exclusive_access() // \u62ff\u5230\u5206\u914d\u5668\u7684 \u53ef\u53d8\u501f\u7528 .init(PhysAddr::from(ekernel as usize).ceil(), PhysAddr::from(MEMORY_END).floor()); // \u8fd9\u91cc\u6211\u4eec\u8c03\u7528\u7269\u7406\u5730\u5740 PhysAddr \u7684 floor/ceil \u65b9\u6cd5\u5206\u522b\u4e0b/\u4e0a\u53d6\u6574\u83b7\u5f97\u53ef\u7528\u7684\u7269\u7406\u9875\u53f7\u533a\u95f4 } // \u7136\u540e\u662f\u516c\u5f00\u7ed9\u5176\u4ed6\u5185\u6838\u6a21\u5757\u8c03\u7528\u7684\u5206\u914d/\u56de\u6536\u7269\u7406\u9875\u5e27\u7684\u63a5\u53e3 pub fn frame_alloc() -> Option<FrameTracker> { FRAME_ALLOCATOR .exclusive_access() .alloc() .map(|ppn| FrameTracker::new(ppn)) // \u53ef\u4ee5\u53d1\u73b0\uff0c frame_alloc \u7684\u8fd4\u56de\u503c\u7c7b\u578b\u5e76\u4e0d\u662f FrameAllocator \u8981\u6c42\u7684\u7269\u7406\u9875\u53f7 PhysPageNum \uff0c // \u800c\u662f\u5c06\u5176\u8fdb\u4e00\u6b65\u5305\u88c5\u4e3a\u4e00\u4e2a FrameTracker \u3002\u8fd9\u91cc\u501f\u7528\u4e86 RAII \u7684\u601d\u60f3\uff0c // \u5c06\u4e00\u4e2a\u7269\u7406\u9875\u5e27\u7684\u751f\u547d\u5468\u671f\u7ed1\u5b9a\u5230\u4e00\u4e2a FrameTracker \u53d8\u91cf\u4e0a\uff0c // \u5f53\u4e00\u4e2a FrameTracker \u88ab\u521b\u5efa\u7684\u65f6\u5019\uff0c\u6211\u4eec\u9700\u8981\u4ece FRAME_ALLOCATOR \u4e2d\u5206\u914d\u4e00\u4e2a\u7269\u7406\u9875\u5e27 } fn frame_dealloc(ppn: PhysPageNum) { FRAME_ALLOCATOR .exclusive_access() .dealloc(ppn); } #[allow(unused)] pub fn frame_allocator_test() { let mut v: Vec<FrameTracker> = Vec::new(); for i in 0..5 { let frame = frame_alloc().unwrap(); println!(\"{:?}\", frame); v.push(frame); } v.clear(); for i in 0..5 { let frame = frame_alloc().unwrap(); println!(\"{:?}\", frame); v.push(frame); } drop(v); println!(\"frame_allocator_test passed!\"); } os/src/mm/heap_allocator.rs use buddy_system_allocator::LockedHeap; use crate::config::KERNEL_HEAP_SIZE; #[global_allocator] static HEAP_ALLOCATOR: LockedHeap = LockedHeap::empty(); // \u6211\u4eec\u76f4\u63a5\u5c06 buddy_system_allocator \u4e2d\u63d0\u4f9b\u7684 LockedHeap \u5b9e\u4f8b\u5316\u6210\u4e00\u4e2a\u5168\u5c40\u53d8\u91cf\uff0c // \u5e76\u4f7f\u7528 alloc \u8981\u6c42\u7684 #[global_allocator] \u8bed\u4e49\u9879\u8fdb\u884c\u6807\u8bb0\u3002 // \u6ce8\u610f LockedHeap \u5df2\u7ecf\u5b9e\u73b0\u4e86 GlobalAlloc \u8981\u6c42\u7684\u62bd\u8c61\u63a5\u53e3\u4e86 // // alloc::alloc::GlobalAlloc // pub unsafe fn alloc(&self, layout: Layout) -> *mut u8; // pub unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout); // \u5b83\u4eec\u7c7b\u4f3c C \u8bed\u8a00\u4e2d\u7684 malloc/free \uff0c\u5206\u522b\u4ee3\u8868\u5806\u7a7a\u95f4\u7684\u5206\u914d\u548c\u56de\u6536\uff0c // \u4e5f\u540c\u6837\u4f7f\u7528\u4e00\u4e2a\u88f8\u6307\u9488\uff08\u4e5f\u5c31\u662f\u5730\u5740\uff09\u4f5c\u4e3a\u5206\u914d\u7684\u8fd4\u56de\u503c\u548c\u56de\u6536\u7684\u53c2\u6570\u3002\u4e24\u4e2a\u63a5\u53e3\u4e2d\u90fd\u6709\u4e00\u4e2aalloc::alloc::Layout \u7c7b\u578b\u7684\u53c2\u6570\uff0c // \u5b83\u6307\u51fa\u4e86\u5206\u914d\u7684\u9700\u6c42\uff0c\u5206\u4e3a\u4e24\u90e8\u5206\uff0c\u5206\u522b\u662f\u6240\u9700\u7a7a\u95f4\u7684\u5927\u5c0f size \uff0c\u4ee5\u53ca\u8fd4\u56de\u5730\u5740\u7684\u5bf9\u9f50\u8981\u6c42 align \u3002 // \u8fd9\u4e2a\u5bf9\u9f50\u8981\u6c42\u5fc5\u987b\u662f\u4e00\u4e2a 2 \u7684\u5e42\u6b21\uff0c\u5355\u4f4d\u4e3a\u5b57\u8282\u6570\uff0c\u9650\u5236\u8fd4\u56de\u7684\u5730\u5740\u5fc5\u987b\u662f align \u7684\u500d\u6570 #[alloc_error_handler] pub fn handle_alloc_error(layout: core::alloc::Layout) -> ! { panic!(\"Heap allocation error, layout = {:?}\", layout); } // \u6211\u4eec\u8fd8\u9700\u8981\u5904\u7406\u52a8\u6001\u5185\u5b58\u5206\u914d\u5931\u8d25\u7684\u60c5\u5f62 static mut HEAP_SPACE: [u8; KERNEL_HEAP_SIZE] = [0; KERNEL_HEAP_SIZE]; // \u8fd9\u5757\u5185\u5b58\u662f\u4e00\u4e2a static mut \u4e14\u88ab\u96f6\u521d\u59cb\u5316\u7684\u5b57\u8282\u6570\u7ec4\uff0c\u4f4d\u4e8e\u5185\u6838\u7684 .bss \u6bb5\u4e2d pub fn init_heap() { // \u5728\u4f7f\u7528\u4efb\u4f55 alloc \u4e2d\u63d0\u4f9b\u7684\u5806\u6570\u636e\u7ed3\u6784\u4e4b\u524d\uff0c\u6211\u4eec\u9700\u8981\u5148\u8c03\u7528 init_heap \u51fd\u6570\u6765\u7ed9\u6211\u4eec\u7684\u5168\u5c40\u5206\u914d\u5668\u4e00\u5757\u5185\u5b58\u7528\u4e8e\u5206\u914d unsafe { HEAP_ALLOCATOR .lock() .init(HEAP_SPACE.as_ptr() as usize, KERNEL_HEAP_SIZE); // LockedHeap \u4e5f\u662f\u4e00\u4e2a\u88ab\u4e92\u65a5\u9501 Mutex<T> \u4fdd\u62a4\u7684\u7c7b\u578b\uff0c // \u5728\u5bf9\u5b83\u4efb\u4f55\u8fdb\u884c\u4efb\u4f55\u64cd\u4f5c\u4e4b\u524d\u90fd\u8981\u5148\u83b7\u53d6\u9501\u4ee5\u907f\u514d\u5176\u4ed6\u7ebf\u7a0b\u540c\u65f6\u5bf9\u5b83\u8fdb\u884c\u64cd\u4f5c\u5bfc\u81f4\u6570\u636e\u7ade\u4e89\u3002 // \u7136\u540e\uff0c\u8c03\u7528 init \u65b9\u6cd5\u544a\u77e5\u5b83\u80fd\u591f\u7528\u6765\u5206\u914d\u7684\u7a7a\u95f4\u7684\u8d77\u59cb\u5730\u5740\u548c\u5927\u5c0f\u5373\u53ef\u3002 } } #[allow(unused)] pub fn heap_test() { use alloc::boxed::Box; use alloc::vec::Vec; extern \"C\" { fn sbss(); fn ebss(); } let bss_range = sbss as usize..ebss as usize; let a = Box::new(5); assert_eq!(*a, 5); assert!(bss_range.contains(&(a.as_ref() as *const _ as usize))); drop(a); let mut v: Vec<usize> = Vec::new(); for i in 0..500 { v.push(i); } for i in 0..500 { assert_eq!(v[i], i); } assert!(bss_range.contains(&(v.as_ptr() as usize))); drop(v); println!(\"heap_test passed!\"); } // \u5176\u4e2d\u5206\u522b\u4f7f\u7528\u667a\u80fd\u6307\u9488 Box<T> \u548c\u5411\u91cf Vec<T> \u5728\u5806\u4e0a\u5206\u914d\u6570\u636e\u5e76\u7ba1\u7406\u5b83\u4eec\uff0c // \u901a\u8fc7 as_ref \u548c as_ptr \u65b9\u6cd5\u53ef\u4ee5\u5206\u522b\u770b\u5230\u5b83\u4eec\u6307\u5411\u7684\u6570\u636e\u7684\u4f4d\u7f6e\uff0c\u80fd\u591f\u786e\u8ba4\u5b83\u4eec\u7684\u786e\u5728\u4f4d\u4e8e .bss \u6bb5\u7684\u5806\u4e0a os/src/mm/memory_set.rs // \u4e00\u65e6\u4f7f\u80fd\u5206\u9875\u673a\u5236\uff0cCPU \u8bbf\u95ee\u5230\u7684\u5730\u5740\u90fd\u662f\u865a\u62df\u5730\u5740\u4e86\uff0c\u90a3\u4e48\u5185\u6838\u4e2d\u4e5f\u5c06\u57fa\u4e8e\u865a\u5730\u5740\u8fdb\u884c\u865a\u5b58\u8bbf\u95ee\u3002 // \u6240\u4ee5\u5728\u7ed9\u5e94\u7528\u6dfb\u52a0\u865a\u62df\u5730\u5740\u7a7a\u95f4\u524d\uff0c\u5185\u6838\u81ea\u5df1\u4e5f\u4f1a\u5efa\u7acb\u4e00\u4e2a\u9875\u8868\uff0c // \u628a\u6574\u5757\u7269\u7406\u5185\u5b58\u901a\u8fc7\u7b80\u5355\u7684\u6052\u7b49\u6620\u5c04\uff08\u5373\u865a\u62df\u5730\u5740\u6620\u5c04\u5230\u5bf9\u7b49\u7684\u7269\u7406\u5730\u5740\uff09\u6620\u5c04\u5230\u5185\u6838\u865a\u62df\u5730\u5740\u7a7a\u95f4\u4e2d\u3002 // \u540e\u7eed\u7684\u5e94\u7528\u5728\u6267\u884c\u524d\uff0c\u4e5f\u9700\u8981\u64cd\u4f5c\u7cfb\u7edf\u5e2e\u52a9\u5b83\u5efa\u7acb\u4e00\u4e2a\u865a\u62df\u5730\u5740\u7a7a\u95f4 // \u5728\u4e00\u4e2a\u865a\u62df\u5730\u5740\u7a7a\u95f4\u4e2d\uff0c\u6709\u4ee3\u7801\u6bb5\uff0c\u6570\u636e\u6bb5\u7b49\u4e0d\u540c\u5c5e\u6027\u4e14\u4e0d\u4e00\u5b9a\u8fde\u7eed\u7684\u5b50\u7a7a\u95f4\uff0c // \u5b83\u4eec\u901a\u8fc7\u4e00\u4e2a\u91cd\u8981\u7684\u6570\u636e\u7ed3\u6784 MapArea \u6765\u8868\u793a\u548c\u7ba1\u7406 use super::{PageTable, PageTableEntry, PTEFlags}; use super::{VirtPageNum, VirtAddr, PhysPageNum, PhysAddr}; use super::{FrameTracker, frame_alloc}; use super::{VPNRange, StepByOne}; use alloc::collections::BTreeMap; use alloc::vec::Vec; use riscv::register::satp; use alloc::sync::Arc; use lazy_static::*; use crate::sync::UPSafeCell; use crate::config::{ MEMORY_END, PAGE_SIZE, TRAMPOLINE, TRAP_CONTEXT, USER_STACK_SIZE }; use core::arch::asm; extern \"C\" { fn stext(); fn etext(); fn srodata(); fn erodata(); fn sdata(); fn edata(); fn sbss_with_stack(); fn ebss(); fn ekernel(); fn strampoline(); } // \u521b\u5efa\u5185\u6838\u5730\u5740\u7a7a\u95f4\u7684\u5168\u5c40\u5b9e\u4f8b lazy_static! { pub static ref KERNEL_SPACE: Arc<UPSafeCell<MemorySet>> = Arc::new(unsafe { UPSafeCell::new(MemorySet::new_kernel() )}); // \u4ece\u4e4b\u524d\u5bf9\u4e8e lazy_static! \u5b8f\u7684\u4ecb\u7ecd\u53ef\u77e5\uff0c KERNEL_SPACE \u5728\u8fd0\u884c\u671f\u95f4\u5b83\u7b2c\u4e00\u6b21\u88ab\u7528\u5230\u65f6\u624d\u4f1a\u5b9e\u9645\u8fdb\u884c\u521d\u59cb\u5316\uff0c // \u800c\u5b83\u6240 \u5360\u636e\u7684\u7a7a\u95f4\u5219\u662f\u7f16\u8bd1\u671f\u88ab\u653e\u5728\u5168\u5c40\u6570\u636e\u6bb5\u4e2d\u3002\u8fd9\u91cc\u4f7f\u7528 Arc<UPSafeCell<T>> \u7ec4\u5408\u662f\u56e0\u4e3a\u6211\u4eec\u65e2\u9700\u8981 Arc<T> \u63d0\u4f9b\u7684\u5171\u4eab \u5f15\u7528\uff0c // \u4e5f\u9700\u8981 UPSafeCell<T> \u63d0\u4f9b\u7684\u5185\u90e8\u53ef\u53d8\u5f15\u7528\u8bbf\u95ee // \u9996\u5148\uff0c\u6211\u4eec\u5f15\u7528 KERNEL_SPACE \uff0c\u8fd9\u662f\u5b83\u7b2c\u4e00\u6b21\u88ab\u4f7f\u7528\uff0c\u5c31\u5728\u6b64\u65f6\u5b83\u4f1a\u88ab\u521d\u59cb\u5316\uff0c // \u8c03\u7528 MemorySet::new_kernel \u521b\u5efa\u4e00\u4e2a\u5185\u6838\u5730\u5740\u7a7a\u95f4\u5e76\u4f7f\u7528 Arc<Mutex<T>> \u5305\u88f9\u8d77\u6765\uff1b // \u63a5\u7740\u4f7f\u7528 .exclusive_access() \u83b7\u53d6\u4e00\u4e2a\u53ef\u53d8\u5f15\u7528 &mut MemorySet \u3002 // \u9700\u8981\u6ce8\u610f\u7684\u662f\u8fd9\u91cc\u53d1\u751f\u4e86\u4e24\u6b21\u9690\u5f0f\u7c7b\u578b\u8f6c\u6362\uff1a // \u6211\u4eec\u77e5\u9053 exclusive_access \u662f UPSafeCell<T> \u7684\u65b9\u6cd5\u800c\u4e0d\u662f Arc<T> \u7684\u65b9\u6cd5\uff0c // \u7531\u4e8e Arc<T> \u5b9e\u73b0\u4e86 Deref Trait \uff0c\u5f53 exclusive_access \u9700\u8981\u4e00\u4e2a &UPSafeCell<T> \u7c7b\u578b\u7684\u53c2\u6570\u7684\u65f6\u5019\uff0c // \u7f16\u8bd1\u5668\u4f1a\u81ea\u52a8\u5c06\u4f20\u5165\u7684 Arc<UPSafeCell<T>> \u8f6c\u6362\u4e3a &UPSafeCell<T> \u8fd9\u6837\u5c31\u5b9e\u73b0\u4e86\u7c7b\u578b\u5339\u914d\uff1b // \u4e8b\u5b9e\u4e0a UPSafeCell<T>::exclusive_access \u8fd4\u56de\u7684\u662f\u4e00\u4e2a RefMut<'_, T> \uff0c // \u8fd9\u540c\u6837\u662f RAII \u7684\u601d\u60f3\uff0c\u5f53\u8fd9\u4e2a\u7c7b\u578b\u751f\u547d\u5468\u671f\u7ed3\u675f\u540e\u4e92\u65a5\u9501\u5c31\u4f1a\u88ab\u91ca\u653e\u3002 // \u800c\u8be5\u7c7b\u578b\u5b9e\u73b0\u4e86 DerefMut Trait\uff0c\u56e0\u6b64\u5f53\u4e00\u4e2a\u51fd\u6570\u63a5\u53d7\u7c7b\u578b\u4e3a &mut T \u7684\u53c2\u6570\u5374\u88ab\u4f20\u5165\u4e00\u4e2a\u7c7b\u578b\u4e3a &mut RefMut<'_, T> \u7684\u53c2\u6570\u7684\u65f6\u5019\uff0c // \u7f16\u8bd1\u5668\u4f1a\u81ea\u52a8\u8fdb\u884c\u7c7b\u578b\u8f6c\u6362\u4f7f\u53c2\u6570\u5339\u914d\u3002 } // \u5730\u5740\u7a7a\u95f4 \u662f\u4e00\u7cfb\u5217\u6709\u5173\u8054\u7684\u4e0d\u4e00\u5b9a\u8fde\u7eed\u7684\u903b\u8f91\u6bb5\uff0c // \u8fd9\u79cd\u5173\u8054\u4e00\u822c\u662f\u6307\u8fd9\u4e9b\u903b\u8f91\u6bb5\u7ec4\u6210\u7684\u865a\u62df\u5185\u5b58\u7a7a\u95f4\u4e0e\u4e00\u4e2a\u8fd0\u884c\u7684\u7a0b\u5e8f\uff08\u76ee\u524d\u628a\u4e00\u4e2a\u8fd0\u884c\u7684\u7a0b\u5e8f\u79f0\u4e3a\u4efb\u52a1\uff0c // \u540e\u7eed\u4f1a\u79f0\u4e3a\u8fdb\u7a0b\uff09\u7ed1\u5b9a\uff0c\u5373\u8fd9\u4e2a\u8fd0\u884c\u7684\u7a0b\u5e8f\u5bf9\u4ee3\u7801\u548c\u6570\u636e\u7684\u76f4\u63a5\u8bbf\u95ee\u8303\u56f4\u9650\u5236\u5728\u5b83\u5173\u8054\u7684\u865a\u62df\u5730\u5740\u7a7a\u95f4\u4e4b\u5185\u3002 // \u8fd9\u6837\u6211\u4eec\u5c31\u6709\u4efb\u52a1\u7684\u5730\u5740\u7a7a\u95f4\uff0c\u5185\u6838\u7684\u5730\u5740\u7a7a\u95f4\u7b49\u8bf4\u6cd5\u4e86\u3002\u5730\u5740\u7a7a\u95f4\u4f7f\u7528 MemorySet \u7c7b\u578b\u6765\u8868\u793a pub struct MemorySet { page_table: PageTable, // \u8be5\u5730\u5740\u7a7a\u95f4\u7684\u591a\u7ea7\u9875\u8868 page_table // PageTable \u4e0b\u6302\u7740\u6240\u6709\u591a\u7ea7\u9875\u8868\u7684\u8282\u70b9\u6240\u5728\u7684\u7269\u7406\u9875\u5e27 areas: Vec<MapArea>, // \u4e00\u4e2a\u903b\u8f91\u6bb5 MapArea \u7684\u5411\u91cf areas // \u6bcf\u4e2a MapArea \u4e0b\u5219\u6302\u7740\u5bf9\u5e94\u903b\u8f91\u6bb5\u4e2d\u7684\u6570\u636e\u6240\u5728\u7684\u7269\u7406\u9875\u5e27\uff0c\u8fd9\u4e24\u90e8\u5206\u5408\u5728\u4e00\u8d77\u6784\u6210\u4e86\u4e00\u4e2a\u5730\u5740\u7a7a\u95f4\u6240\u9700\u7684\u6240\u6709\u7269\u7406\u9875\u5e27\u3002 // \u8fd9\u540c\u6837\u662f\u4e00\u79cd RAII \u98ce\u683c\uff0c\u5f53\u4e00\u4e2a\u5730\u5740\u7a7a\u95f4 MemorySet \u751f\u547d\u5468\u671f\u7ed3\u675f\u540e\uff0c\u8fd9\u4e9b\u7269\u7406\u9875\u5e27\u90fd\u4f1a\u88ab\u56de\u6536 } impl MemorySet { // \u65b0\u5efa\u4e00\u4e2a\u7a7a\u7684\u5730\u5740\u7a7a\u95f4 pub fn new_bare() -> Self { Self { page_table: PageTable::new(), areas: Vec::new(), } } pub fn token(&self) -> usize { self.page_table.token() } /// Assume that no conflicts. // \u8c03\u7528 push \uff0c\u53ef\u4ee5\u5728\u5f53\u524d\u5730\u5740\u7a7a\u95f4\u63d2\u5165\u4e00\u4e2a Framed \u65b9\u5f0f\u6620\u5c04\u5230\u7269\u7406\u5185\u5b58\u7684\u903b\u8f91\u6bb5\u3002 // \u6ce8\u610f\u8be5\u65b9\u6cd5\u7684\u8c03\u7528\u8005\u8981\u4fdd\u8bc1\u540c\u4e00\u5730\u5740\u7a7a\u95f4\u5185\u7684\u4efb\u610f\u4e24\u4e2a\u903b\u8f91\u6bb5\u4e0d\u80fd\u5b58\u5728\u4ea4\u96c6\uff0c // \u4ece\u540e\u9762\u5373\u5c06\u5206\u522b\u4ecb\u7ecd\u7684\u5185\u6838\u548c\u5e94\u7528\u7684\u5730\u5740\u7a7a\u95f4\u5e03\u5c40\u53ef\u4ee5\u770b\u51fa\u8fd9\u4e00\u8981\u6c42\u5f97\u5230\u4e86\u4fdd\u8bc1 pub fn insert_framed_area(&mut self, start_va: VirtAddr, end_va: VirtAddr, permission: MapPermission) { self.push(MapArea::new( start_va, end_va, MapType::Framed, permission, ), None); } // push \u65b9\u6cd5\u53ef\u4ee5\u5728\u5f53\u524d\u5730\u5740\u7a7a\u95f4\u63d2\u5165\u4e00\u4e2a\u65b0\u7684\u903b\u8f91\u6bb5 map_area \uff0c\u5982\u679c\u5b83\u662f\u4ee5 Framed \u65b9\u5f0f\u6620\u5c04\u5230\u7269\u7406\u5185\u5b58\uff0c // \u8fd8\u53ef\u4ee5\u53ef\u9009\u5730\u5728\u90a3\u4e9b\u88ab\u6620\u5c04\u5230\u7684\u7269\u7406\u9875\u5e27\u4e0a\u5199\u5165\u4e00\u4e9b\u521d\u59cb\u5316\u6570\u636e data fn push(&mut self, mut map_area: MapArea, data: Option<&[u8]>) { map_area.map(&mut self.page_table); if let Some(data) = data { map_area.copy_data(&mut self.page_table, data); } self.areas.push(map_area); } /// Mention that trampoline is not collected by areas. fn map_trampoline(&mut self) { self.page_table.map( VirtAddr::from(TRAMPOLINE).into(), PhysAddr::from(strampoline as usize).into(), PTEFlags::R | PTEFlags::X, ); } /// Without kernel stacks. // \u751f\u6210\u5185\u6838\u7684\u5730\u5740\u7a7a\u95f4 // new_kernel \u5c06\u6620\u5c04\u8df3\u677f\u548c\u5730\u5740\u7a7a\u95f4\u4e2d\u6700\u4f4e \u4e2d\u7684\u5185\u6838\u903b\u8f91\u6bb5\u3002 // \u6211\u4eec\u4ece os/src/linker.ld \u4e2d\u5f15\u7528\u4e86\u5f88\u591a\u8868\u793a\u5404\u4e2a\u6bb5\u4f4d\u7f6e\u7684\u7b26\u53f7\uff0c\u800c\u540e\u5728 new_kernel \u4e2d\uff0c // \u6211\u4eec\u4ece\u4f4e\u5730\u5740\u5230\u9ad8\u5730\u5740\u4f9d\u6b21\u521b\u5efa 5 \u4e2a\u903b\u8f91\u6bb5\u5e76\u901a\u8fc7 push \u65b9\u6cd5\u5c06\u5b83\u4eec\u63d2\u5165\u5230\u5185\u6838\u5730\u5740\u7a7a\u95f4\u4e2d\uff0c // \u4e0a\u9762\u6211\u4eec\u5df2\u7ecf\u8be6\u7ec6\u4ecb\u7ecd\u8fc7\u8fd9 5 \u4e2a\u903b\u8f91\u6bb5\u3002\u8df3\u677f\u662f\u901a\u8fc7 map_trampoline \u65b9\u6cd5\u6765\u6620\u5c04\u7684 pub fn new_kernel() -> Self { let mut memory_set = Self::new_bare(); // map trampoline memory_set.map_trampoline(); // map kernel sections println!(\".text [{:#x}, {:#x})\", stext as usize, etext as usize); println!(\".rodata [{:#x}, {:#x})\", srodata as usize, erodata as usize); println!(\".data [{:#x}, {:#x})\", sdata as usize, edata as usize); println!(\".bss [{:#x}, {:#x})\", sbss_with_stack as usize, ebss as usize); println!(\"mapping .text section\"); memory_set.push(MapArea::new( (stext as usize).into(), (etext as usize).into(), MapType::Identical, MapPermission::R | MapPermission::X, ), None); println!(\"mapping .rodata section\"); memory_set.push(MapArea::new( (srodata as usize).into(), (erodata as usize).into(), MapType::Identical, MapPermission::R, ), None); println!(\"mapping .data section\"); memory_set.push(MapArea::new( (sdata as usize).into(), (edata as usize).into(), MapType::Identical, MapPermission::R | MapPermission::W, ), None); println!(\"mapping .bss section\"); memory_set.push(MapArea::new( (sbss_with_stack as usize).into(), (ebss as usize).into(), MapType::Identical, MapPermission::R | MapPermission::W, ), None); println!(\"mapping physical memory\"); memory_set.push(MapArea::new( (ekernel as usize).into(), MEMORY_END.into(), MapType::Identical, MapPermission::R | MapPermission::W, ), None); memory_set } /// Include sections in elf and trampoline and TrapContext and user stack, /// also returns user_sp and entry point. // \u5e94\u7528\u7684 ELF \u683c\u5f0f\u53ef\u6267\u884c\u6587\u4ef6\u89e3\u6790\u51fa\u5404\u6570\u636e\u6bb5\u5e76\u5bf9\u5e94\u751f\u6210\u5e94\u7528\u7684\u5730\u5740\u7a7a\u95f4 // \u5728\u521b\u5efa\u5e94\u7528\u5730\u5740\u7a7a\u95f4\u7684\u65f6\u5019\uff0c\u6211\u4eec\u9700\u8981\u5bf9 get_app_data \u5f97\u5230\u7684 ELF \u683c\u5f0f\u6570\u636e\u8fdb\u884c\u89e3\u6790\uff0c // \u627e\u5230\u5404\u4e2a\u903b\u8f91\u6bb5\u6240\u5728\u4f4d\u7f6e\u548c\u8bbf\u95ee\u9650\u5236\u5e76\u63d2\u5165\u8fdb\u6765\uff0c\u6700\u7ec8\u5f97\u5230\u4e00\u4e2a\u5b8c\u6574\u7684\u5e94\u7528\u5730\u5740\u7a7a\u95f4 pub fn from_elf(elf_data: &[u8]) -> (Self, usize, usize) { let mut memory_set = Self::new_bare(); // map trampoline memory_set.map_trampoline(); // \u6211\u4eec\u5c06\u8df3\u677f\u63d2\u5165\u5230\u5e94\u7528\u5730\u5740\u7a7a\u95f4 // map program headers of elf, with U flag let elf = xmas_elf::ElfFile::new(elf_data).unwrap(); // \u6211\u4eec\u4f7f\u7528\u5916\u90e8 crate xmas_elf \u6765\u89e3\u6790\u4f20\u5165\u7684\u5e94\u7528 ELF \u6570\u636e\u5e76\u53ef\u4ee5\u8f7b\u677e\u53d6\u51fa\u5404\u4e2a\u90e8\u5206 // \u6211\u4eec\u53d6\u51fa ELF \u7684\u9b54\u6570\u6765\u5224\u65ad\u5b83\u662f\u4e0d\u662f\u4e00\u4e2a\u5408\u6cd5\u7684 ELF let elf_header = elf.header; let magic = elf_header.pt1.magic; assert_eq!(magic, [0x7f, 0x45, 0x4c, 0x46], \"invalid elf!\"); let ph_count = elf_header.pt2.ph_count(); // \u6211\u4eec\u53ef\u4ee5\u76f4\u63a5\u5f97\u5230 program header \u7684\u6570\u76ee\uff0c let mut max_end_vpn = VirtPageNum(0); // \u7136\u540e\u904d\u5386\u6240\u6709\u7684 program header \u5e76\u5c06\u5408\u9002\u7684\u533a\u57df\u52a0\u5165\u5230\u5e94\u7528\u5730\u5740\u7a7a\u95f4\u4e2d for i in 0..ph_count { let ph = elf.program_header(i).unwrap(); if ph.get_type().unwrap() == xmas_elf::program::Type::Load { // program header \u7684\u7c7b\u578b\u662f LOAD \uff0c\u8fd9\u8868\u660e\u5b83\u6709\u88ab\u5185\u6838\u52a0\u8f7d\u7684\u5fc5\u8981\uff0c // \u6b64\u65f6\u4e0d\u5fc5\u7406\u4f1a\u5176\u4ed6\u7c7b\u578b\u7684 program header let start_va: VirtAddr = (ph.virtual_addr() as usize).into(); let end_va: VirtAddr = ((ph.virtual_addr() + ph.mem_size()) as usize).into(); // \u8ba1\u7b97\u8fd9\u4e00\u533a\u57df\u5728\u5e94\u7528\u5730\u5740\u7a7a\u95f4\u4e2d\u7684\u4f4d\u7f6e let mut map_perm = MapPermission::U; let ph_flags = ph.flags(); // \u786e\u8ba4\u8fd9\u4e00\u533a\u57df\u8bbf\u95ee\u65b9\u5f0f\u7684\u9650\u5236\u5e76\u5c06\u5176\u8f6c\u6362\u4e3a MapPermission \u7c7b\u578b if ph_flags.is_read() { map_perm |= MapPermission::R; } if ph_flags.is_write() { map_perm |= MapPermission::W; } if ph_flags.is_execute() { map_perm |= MapPermission::X; } let map_area = MapArea::new( // \u521b\u5efa\u903b\u8f91\u6bb5 map_area start_va, end_va, MapType::Framed, map_perm, ); max_end_vpn = map_area.vpn_range.get_end(); memory_set.push( // push \u5230\u5e94\u7528\u5730\u5740\u7a7a\u95f4 map_area, Some(&elf.input[ph.offset() as usize..(ph.offset() + ph.file_size()) as usize]) ); // \u5728 push \u7684\u65f6\u5019\u6211\u4eec\u9700\u8981\u5b8c\u6210\u6570\u636e\u62f7\u8d1d\uff0c\u5f53\u524d program header \u6570\u636e\u88ab\u5b58\u653e\u7684\u4f4d\u7f6e\u53ef\u4ee5\u901a\u8fc7 ph.offset() \u548c ph.file_size() \u6765\u627e\u5230\u3002 // \u6ce8\u610f\u5f53\u5b58\u5728\u4e00\u90e8\u5206\u96f6\u521d\u59cb\u5316\u7684\u65f6\u5019\uff0c ph.file_size() \u5c06\u4f1a\u5c0f\u4e8e ph.mem_size() \uff0c // \u56e0\u4e3a\u8fd9\u4e9b\u96f6\u51fa\u4e8e\u7f29\u51cf\u53ef\u6267\u884c\u6587\u4ef6\u5927\u5c0f\u7684\u539f\u56e0\u4e0d\u5e94\u8be5\u5b9e\u9645\u51fa\u73b0\u5728 ELF \u6570\u636e\u4e2d } } // map user stack with U flags // \u5904\u7406\u7528\u6237\u6808\u3002\u6ce8\u610f\u5728\u524d\u9762\u52a0\u8f7d\u5404\u4e2a program header \u7684\u65f6\u5019\uff0c // \u6211\u4eec\u5c31\u5df2\u7ecf\u7ef4\u62a4\u4e86 max_end_vpn \u8bb0\u5f55\u76ee\u524d\u6d89\u53ca\u5230\u7684\u6700\u5927\u7684\u865a\u62df\u9875\u53f7\uff0c // \u53ea\u9700\u7d27\u63a5\u7740\u5728\u5b83\u4e0a\u9762\u518d\u653e\u7f6e\u4e00\u4e2a\u4fdd\u62a4\u9875\u9762\u548c\u7528\u6237\u6808\u5373\u53ef let max_end_va: VirtAddr = max_end_vpn.into(); let mut user_stack_bottom: usize = max_end_va.into(); // guard page user_stack_bottom += PAGE_SIZE; let user_stack_top = user_stack_bottom + USER_STACK_SIZE; memory_set.push(MapArea::new( user_stack_bottom.into(), user_stack_top.into(), MapType::Framed, MapPermission::R | MapPermission::W | MapPermission::U, ), None); // map TrapContext // \u5e94\u7528\u5730\u5740\u7a7a\u95f4\u4e2d\u6620\u5c04\u6b21\u9ad8\u9875\u9762\u6765\u5b58\u653e Trap \u4e0a\u4e0b\u6587 memory_set.push(MapArea::new( TRAP_CONTEXT.into(), TRAMPOLINE.into(), MapType::Framed, MapPermission::R | MapPermission::W, ), None); (memory_set, user_stack_top, elf.header.pt2.entry_point() as usize) // \u8fd4\u56de\u5e94\u7528\u5730\u5740\u7a7a\u95f4 memory_set \uff0c // \u4e5f\u540c\u65f6\u8fd4\u56de\u7528\u6237\u6808\u865a\u62df\u5730\u5740 user_stack_top \u4ee5\u53ca\u4ece\u89e3\u6790 ELF \u5f97\u5230\u7684\u8be5\u5e94\u7528\u5165\u53e3\u70b9\u5730\u5740\uff0c // \u5b83\u4eec\u5c06\u88ab\u6211\u4eec\u7528\u6765\u521b\u5efa\u5e94\u7528\u7684\u4efb\u52a1\u63a7\u5236\u5757 } pub fn activate(&self) { let satp = self.page_table.token(); unsafe { satp::write(satp); asm!(\"sfence.vma\"); } // \u6211\u4eec\u5c06\u8fd9\u4e2a\u503c\u5199\u5165\u5f53\u524d CPU \u7684 satp CSR \uff0c\u4ece\u8fd9\u4e00\u523b\u5f00\u59cb SV39 \u5206\u9875\u6a21\u5f0f\u5c31\u88ab\u542f\u7528\u4e86\uff0c // \u800c\u4e14 MMU \u4f1a\u4f7f\u7528\u5185\u6838\u5730\u5740\u7a7a\u95f4\u7684\u591a\u7ea7\u9875\u8868\u8fdb\u884c\u5730\u5740\u8f6c\u6362 } pub fn translate(&self, vpn: VirtPageNum) -> Option<PageTableEntry> { self.page_table.translate(vpn) } } // \u6211\u4eec\u4ee5\u903b\u8f91\u6bb5 MapArea \u4e3a\u5355\u4f4d\u63cf\u8ff0\u4e00\u6bb5\u8fde\u7eed\u5730\u5740\u7684\u865a\u62df\u5185\u5b58\u3002\u6240\u8c13\u903b\u8f91\u6bb5\uff0c // \u5c31\u662f\u6307\u5730\u5740\u533a\u95f4\u4e2d\u7684\u4e00\u6bb5\u5b9e\u9645\u53ef\u7528\uff08\u5373 MMU \u901a\u8fc7\u67e5\u591a\u7ea7\u9875\u8868\u53ef\u4ee5\u6b63\u786e\u5b8c\u6210\u5730\u5740\u8f6c\u6362\uff09\u7684\u5730\u5740\u8fde\u7eed\u7684\u865a\u62df\u5730\u5740\u533a\u95f4\uff0c // \u8be5\u533a\u95f4\u5185\u5305\u542b\u7684\u6240\u6709\u865a\u62df\u9875\u9762\u90fd\u4ee5\u4e00\u79cd\u76f8\u540c\u7684\u65b9\u5f0f\u6620\u5c04\u5230\u7269\u7406\u9875\u5e27\uff0c\u5177\u6709\u53ef\u8bfb/\u53ef\u5199/\u53ef\u6267\u884c\u7b49\u5c5e\u6027 pub struct MapArea { vpn_range: VPNRange, // \u5176\u4e2d VPNRange \u63cf\u8ff0\u4e00\u6bb5\u865a\u62df\u9875\u53f7\u7684\u8fde\u7eed\u533a\u95f4\uff0c\u8868\u793a\u8be5\u903b\u8f91\u6bb5\u5728\u5730\u5740\u533a\u95f4\u4e2d\u7684\u4f4d\u7f6e\u548c\u957f\u5ea6\u3002 // \u5b83\u662f\u4e00\u4e2a\u8fed\u4ee3\u5668\uff0c\u53ef\u4ee5\u4f7f\u7528 Rust \u7684\u8bed\u6cd5\u7cd6 for-loop \u8fdb\u884c\u8fed\u4ee3 data_frames: BTreeMap<VirtPageNum, FrameTracker>, map_type: MapType, map_perm: MapPermission, // MapPermission \u8868\u793a\u63a7\u5236\u8be5\u903b\u8f91\u6bb5\u7684\u8bbf\u95ee\u65b9\u5f0f\uff0c\u5b83\u662f\u9875\u8868\u9879\u6807\u5fd7\u4f4d PTEFlags \u7684\u4e00\u4e2a\u5b50\u96c6\uff0c // \u4ec5\u4fdd\u7559 U/R/W/X \u56db\u4e2a\u6807\u5fd7\u4f4d\uff0c\u56e0\u4e3a\u5176\u4ed6\u7684\u6807\u5fd7\u4f4d\u4ec5\u4e0e\u786c\u4ef6\u7684\u5730\u5740\u8f6c\u6362\u673a\u5236\u7ec6\u8282\u76f8\u5173\uff0c\u8fd9\u6837\u7684\u8bbe\u8ba1\u80fd\u907f\u514d\u5f15\u5165\u9519\u8bef\u7684\u6807\u5fd7\u4f4d } impl MapArea { // \u65b0\u5efa\u4e00\u4e2a\u903b\u8f91\u6bb5\u7ed3\u6784\u4f53\uff0c // \u6ce8\u610f\u4f20\u5165\u7684\u8d77\u59cb/\u7ec8\u6b62\u865a\u62df\u5730\u5740\u4f1a\u5206\u522b\u88ab\u4e0b\u53d6\u6574/\u4e0a\u53d6\u6574\u4e3a\u865a\u62df\u9875\u53f7\u5e76\u4f20\u5165\u8fed\u4ee3\u5668 vpn_range \u4e2d pub fn new( start_va: VirtAddr, end_va: VirtAddr, map_type: MapType, map_perm: MapPermission ) -> Self { let start_vpn: VirtPageNum = start_va.floor(); let end_vpn: VirtPageNum = end_va.ceil(); Self { vpn_range: VPNRange::new(start_vpn, end_vpn), data_frames: BTreeMap::new(), map_type, map_perm, } } // \u5bf9\u903b\u8f91\u6bb5\u4e2d\u7684\u5355\u4e2a\u865a\u62df\u9875\u9762\u8fdb\u884c\u6620\u5c04/\u89e3\u6620\u5c04\u7684\u65b9\u6cd5 // \u5728\u865a\u62df\u9875\u53f7 vpn \u5df2\u7ecf\u786e\u5b9a\u7684\u60c5\u51b5\u4e0b\uff0c\u5b83\u9700\u8981\u77e5\u9053\u8981\u5c06\u4e00\u4e2a\u600e\u4e48\u6837\u7684\u9875\u8868\u9879\u63d2\u5165\u591a\u7ea7\u9875\u8868\u3002 // \u9875\u8868\u9879\u7684\u6807\u5fd7\u4f4d\u6765\u6e90\u4e8e\u5f53\u524d\u903b\u8f91\u6bb5\u7684\u7c7b\u578b\u4e3a MapPermission \u7684\u7edf\u4e00\u914d\u7f6e\uff0c\u53ea\u9700\u5c06\u5176\u8f6c\u6362\u4e3a PTEFlags \uff1b // \u800c\u9875\u8868\u9879\u7684\u7269\u7406\u9875\u53f7\u5219\u53d6\u51b3\u4e8e\u5f53\u524d\u903b\u8f91\u6bb5\u6620\u5c04\u5230\u7269\u7406\u5185\u5b58\u7684\u65b9\u5f0f: // \u5f53\u4ee5\u6052\u7b49\u6620\u5c04 Identical \u65b9\u5f0f\u6620\u5c04\u7684\u65f6\u5019\uff0c\u7269\u7406\u9875\u53f7\u5c31\u7b49\u4e8e\u865a\u62df\u9875\u53f7\uff1b // \u5f53\u4ee5 Framed \u65b9\u5f0f\u6620\u5c04\u65f6\uff0c\u9700\u8981\u5206\u914d\u4e00\u4e2a\u7269\u7406\u9875\u5e27\u8ba9\u5f53\u524d\u7684\u865a\u62df\u9875\u9762\u53ef\u4ee5\u6620\u5c04\u8fc7\u53bb\uff0c // \u6b64\u65f6\u9875\u8868\u9879\u4e2d\u7684\u7269\u7406\u9875\u53f7\u81ea\u7136\u5c31\u662f \u8fd9\u4e2a\u88ab\u5206\u914d\u7684\u7269\u7406\u9875\u5e27\u7684\u7269\u7406\u9875\u53f7\u3002 // \u6b64\u65f6\u8fd8\u9700\u8981\u5c06\u8fd9\u4e2a\u7269\u7406\u9875\u5e27\u6302\u5728\u903b\u8f91\u6bb5\u7684 data_frames \u5b57\u6bb5\u4e0b\u3002 // \u5f53\u786e\u5b9a\u4e86\u9875\u8868\u9879\u7684\u6807\u5fd7\u4f4d\u548c\u7269\u7406\u9875\u53f7\u4e4b\u540e\uff0c\u5373\u53ef\u8c03\u7528\u591a\u7ea7\u9875\u8868 PageTable \u7684 map \u63a5\u53e3\u6765\u63d2\u5165\u952e\u503c\u5bf9 pub fn map_one(&mut self, page_table: &mut PageTable, vpn: VirtPageNum) { let ppn: PhysPageNum; match self.map_type { MapType::Identical => { ppn = PhysPageNum(vpn.0); } MapType::Framed => { let frame = frame_alloc().unwrap(); ppn = frame.ppn; self.data_frames.insert(vpn, frame); } } let pte_flags = PTEFlags::from_bits(self.map_perm.bits).unwrap(); page_table.map(vpn, ppn, pte_flags); } // \u57fa\u672c\u4e0a\u5c31\u662f\u8c03\u7528 PageTable \u7684 unmap \u63a5\u53e3\u5220\u9664\u4ee5\u4f20\u5165\u7684\u865a\u62df\u9875\u53f7\u4e3a\u952e\u7684\u952e\u503c\u5bf9\u5373\u53ef\u3002 // \u7136\u800c\uff0c\u5f53\u4ee5 Framed \u6620\u5c04\u7684\u65f6\u5019\uff0c\u4e0d\u8981\u5fd8\u8bb0\u540c\u65f6\u5c06\u865a\u62df\u9875\u9762\u88ab\u6620\u5c04\u5230\u7684\u7269\u7406\u9875\u5e27 FrameTracker \u4ece data_frames \u4e2d\u79fb\u9664\uff0c // \u8fd9\u6837\u8fd9\u4e2a\u7269\u7406\u9875\u5e27\u624d\u80fd\u7acb\u5373\u88ab\u56de\u6536\u4ee5\u5907\u540e\u7eed\u5206\u914d #[allow(unused)] pub fn unmap_one(&mut self, page_table: &mut PageTable, vpn: VirtPageNum) { match self.map_type { MapType::Framed => { self.data_frames.remove(&vpn); } _ => {} } page_table.unmap(vpn); } // \u53ef\u4ee5\u5c06\u5f53\u524d\u903b\u8f91\u6bb5\u5230\u7269\u7406\u5185\u5b58\u7684\u6620\u5c04\u4ece\u4f20\u5165\u7684\u8be5\u903b\u8f91\u6bb5\u6240\u5c5e\u7684\u5730\u5740\u7a7a\u95f4\u7684\u591a\u7ea7\u9875\u8868\u4e2d\u52a0\u5165\u6216\u5220\u9664\u3002 // \u53ef\u4ee5\u770b\u5230\u5b83\u4eec\u7684\u5b9e\u73b0\u662f\u904d\u5386\u903b\u8f91\u6bb5\u4e2d\u7684\u6240\u6709\u865a\u62df\u9875\u9762\uff0c // \u5e76\u4ee5\u6bcf\u4e2a\u865a\u62df\u9875\u9762\u4e3a\u5355\u4f4d\u4f9d\u6b21\u5728\u591a\u7ea7\u9875\u8868\u4e2d\u8fdb\u884c\u952e\u503c\u5bf9\u7684\u63d2\u5165\u6216\u5220\u9664\uff0c // \u5206\u522b\u5bf9\u5e94 MapArea \u7684 map_one \u548c unmap_one \u65b9\u6cd5 pub fn map(&mut self, page_table: &mut PageTable) { for vpn in self.vpn_range { self.map_one(page_table, vpn); } } #[allow(unused)] pub fn unmap(&mut self, page_table: &mut PageTable) { for vpn in self.vpn_range { self.unmap_one(page_table, vpn); } } /// data: start-aligned but maybe with shorter length /// assume that all frames were cleared before // \u5c06\u5207\u7247 data \u4e2d\u7684\u6570\u636e\u62f7\u8d1d\u5230\u5f53\u524d\u903b\u8f91\u6bb5\u5b9e\u9645\u88ab\u5185\u6838\u653e\u7f6e\u5728\u7684\u5404\u7269\u7406\u9875\u5e27\u4e0a\uff0c // \u4ece\u800c\u5728\u5730\u5740\u7a7a\u95f4\u4e2d\u901a\u8fc7\u8be5\u903b\u8f91\u6bb5\u5c31\u80fd\u8bbf\u95ee\u8fd9\u4e9b\u6570\u636e\u3002\u8c03\u7528\u5b83\u7684\u65f6\u5019\u9700\u8981\u6ee1\u8db3\uff1a // \u5207\u7247 data \u4e2d\u7684\u6570\u636e\u5927\u5c0f\u4e0d\u8d85\u8fc7\u5f53\u524d\u903b\u8f91\u6bb5\u7684\u603b\u5927\u5c0f\uff0c\u4e14\u5207\u7247\u4e2d\u7684\u6570\u636e\u4f1a\u88ab\u5bf9\u9f50\u5230\u903b\u8f91\u6bb5\u7684\u5f00\u5934\uff0c // \u7136\u540e\u9010\u9875\u62f7\u8d1d\u5230\u5b9e\u9645\u7684\u7269\u7406\u9875\u5e27 pub fn copy_data(&mut self, page_table: &mut PageTable, data: &[u8]) { assert_eq!(self.map_type, MapType::Framed); let mut start: usize = 0; let mut current_vpn = self.vpn_range.get_start(); let len = data.len(); loop { let src = &data[start..len.min(start + PAGE_SIZE)]; let dst = &mut page_table .translate(current_vpn) .unwrap() .ppn() .get_bytes_array()[..src.len()]; dst.copy_from_slice(src); start += PAGE_SIZE; if start >= len { break; } current_vpn.step(); } // \u5faa\u73af\u4f1a\u904d\u5386\u6bcf\u4e00\u4e2a\u9700\u8981\u62f7\u8d1d\u6570\u636e\u7684\u865a\u62df\u9875\u9762\uff0c\u5728\u6570\u636e\u62f7\u8d1d\u5b8c\u6210\u540e\u4f1a\u901a\u8fc7\u8c03\u7528 step \u65b9\u6cd5 } } // MapType \u63cf\u8ff0\u8be5\u903b\u8f91\u6bb5\u5185\u7684\u6240\u6709\u865a\u62df\u9875\u9762\u6620\u5c04\u5230\u7269\u7406\u9875\u5e27\u7684\u540c\u4e00\u79cd\u65b9\u5f0f\uff0c\u5b83\u662f\u4e00\u4e2a\u679a\u4e3e\u7c7b\u578b\uff0c // \u5728\u5185\u6838\u5f53\u524d\u7684\u5b9e\u73b0\u4e2d\u652f\u6301\u4e24\u79cd\u65b9\u5f0f #[derive(Copy, Clone, PartialEq, Debug)] pub enum MapType { Identical, // Identical \u8868\u793a\u6052\u7b49\u6620\u5c04\u65b9\u5f0f // \u6052\u7b49\u6620\u5c04\u65b9\u5f0f\u4e3b\u8981\u662f\u7528\u5728\u542f\u7528\u591a\u7ea7\u9875\u8868\u4e4b\u540e\uff0c // \u5185\u6838\u4ecd\u80fd\u591f\u5728\u865a\u5b58\u5730\u5740\u7a7a\u95f4\u4e2d\u8bbf\u95ee\u4e00\u4e2a\u7279\u5b9a\u7684\u7269\u7406\u5730\u5740\u6307\u5411\u7684\u7269\u7406\u5185\u5b58 Framed, // Framed \u5219\u8868\u793a\u5bf9\u4e8e\u6bcf\u4e2a\u865a\u62df\u9875\u9762\u90fd\u6709\u4e00\u4e2a\u65b0\u5206\u914d\u7684\u7269\u7406\u9875\u5e27\u4e0e\u4e4b\u5bf9\u5e94\uff0c // \u865a\u5730\u5740\u4e0e\u7269\u7406\u5730\u5740\u7684\u6620\u5c04\u5173\u7cfb\u662f\u76f8\u5bf9\u968f\u673a\u7684 // \u5f53\u903b\u8f91\u6bb5\u91c7\u7528 MapType::Framed \u65b9\u5f0f\u6620\u5c04\u5230\u7269\u7406\u5185\u5b58\u7684\u65f6\u5019\uff0c // data_frames \u662f\u4e00\u4e2a\u4fdd\u5b58\u4e86\u8be5\u903b\u8f91\u6bb5\u5185\u7684\u6bcf\u4e2a\u865a\u62df\u9875\u9762\u548c\u5b83\u88ab\u6620\u5c04\u5230\u7684\u7269\u7406\u9875\u5e27 FrameTracker \u7684\u4e00\u4e2a\u952e\u503c\u5bf9\u5bb9\u5668 BTreeMap \u4e2d\uff0c // \u8fd9\u4e9b\u7269\u7406\u9875\u5e27\u88ab\u7528\u6765\u5b58\u653e\u5b9e\u9645\u5185\u5b58\u6570\u636e\u800c\u4e0d\u662f\u4f5c\u4e3a\u591a\u7ea7\u9875\u8868\u4e2d\u7684\u4e2d\u95f4\u8282\u70b9\u3002\u548c\u4e4b\u524d\u7684 PageTable \u4e00\u6837\uff0c // \u8fd9\u4e5f\u7528\u5230\u4e86 RAII \u7684\u601d\u60f3\uff0c\u5c06\u8fd9\u4e9b\u7269\u7406\u9875\u5e27\u7684\u751f\u547d\u5468\u671f\u7ed1\u5b9a\u5230\u5b83\u6240\u5728\u7684\u903b\u8f91\u6bb5 MapArea \u4e0b\uff0c // \u5f53\u903b\u8f91\u6bb5\u88ab\u56de\u6536\u4e4b\u540e\u8fd9\u4e9b\u4e4b\u524d\u5206\u914d\u7684\u7269\u7406\u9875\u5e27\u4e5f\u4f1a\u81ea\u52a8\u5730\u540c\u65f6\u88ab\u56de\u6536 } bitflags! { pub struct MapPermission: u8 { const R = 1 << 1; const W = 1 << 2; const X = 1 << 3; const U = 1 << 4; } // \u4ec5\u4fdd\u7559 U/R/W/X \u56db\u4e2a\u6807\u5fd7\u4f4d\uff0c\u56e0\u4e3a\u5176\u4ed6\u7684\u6807\u5fd7\u4f4d\u4ec5\u4e0e\u786c\u4ef6\u7684\u5730\u5740\u8f6c\u6362\u673a\u5236\u7ec6\u8282\u76f8\u5173\uff0c // \u8fd9\u6837\u7684\u8bbe\u8ba1\u80fd\u907f\u514d\u5f15\u5165\u9519\u8bef\u7684\u6807\u5fd7\u4f4d } // \u68c0\u67e5\u5185\u6838\u5730\u5740\u7a7a\u95f4\u7684\u591a\u7ea7\u9875\u8868\u662f\u5426\u88ab\u6b63\u786e\u8bbe\u7f6e #[allow(unused)] pub fn remap_test() { let mut kernel_space = KERNEL_SPACE.exclusive_access(); let mid_text: VirtAddr = ((stext as usize + etext as usize) / 2).into(); let mid_rodata: VirtAddr = ((srodata as usize + erodata as usize) / 2).into(); let mid_data: VirtAddr = ((sdata as usize + edata as usize) / 2).into(); assert_eq!( kernel_space.page_table.translate(mid_text.floor()).unwrap().writable(), false ); assert_eq!( kernel_space.page_table.translate(mid_rodata.floor()).unwrap().writable(), false, ); assert_eq!( kernel_space.page_table.translate(mid_data.floor()).unwrap().executable(), false, ); println!(\"remap_test passed!\"); } os/src/mm/mod.rs mod heap_allocator; mod address; mod frame_allocator; mod page_table; mod memory_set; use page_table::{PageTable, PTEFlags}; use address::{VPNRange, StepByOne}; pub use address::{PhysAddr, VirtAddr, PhysPageNum, VirtPageNum}; pub use frame_allocator::{FrameTracker, frame_alloc}; pub use page_table::{PageTableEntry, translated_byte_buffer}; pub use memory_set::{MemorySet, KERNEL_SPACE, MapPermission}; pub use memory_set::remap_test; pub fn init() { heap_allocator::init_heap(); // \u6211\u4eec\u6700\u5148\u8fdb\u884c\u4e86\u5168\u5c40\u52a8\u6001\u5185\u5b58\u5206\u914d\u5668\u7684\u521d\u59cb\u5316 // \u56e0\u4e3a\u63a5\u4e0b\u6765\u9a6c\u4e0a\u5c31\u8981\u7528\u5230 Rust \u7684\u5806\u6570\u636e\u7ed3\u6784 frame_allocator::init_frame_allocator(); // \u63a5\u4e0b\u6765\u6211\u4eec\u521d\u59cb\u5316\u7269\u7406\u9875\u5e27\u7ba1\u7406\u5668\uff08\u5185\u542b\u5806\u6570\u636e\u7ed3\u6784 Vec<T> \uff09\u4f7f\u80fd\u53ef\u7528\u7269\u7406\u9875\u5e27\u7684\u5206\u914d\u548c\u56de\u6536\u80fd\u529b KERNEL_SPACE.exclusive_access().activate(); // \u6700\u540e\u6211\u4eec\u521b\u5efa\u5185\u6838\u5730\u5740\u7a7a\u95f4\u5e76\u8ba9 CPU \u5f00\u542f\u5206\u9875\u6a21\u5f0f\uff0c MMU \u5728\u5730\u5740\u8f6c\u6362\u7684\u65f6\u5019\u4f7f\u7528\u5185\u6838\u7684\u591a\u7ea7\u9875\u8868 } os/src/mm/page_table.rs // \u9875\u8868\u4e2d\u7684\u9875\u8868\u9879\u7684\u7d22\u5f15\u5176\u5b9e\u662f\u865a\u62df\u5730\u5740\u4e2d\u7684\u865a\u62df\u9875\u53f7\uff0c\u9875\u8868\u9879\u7684\u91cd\u8981\u5185\u5bb9\u662f\u7269\u7406\u5730\u5740\u7684\u7269\u7406\u9875\u5e27\u53f7\u3002 // \u4e3a\u4e86\u80fd\u591f\u7075\u6d3b\u5730\u5728\u865a\u62df\u5730\u5740\u3001\u7269\u7406\u5730\u5740\u3001\u865a\u62df\u9875\u53f7\u3001\u7269\u7406\u9875\u53f7\u4e4b\u95f4\u8fdb\u884c\u5404\u79cd\u8f6c\u6362 // \u67e5\u9875\u8868\u4ee5\u8bbf\u95ee\u4e0d\u540c\u5730\u5740\u7a7a\u95f4\u7684\u6570\u636e \u3002\u5728\u5185\u6838\u5730\u5740\u7a7a\u95f4\u4e2d\u6267\u884c\u7684\u5185\u6838\u4ee3\u7801\u5e38\u5e38\u9700\u8981\u8bfb\u5199\u5e94\u7528\u7684\u5730\u5740\u7a7a\u95f4\u4e2d\u7684\u6570\u636e\uff0c // \u8fd9\u65e0\u6cd5\u7b80\u5355\u7684\u901a\u8fc7\u4e00\u6b21\u8bbf\u5b58\u6765\u89e3\u51b3\uff0c\u800c\u662f\u9700\u8981\u624b\u52a8\u67e5\u7528\u6237\u6001\u5e94\u7528\u7684\u5730\u5740\u7a7a\u95f4\u7684\u9875\u8868\uff0c // \u77e5\u9053\u7528\u6237\u6001\u5e94\u7528\u7684\u865a\u5730\u5740\u5bf9\u5e94\u7684\u7269\u7406\u5730\u5740\u540e\uff0c\u8f6c\u6362\u6210\u5bf9\u5e94\u7684\u5185\u6838\u6001\u7684\u865a\u5730\u5740\uff0c\u624d\u80fd\u8bbf\u95ee\u5e94\u7528\u5730\u5740\u7a7a\u95f4\u4e2d\u7684\u6570\u636e\u3002 // \u5982\u679c\u8bbf\u95ee\u5e94\u7528\u5730\u5740\u7a7a\u95f4\u4e2d\u7684\u6570\u636e\u8de8\u4e86\u591a\u4e2a\u9875\uff0c\u8fd8\u9700\u8981\u6ce8\u610f\u5904\u7406\u5730\u5740\u7684\u8fb9\u754c\u6761\u4ef6 use super::{frame_alloc, PhysPageNum, FrameTracker, VirtPageNum, VirtAddr, StepByOne}; use alloc::vec::Vec; use alloc::vec; use bitflags::*; // bitflags \u662f\u4e00\u4e2a Rust \u4e2d\u5e38\u7528\u6765\u6bd4\u7279\u6807\u5fd7\u4f4d\u7684 crate \u3002\u5b83\u63d0\u4f9b\u4e86\u4e00\u4e2a bitflags! \u5b8f\uff0c // \u5982\u4e0a\u9762\u7684\u4ee3\u7801\u6bb5\u6240\u5c55\u793a\u7684\u90a3\u6837\uff0c\u53ef\u4ee5\u5c06\u4e00\u4e2a u8 \u5c01\u88c5\u6210\u4e00\u4e2a\u6807\u5fd7\u4f4d\u7684\u96c6\u5408\u7c7b\u578b\uff0c\u652f\u6301\u4e00\u4e9b\u5e38\u89c1\u7684\u96c6\u5408\u8fd0\u7b97 bitflags! { pub struct PTEFlags: u8 { const V = 1 << 0; const R = 1 << 1; const W = 1 << 2; const X = 1 << 3; const U = 1 << 4; const G = 1 << 5; const A = 1 << 6; const D = 1 << 7; } } // \u5b9e\u73b0\u9875\u8868\u9879 PageTableEntry // 64\u4f4d // |Reserved PPN[2] PPN[1] PPN[0] RSW D A G U X W R V| #[derive(Copy, Clone)] // \u8ba9\u7f16\u8bd1\u5668\u81ea\u52a8\u4e3a PageTableEntry \u5b9e\u73b0 Copy/Clone Trait\uff0c\u6765\u8ba9\u8fd9\u4e2a\u7c7b\u578b\u4ee5\u503c\u8bed\u4e49\u8d4b\u503c/\u4f20\u53c2\u7684\u65f6\u5019\u4e0d\u4f1a\u53d1\u751f\u6240\u6709\u6743\u8f6c\u79fb\uff0c // \u800c\u662f\u62f7\u8d1d\u4e00\u4efd\u65b0\u7684\u526f\u672c\u3002\u4ece\u8fd9\u4e00\u70b9\u6765\u8bf4 PageTableEntry \u5c31\u548c usize \u4e00\u6837\uff0c // \u56e0\u4e3a\u5b83\u4e5f\u53ea\u662f\u540e\u8005\u7684\u4e00\u5c42\u7b80\u5355\u5305\u88c5\uff0c\u5e76\u89e3\u91ca\u4e86 usize \u5404\u4e2a\u6bd4\u7279\u6bb5\u7684\u542b\u4e49 #[repr(C)] // \u9875\u8868\u9879 63-54 (Reserved) 53-10 (44\u4f4d\u7269\u7406\u9875\u53f7) 9-8 (RSW) 7-0 (8\u4f4d\u6807\u5fd7\u4f4d) pub struct PageTableEntry { pub bits: usize, } impl PageTableEntry { pub fn new(ppn: PhysPageNum, flags: PTEFlags) -> Self { PageTableEntry { bits: ppn.0 << 10 | flags.bits as usize, } } // \u6211\u4eec\u53ef\u4ee5\u4ece\u4e00\u4e2a\u7269\u7406\u9875\u53f7 PhysPageNum \u548c\u4e00\u4e2a\u9875\u8868\u9879\u6807\u5fd7\u4f4d PTEFlags \u751f\u6210\u4e00\u4e2a\u9875\u8868\u9879 PageTableEntry \u5b9e\u4f8b pub fn empty() -> Self { PageTableEntry { bits: 0, } } // \u6211\u4eec\u4e5f\u53ef\u4ee5\u901a\u8fc7 empty \u65b9\u6cd5\u751f\u6210\u4e00\u4e2a\u5168\u96f6\u7684\u9875\u8868\u9879\uff0c\u6ce8\u610f\u8fd9\u9690\u542b\u7740\u8be5\u9875\u8868\u9879\u7684 V \u6807\u5fd7\u4f4d\u4e3a 0 \uff0c // \u56e0\u6b64\u5b83\u662f\u4e0d\u5408\u6cd5\u7684 pub fn ppn(&self) -> PhysPageNum { (self.bits >> 10 & ((1usize << 44) - 1)).into() // \u548c 44 \u4e2a 1 \u76f8\u4e0e\uff0c\u76f8\u5f53\u4e8e\u53bb\u6389reserved \u90e8\u5206 } // \u4ece\u4e00\u4e2a\u9875\u8868\u9879\u5c06 ppn \u53d6\u51fa pub fn flags(&self) -> PTEFlags { PTEFlags::from_bits(self.bits as u8).unwrap() } // \u4ece\u4e00\u4e2a\u9875\u8868\u9879\u5c06 flags 8\u4e2a\u6807\u5fd7\u4f4d\u53d6\u51fa pub fn is_valid(&self) -> bool { (self.flags() & PTEFlags::V) != PTEFlags::empty() } pub fn readable(&self) -> bool { (self.flags() & PTEFlags::R) != PTEFlags::empty() } pub fn writable(&self) -> bool { (self.flags() & PTEFlags::W) != PTEFlags::empty() } pub fn executable(&self) -> bool { (self.flags() & PTEFlags::X) != PTEFlags::empty() } // \u4e00\u4e9b\u8f85\u52a9\u51fd\u6570(Helper Function)\uff0c\u53ef\u4ee5\u5feb\u901f\u5224\u65ad\u4e00\u4e2a\u9875\u8868\u9879\u7684 V/R/W/X \u6807\u5fd7\u4f4d\u662f\u5426\u4e3a 1 } // \u9875\u8868 pub struct PageTable { root_ppn: PhysPageNum, frames: Vec<FrameTracker>, // \u6bcf\u4e2a\u5e94\u7528\u7684\u5730\u5740\u7a7a\u95f4\u90fd\u5bf9\u5e94\u4e00\u4e2a\u4e0d\u540c\u7684\u591a\u7ea7\u9875\u8868\uff0c // \u8fd9\u4e5f\u5c31\u610f\u5473\u8fd9\u4e0d\u540c\u9875\u8868\u7684\u8d77\u59cb\u5730\u5740\uff08\u5373\u9875\u8868\u6839\u8282\u70b9\u7684\u5730\u5740\uff09\u662f\u4e0d\u4e00\u6837\u7684\u3002 // \u56e0\u6b64 PageTable``\u8981\u4fdd\u5b58\u5b83\u6839\u8282\u70b9\u7684\u7269\u7406\u9875\u53f7 ``root_ppn \u4f5c\u4e3a\u9875\u8868\u552f\u4e00\u7684\u533a\u5206\u6807\u5fd7\u3002 // \u6b64\u5916\uff0c\u5411\u91cf frames \u4ee5 FrameTracker \u7684\u5f62\u5f0f\u4fdd\u5b58\u4e86\u9875\u8868\u6240\u6709\u7684\u8282\u70b9\uff08\u5305\u62ec\u6839\u8282\u70b9\uff09\u6240\u5728\u7684\u7269\u7406\u9875\u5e27\u3002 // \u8fd9\u4e0e\u7269\u7406\u9875\u5e27\u7ba1\u7406\u6a21\u5757\u7684\u6d4b\u8bd5\u7a0b\u5e8f\u662f\u4e00\u4e2a\u601d\u8def\uff0c\u5373\u5c06\u8fd9\u4e9b FrameTracker \u7684\u751f\u547d\u5468\u671f\u8fdb\u4e00\u6b65\u7ed1\u5b9a\u5230 PageTable \u4e0b\u9762\u3002 // \u5f53 PageTable \u751f\u547d\u5468\u671f\u7ed3\u675f\u540e\uff0c\u5411\u91cf frames \u91cc\u9762\u7684\u90a3\u4e9b FrameTracker \u4e5f\u4f1a\u88ab\u56de\u6536\uff0c // \u4e5f\u5c31\u610f\u5473\u7740\u5b58\u653e\u591a\u7ea7\u9875\u8868\u8282\u70b9\u7684\u90a3\u4e9b\u7269\u7406\u9875\u5e27\u88ab\u56de\u6536\u4e86 } /// Assume that it won't oom when creating/mapping. impl PageTable { // \u5f53\u6211\u4eec\u901a\u8fc7 new \u65b9\u6cd5\u65b0\u5efa\u4e00\u4e2a PageTable \u7684\u65f6\u5019\uff0c\u5b83\u53ea\u9700\u6709\u4e00\u4e2a\u6839\u8282\u70b9\u3002 // \u4e3a\u6b64\u6211\u4eec\u9700\u8981\u5206\u914d\u4e00\u4e2a\u7269\u7406\u9875\u5e27 FrameTracker \u5e76\u6302\u5728\u5411\u91cf frames \u4e0b\uff0c\u7136\u540e\u66f4\u65b0\u6839\u8282\u70b9\u7684\u7269\u7406\u9875\u53f7 root_ppn pub fn new() -> Self { let frame = frame_alloc().unwrap(); PageTable { root_ppn: frame.ppn, frames: vec![frame], } } /// Temporarily used to get arguments from user space. pub fn from_token(satp: usize) -> Self { Self { root_ppn: PhysPageNum::from(satp & ((1usize << 44) - 1)), frames: Vec::new(), } } // // from_token \u53ef\u4ee5\u4e34\u65f6\u521b\u5efa\u4e00\u4e2a\u4e13\u7528\u6765\u624b\u52a8\u67e5\u9875\u8868\u7684 PageTable \uff0c // \u5b83\u4ec5\u6709\u4e00\u4e2a\u4ece\u4f20\u5165\u7684 satp token \u4e2d\u5f97\u5230\u7684\u591a\u7ea7\u9875\u8868\u6839\u8282\u70b9\u7684\u7269\u7406\u9875\u53f7\uff0c\u5b83\u7684 frames \u5b57\u6bb5\u4e3a\u7a7a\uff0c // \u4e5f\u5373\u4e0d\u5b9e\u9645\u63a7\u5236\u4efb\u4f55\u8d44\u6e90 // \u5f53\u9047\u5230\u9700\u8981\u67e5\u4e00\u4e2a\u7279\u5b9a\u9875\u8868\uff08\u975e\u5f53\u524d\u6b63\u5904\u5728\u7684\u5730\u5740\u7a7a\u95f4\u7684\u9875\u8868\u65f6\uff09\uff0c // \u4fbf\u53ef\u5148\u901a\u8fc7 PageTable::from_token \u65b0\u5efa\u4e00\u4e2a\u9875\u8868\uff0c\u518d\u8c03\u7528\u5b83\u7684 translate \u65b9\u6cd5\u67e5\u9875\u8868 // \u5728\u591a\u7ea7\u9875\u8868\u627e\u5230\u4e00\u4e2a\u865a\u62df\u9875\u53f7\u5bf9\u5e94\u7684\u9875\u8868\u9879\u7684\u53ef\u53d8\u5f15\u7528\u3002 // \u5982\u679c\u5728\u904d\u5386\u7684\u8fc7\u7a0b\u4e2d\u53d1\u73b0\u6709\u8282\u70b9\u5c1a\u672a\u521b\u5efa\u5219\u4f1a\u65b0\u5efa\u4e00\u4e2a\u8282\u70b9 fn find_pte_create(&mut self, vpn: VirtPageNum) -> Option<&mut PageTableEntry> { let idxs = vpn.indexes(); // \u53d6\u51fa\u4e09\u7ea7\u7d22\u5f15 let mut ppn = self.root_ppn; let mut result: Option<&mut PageTableEntry> = None; for i in 0..3 { let pte = &mut ppn.get_pte_array()[idxs[i]]; // \u5206\u522b\u53d6\u51fa \u7b2c\u4e09\u7ea7\u7d22\u5f15 \u7b2c\u4e8c\u7ea7\u7d22\u5f15 \u7b2c\u4e00\u7ea7\u7d22\u5f15(\u5373\u7269\u7406\u9875\u53f7) if i == 2 { // \u627e\u5230 \u7269\u7406\u9875\u53f7 result = Some(pte); // \u8fd4\u56de\u7269\u7406\u9875\u53f7 break; } if !pte.is_valid() { let frame = frame_alloc().unwrap(); // create \u521b\u5efa\u4e00\u4e2a\u7269\u7406\u9875\u5e27\uff0c\u8fd4\u56de\u4ed6\u7684\u7269\u7406\u9875\u53f7 *pte = PageTableEntry::new(frame.ppn, PTEFlags::V); // \u751f\u6210\u8fd9\u4e2a\u7269\u7406\u9875\u53f7\u5bf9\u5e94\u7684\u7269\u7406\u9875\u8868\u9879 self.frames.push(frame); // \u5c06\u8fd9\u4e2a\u7269\u7406\u9875\u5e27\u5b58\u653e\u5728 \u5168\u5c40\u7ba1\u7406\u5668\u7684 Vector\u4e2d } ppn = pte.ppn(); } // \u53d8\u91cf ppn \u8868\u793a\u5f53\u524d\u8282\u70b9\u7684\u7269\u7406\u9875\u53f7\uff0c\u6700\u5f00\u59cb\u6307\u5411\u591a\u7ea7\u9875\u8868\u7684\u6839\u8282\u70b9\u3002 // \u968f\u540e\u6bcf\u6b21\u5faa\u73af\u901a\u8fc7 get_pte_array \u5c06\u53d6\u51fa\u5f53\u524d\u8282\u70b9\u7684\u9875\u8868\u9879\u6570\u7ec4\uff0c // \u5e76\u6839\u636e\u5f53\u524d\u7ea7\u9875\u7d22\u5f15\u627e\u5230\u5bf9\u5e94\u7684\u9875\u8868\u9879\u3002\u5982\u679c\u5f53\u524d\u8282\u70b9\u662f\u4e00\u4e2a\u53f6\u8282\u70b9\uff0c // \u90a3\u4e48\u76f4\u63a5\u8fd4\u56de\u8fd9\u4e2a\u9875\u8868\u9879\u7684\u53ef\u53d8\u5f15\u7528\uff1b\u5426\u5219\u5c1d\u8bd5\u5411\u4e0b\u8d70\u3002\u8d70\u4e0d\u4e0b\u53bb\u7684\u8bdd\u5c31\u65b0\u5efa\u4e00\u4e2a\u8282\u70b9\uff0c // \u66f4\u65b0\u4f5c\u4e3a\u4e0b\u7ea7\u8282\u70b9\u6307\u9488\u7684\u9875\u8868\u9879\uff0c\u5e76\u5c06\u65b0\u5206\u914d\u7684\u7269\u7406\u9875\u5e27\u79fb\u52a8\u5230\u5411\u91cf frames \u4e2d\u65b9\u4fbf\u540e\u7eed\u7684\u81ea\u52a8\u56de\u6536\u3002 // \u6ce8\u610f\u5728\u66f4\u65b0\u9875\u8868\u9879\u7684\u65f6\u5019\uff0c\u4e0d\u4ec5\u8981\u66f4\u65b0\u7269\u7406\u9875\u53f7\uff0c\u8fd8\u8981\u5c06\u6807\u5fd7\u4f4d V \u7f6e 1\uff0c // \u4e0d\u7136\u786c\u4ef6\u5728\u67e5\u591a\u7ea7\u9875\u8868\u7684\u65f6\u5019\uff0c\u4f1a\u8ba4\u4e3a\u8fd9\u4e2a\u9875\u8868\u9879\u4e0d\u5408\u6cd5\uff0c\u4ece\u800c\u89e6\u53d1 Page Fault \u800c\u4e0d\u80fd\u5411\u4e0b\u8d70 result } fn find_pte(&self, vpn: VirtPageNum) -> Option<&PageTableEntry> { let idxs = vpn.indexes(); let mut ppn = self.root_ppn; let mut result: Option<&PageTableEntry> = None; for i in 0..3 { let pte = &ppn.get_pte_array()[idxs[i]]; if i == 2 { result = Some(pte); break; } if !pte.is_valid() { return None; } ppn = pte.ppn(); } // PageTable::find_pte \u4e0e find_pte_create \u7684\u4e0d\u540c\u5728\u4e8e\u5f53\u627e\u4e0d\u5230\u5408\u6cd5\u53f6\u5b50\u8282\u70b9\u7684\u65f6\u5019\u4e0d\u4f1a\u65b0\u5efa\u53f6\u5b50\u8282\u70b9\u800c\u662f\u76f4\u63a5\u8fd4\u56de None \u5373\u67e5\u627e\u5931\u8d25\u3002 // \u56e0\u6b64\uff0c\u5b83\u4e0d\u4f1a\u5c1d\u8bd5\u5bf9\u9875\u8868\u672c\u8eab\u8fdb\u884c\u4fee\u6539\uff0c\u4f46\u662f\u6ce8\u610f\u5b83\u8fd4\u56de\u7684\u53c2\u6570\u7c7b\u578b\u662f\u9875\u8868\u9879\u7684\u53ef\u53d8\u5f15\u7528\uff0c // \u4e5f\u5373\u5b83\u5141\u8bb8\u6211\u4eec\u4fee\u6539\u9875\u8868\u9879\u3002\u4ece find_pte \u7684\u5b9e\u73b0\u8fd8\u53ef\u4ee5\u770b\u51fa\uff0c\u5373\u4f7f\u627e\u5230\u7684\u9875\u8868\u9879\u4e0d\u5408\u6cd5\uff0c // \u8fd8\u662f\u4f1a\u5c06\u5176\u8fd4\u56de\u56de\u53bb\u800c\u4e0d\u662f\u8fd4\u56de None \u3002\u8fd9\u8bf4\u660e\u5728\u76ee\u524d\u7684\u5b9e\u73b0\u4e2d\uff0c\u9875\u8868\u548c\u9875\u8868\u9879\u662f\u76f8\u5bf9\u89e3\u8026\u5408\u7684 result } // \u591a\u7ea7\u9875\u8868\u5e76\u4e0d\u662f\u88ab\u521b\u5efa\u51fa\u6765\u4e4b\u540e\u5c31\u4e0d\u518d\u53d8\u5316\u7684\uff0c // \u4e3a\u4e86 MMU \u80fd\u591f\u901a\u8fc7\u5730\u5740\u8f6c\u6362\u6b63\u786e\u627e\u5230\u5e94\u7528\u5730\u5740\u7a7a\u95f4\u4e2d\u7684\u6570\u636e\u5b9e\u9645\u88ab\u5185\u6838\u653e\u5728\u5185\u5b58\u4e2d\u4f4d\u7f6e\uff0c // \u64cd\u4f5c\u7cfb\u7edf\u9700\u8981\u52a8\u6001\u7ef4\u62a4\u4e00\u4e2a\u865a\u62df\u9875\u53f7\u5230\u9875\u8868\u9879\u7684\u6620\u5c04\uff0c\u652f\u6301\u63d2\u5165/\u5220\u9664\u952e\u503c\u5bf9 // \u63a5\u4e0b\u6765\u4ecb\u7ecd\u5efa\u7acb\u548c\u62c6\u9664\u865a\u5b9e\u5730\u5740\u6620\u5c04\u5173\u7cfb\u7684 map \u548c unmap \u65b9\u6cd5\u662f\u5982\u4f55\u5b9e\u73b0\u7684\u3002 // \u5b83\u4eec\u90fd\u4f9d\u8d56\u4e8e\u4e00\u4e2a\u5f88\u91cd\u8981\u7684\u8fc7\u7a0b\uff0c\u5373\u5728\u591a\u7ea7\u9875\u8868\u4e2d\u627e\u5230\u4e00\u4e2a\u865a\u62df\u5730\u5740\u5bf9\u5e94\u7684\u9875\u8868\u9879\u3002\u627e\u5230\u4e4b\u540e\uff0c // \u53ea\u8981\u4fee\u6539\u9875\u8868\u9879\u7684\u5185\u5bb9\u5373\u53ef\u5b8c\u6210\u952e\u503c\u5bf9\u7684\u63d2\u5165\u548c\u5220\u9664\u3002\u5728\u5bfb\u627e\u9875\u8868\u9879\u7684\u65f6\u5019\uff0c // \u53ef\u80fd\u51fa\u73b0\u9875\u8868\u7684\u4e2d\u95f4\u7ea7\u8282\u70b9\u8fd8\u672a\u88ab\u521b\u5efa\u7684\u60c5\u51b5\uff0c\u8fd9\u4e2a\u65f6\u5019\u6211\u4eec\u9700\u8981\u624b\u52a8\u5206\u914d\u4e00\u4e2a\u7269\u7406\u9875\u5e27\u6765\u5b58\u653e\u8fd9\u4e2a\u8282\u70b9\uff0c // \u5e76\u5c06\u8fd9\u4e2a\u8282\u70b9\u63a5\u5165\u5230\u5f53\u524d\u7684\u591a\u7ea7\u9875\u8868\u7684\u67d0\u7ea7\u4e2d // \u53ea\u9700\u6839\u636e\u865a\u62df\u9875\u53f7\u627e\u5230\u9875\u8868\u9879\uff0c\u7136\u540e\u4fee\u6539\u6216\u8005\u76f4\u63a5\u6e05\u7a7a\u5176\u5185\u5bb9\u5373\u53ef #[allow(unused)] pub fn map(&mut self, vpn: VirtPageNum, ppn: PhysPageNum, flags: PTEFlags) { let pte = self.find_pte_create(vpn).unwrap(); // \u67e5\u627e\u4e00\u4e2a\u865a\u62df\u9875\u53f7 assert!(!pte.is_valid(), \"vpn {:?} is mapped before mapping\", vpn); *pte = PageTableEntry::new(ppn, flags | PTEFlags::V); // \u521b\u5efa\u4e00\u4e2a\u9875\u8868\u9879\uff0c \u5b58\u653e\u8fd9\u4e2a\u865a\u62df\u9875\u53f7 \u6240\u6620\u5c04\u7684 \u7269\u7406\u9875\u53f7 } // \u901a\u8fc7 map \u65b9\u6cd5\u6765\u5728\u591a\u7ea7\u9875\u8868\u4e2d\u63d2\u5165\u4e00\u4e2a\u952e\u503c\u5bf9\uff0c // \u6ce8\u610f\u8fd9\u91cc\u5c06\u7269\u7406\u9875\u53f7 ppn \u548c\u9875\u8868\u9879\u6807\u5fd7\u4f4d flags \u4f5c\u4e3a\u4e0d\u540c\u7684\u53c2\u6570\u4f20\u5165 #[allow(unused)] pub fn unmap(&mut self, vpn: VirtPageNum) { let pte = self.find_pte_create(vpn).unwrap(); // \u521b\u5efa\u4e00\u4e2a\u865a\u62df\u9875\u8868\u9879 assert!(pte.is_valid(), \"vpn {:?} is invalid before unmapping\", vpn); *pte = PageTableEntry::empty(); // \u5c06\u9875\u8868\u9879\u7684\u6240\u6709\u4f4d \u7f6e0 } // \u901a\u8fc7 unmap \u65b9\u6cd5\u6765\u5220\u9664\u4e00\u4e2a\u952e\u503c\u5bf9\uff0c\u5728\u8c03\u7528\u65f6\u4ec5\u9700\u7ed9\u51fa\u4f5c\u4e3a\u7d22\u5f15\u7684\u865a\u62df\u9875\u53f7\u5373\u53ef pub fn translate(&self, vpn: VirtPageNum) -> Option<PageTableEntry> { self.find_pte(vpn) .map(|pte| {pte.clone()}) } // \u8c03\u7528 find_pte \u6765\u5b9e\u73b0\uff0c\u5982\u679c\u80fd\u591f\u627e\u5230\u9875\u8868\u9879\uff0c\u90a3\u4e48\u5b83\u4f1a\u5c06\u9875\u8868\u9879\u62f7\u8d1d\u4e00\u4efd\u5e76\u8fd4\u56de\uff0c\u5426\u5219\u5c31\u8fd4\u56de\u4e00\u4e2a None pub fn token(&self) -> usize { 8usize << 60 | self.root_ppn.0 } // PageTable::token \u4f1a\u6309\u7167 satp CSR \u683c\u5f0f\u8981\u6c42 \u6784\u9020\u4e00\u4e2a\u65e0\u7b26\u53f7 64 \u4f4d\u65e0\u7b26\u53f7\u6574\u6570\uff0c // \u4f7f\u5f97\u5176\u5206\u9875\u6a21\u5f0f\u4e3a SV39 \uff0c\u4e14\u5c06\u5f53\u524d\u591a\u7ea7\u9875\u8868\u7684\u6839\u8282\u70b9\u6240\u5728\u7684\u7269\u7406\u9875\u53f7\u586b\u5145\u8fdb\u53bb } pub fn translated_byte_buffer(token: usize, ptr: *const u8, len: usize) -> Vec<&'static mut [u8]> { let page_table = PageTable::from_token(token); let mut start = ptr as usize; let end = start + len; let mut v = Vec::new(); while start < end { let start_va = VirtAddr::from(start); let mut vpn = start_va.floor(); let ppn = page_table .translate(vpn) .unwrap() .ppn(); vpn.step(); let mut end_va: VirtAddr = vpn.into(); end_va = end_va.min(VirtAddr::from(end)); if end_va.page_offset() == 0 { v.push(&mut ppn.get_bytes_array()[start_va.page_offset()..]); } else { v.push(&mut ppn.get_bytes_array()[start_va.page_offset()..end_va.page_offset()]); } start = end_va.into(); } v } os/src/sync/mod.rs mod up; pub use up::UPSafeCell; os/src/sync/up.rs use core::cell::{RefCell, RefMut}; /// Wrap a static data structure inside it so that we are /// able to access it without any `unsafe`. /// /// We should only use it in uniprocessor. /// /// In order to get mutable reference of inner data, call /// `exclusive_access`. pub struct UPSafeCell<T> { /// inner data inner: RefCell<T>, } unsafe impl<T> Sync for UPSafeCell<T> {} impl<T> UPSafeCell<T> { /// User is responsible to guarantee that inner struct is only used in /// uniprocessor. pub unsafe fn new(value: T) -> Self { Self { inner: RefCell::new(value) } } /// Panic if the data has been borrowed. pub fn exclusive_access(&self) -> RefMut<'_, T> { self.inner.borrow_mut() } } os/src/syscall/fs.rs // \u67e5\u9875\u8868\u4ee5\u8bbf\u95ee\u4e0d\u540c\u5730\u5740\u7a7a\u95f4\u7684\u6570\u636e \u3002\u5728\u5185\u6838\u5730\u5740\u7a7a\u95f4\u4e2d\u6267\u884c\u7684\u5185\u6838\u4ee3\u7801\u5e38\u5e38\u9700\u8981\u8bfb\u5199\u5e94\u7528\u7684\u5730\u5740\u7a7a\u95f4\u4e2d\u7684\u6570\u636e\uff0c // \u8fd9\u65e0\u6cd5\u7b80\u5355\u7684\u901a\u8fc7\u4e00\u6b21\u8bbf\u5b58\u6765\u89e3\u51b3\uff0c\u800c\u662f\u9700\u8981\u624b\u52a8\u67e5\u7528\u6237\u6001\u5e94\u7528\u7684\u5730\u5740\u7a7a\u95f4\u7684\u9875\u8868\uff0c // \u77e5\u9053\u7528\u6237\u6001\u5e94\u7528\u7684\u865a\u5730\u5740\u5bf9\u5e94\u7684\u7269\u7406\u5730\u5740\u540e\uff0c\u8f6c\u6362\u6210\u5bf9\u5e94\u7684\u5185\u6838\u6001\u7684\u865a\u5730\u5740\uff0c\u624d\u80fd\u8bbf\u95ee\u5e94\u7528\u5730\u5740\u7a7a\u95f4\u4e2d\u7684\u6570\u636e\u3002 // \u5982\u679c\u8bbf\u95ee\u5e94\u7528\u5730\u5740\u7a7a\u95f4\u4e2d\u7684\u6570\u636e\u8de8\u4e86\u591a\u4e2a\u9875\uff0c\u8fd8\u9700\u8981\u6ce8\u610f\u5904\u7406\u5730\u5740\u7684\u8fb9\u754c\u6761\u4ef6 use crate::mm::translated_byte_buffer; use crate::task::current_user_token; const FD_STDOUT: usize = 1; pub fn sys_write(fd: usize, buf: *const u8, len: usize) -> isize { match fd { FD_STDOUT => { let buffers = translated_byte_buffer(current_user_token(), buf, len); for buffer in buffers { print!(\"{}\", core::str::from_utf8(buffer).unwrap()); } len as isize }, _ => { panic!(\"Unsupported fd in sys_write!\"); } } } os/src/syscall/mod.rs const SYSCALL_WRITE: usize = 64; const SYSCALL_EXIT: usize = 93; const SYSCALL_YIELD: usize = 124; const SYSCALL_GET_TIME: usize = 169; mod fs; mod process; use fs::*; use process::*; pub fn syscall(syscall_id: usize, args: [usize; 3]) -> isize { match syscall_id { SYSCALL_WRITE => sys_write(args[0], args[1] as *const u8, args[2]), SYSCALL_EXIT => sys_exit(args[0] as i32), SYSCALL_YIELD => sys_yield(), SYSCALL_GET_TIME => sys_get_time(), _ => panic!(\"Unsupported syscall_id: {}\", syscall_id), } } os/src/syscall/process.rs use crate::task::{ suspend_current_and_run_next, exit_current_and_run_next, }; use crate::timer::get_time_ms; pub fn sys_exit(exit_code: i32) -> ! { println!(\"[kernel] Application exited with code {}\", exit_code); exit_current_and_run_next(); panic!(\"Unreachable in sys_exit!\"); } pub fn sys_yield() -> isize { suspend_current_and_run_next(); 0 } pub fn sys_get_time() -> isize { get_time_ms() as isize } os/src/task/context.rs use crate::trap::trap_return; #[repr(C)] pub struct TaskContext { ra: usize, sp: usize, s: [usize; 12], } impl TaskContext { pub fn zero_init() -> Self { Self { ra: 0, sp: 0, s: [0; 12], } } pub fn goto_trap_return(kstack_ptr: usize) -> Self { Self { ra: trap_return as usize, sp: kstack_ptr, s: [0; 12], } } } os/src/task/switch.rs use super::TaskContext; use core::arch::global_asm; global_asm!(include_str!(\"switch.S\")); extern \"C\" { pub fn __switch( current_task_cx_ptr: *mut TaskContext, next_task_cx_ptr: *const TaskContext ); // \u6211\u4eec\u4f1a\u5c06\u8fd9\u6bb5\u6c47\u7f16\u4ee3\u7801\u4e2d\u7684\u5168\u5c40\u7b26\u53f7 __switch \u89e3\u91ca\u4e3a\u4e00\u4e2a Rust \u51fd\u6570 // \u6211\u4eec\u4f1a\u8c03\u7528\u8be5\u51fd\u6570\u6765\u5b8c\u6210\u5207\u6362\u529f\u80fd\u800c\u4e0d\u662f\u76f4\u63a5\u8df3\u8f6c\u5230\u7b26\u53f7 __switch \u7684\u5730\u5740\u3002 // \u56e0\u6b64\u5728\u8c03\u7528\u524d\u540e Rust \u7f16\u8bd1\u5668\u4f1a\u81ea\u52a8\u5e2e\u52a9\u6211\u4eec\u63d2\u5165\u4fdd\u5b58/\u6062\u590d\u8c03\u7528\u8005\u4fdd\u5b58\u5bc4\u5b58\u5668\u7684\u6c47\u7f16\u4ee3\u7801 } os/src/task/switch.S .altmacro .macro SAVE_SN n sd s\\n, (\\n+2)*8(a0) .endm .macro LOAD_SN n ld s\\n, (\\n+2)*8(a1) .endm .section .text .globl __switch __switch: # __switch( # current_task_cx_ptr: *mut TaskContext, # next_task_cx_ptr: *const TaskContext # ) # save kernel stack of current task sd sp, 8(a0) # save ra & s0~s11 of current execution sd ra, 0(a0) .set n, 0 .rept 12 SAVE_SN %n .set n, n + 1 .endr # restore ra & s0~s11 of next execution ld ra, 0(a1) .set n, 0 .rept 12 LOAD_SN %n .set n, n + 1 .endr # restore kernel stack of next task ld sp, 8(a1) ret os/src/task.rs // \u64cd\u4f5c\u7cfb\u7edf\u9700\u8981\u6269\u5c55\u4efb\u52a1\u63a7\u5236\u5757 TaskControlBlock \u7684\u7ba1\u7406\u8303\u56f4\uff0c // \u4f7f\u5f97\u64cd\u4f5c\u7cfb\u7edf\u80fd\u7ba1\u7406\u62e5\u6709\u72ec\u7acb\u9875\u8868\u548c\u5355\u4e00\u865a\u62df\u5730\u5740\u7a7a\u95f4\u7684\u5e94\u7528\u7a0b\u5e8f\u7684\u8fd0\u884c use crate::mm::{MemorySet, MapPermission, PhysPageNum, KERNEL_SPACE, VirtAddr}; use crate::trap::{TrapContext, trap_handler}; use crate::config::{TRAP_CONTEXT, kernel_stack_position}; use super::TaskContext; pub struct TaskControlBlock { pub task_status: TaskStatus, pub task_cx: TaskContext, pub memory_set: MemorySet, pub trap_cx_ppn: PhysPageNum, pub base_size: usize, } impl TaskControlBlock { pub fn get_trap_cx(&self) -> &'static mut TrapContext { self.trap_cx_ppn.get_mut() } pub fn get_user_token(&self) -> usize { self.memory_set.token() } pub fn new(elf_data: &[u8], app_id: usize) -> Self { // memory_set with elf program headers/trampoline/trap context/user stack let (memory_set, user_sp, entry_point) = MemorySet::from_elf(elf_data); // \u89e3\u6790\u4f20\u5165\u7684 ELF \u683c\u5f0f\u6570\u636e\u6784\u9020\u5e94\u7528\u7684\u5730\u5740\u7a7a\u95f4 memory_set \u5e76\u83b7\u5f97\u5176\u4ed6\u4fe1\u606f let trap_cx_ppn = memory_set .translate(VirtAddr::from(TRAP_CONTEXT).into()) .unwrap() .ppn(); // \u4ece\u5730\u5740\u7a7a\u95f4 memory_set \u4e2d\u67e5\u591a\u7ea7\u9875\u8868\u627e\u5230\u5e94\u7528\u5730\u5740\u7a7a\u95f4\u4e2d\u7684 Trap \u4e0a\u4e0b\u6587\u5b9e\u9645\u88ab\u653e\u5728\u54ea\u4e2a\u7269\u7406\u9875\u5e27 let task_status = TaskStatus::Ready; // map a kernel-stack in kernel space let (kernel_stack_bottom, kernel_stack_top) = kernel_stack_position(app_id); KERNEL_SPACE .exclusive_access() .insert_framed_area( kernel_stack_bottom.into(), kernel_stack_top.into(), MapPermission::R | MapPermission::W, ); // \u6839\u636e\u4f20\u5165\u7684\u5e94\u7528 ID app_id \u8c03\u7528\u5728 config \u5b50\u6a21\u5757\u4e2d\u5b9a\u4e49\u7684 kernel_stack_position \u627e\u5230 \u5e94\u7528\u7684\u5185\u6838\u6808\u9884\u8ba1\u653e\u5728\u5185\u6838\u5730\u5740\u7a7a\u95f4 KERNEL_SPACE \u4e2d\u7684\u54ea\u4e2a\u4f4d\u7f6e // \u5e76\u901a\u8fc7 insert_framed_area \u5b9e\u9645\u5c06\u8fd9\u4e2a\u903b\u8f91\u6bb5 \u52a0\u5165\u5230\u5185\u6838\u5730\u5740\u7a7a\u95f4\u4e2d let task_control_block = Self { task_status, task_cx: TaskContext::goto_trap_return(kernel_stack_top), // \u5728\u5e94\u7528\u7684\u5185\u6838\u6808\u9876\u538b\u5165\u4e00\u4e2a\u8df3\u8f6c\u5230 trap_return \u800c\u4e0d\u662f __restore \u7684\u4efb\u52a1\u4e0a\u4e0b\u6587\uff0c // \u8fd9\u4e3b\u8981\u662f\u4e3a\u4e86\u80fd\u591f\u652f\u6301\u5bf9\u8be5\u5e94\u7528\u7684\u542f\u52a8\u5e76\u987a\u5229\u5207\u6362\u5230\u7528\u6237\u5730\u5740\u7a7a\u95f4\u6267\u884c\u3002 // \u5728\u6784\u9020\u65b9\u5f0f\u4e0a\uff0c\u53ea\u662f\u5c06 ra \u5bc4\u5b58\u5668\u7684\u503c\u8bbe\u7f6e\u4e3a trap_return \u7684\u5730\u5740\u3002 // trap_return \u662f\u540e\u9762\u8981\u4ecb\u7ecd\u7684\u65b0\u7248\u7684 Trap \u5904\u7406\u7684\u4e00\u90e8\u5206 memory_set, trap_cx_ppn, base_size: user_sp, // \u7528\u4e0a\u9762\u7684\u4fe1\u606f\u6765\u521b\u5efa\u5e76\u8fd4\u56de\u4efb\u52a1\u63a7\u5236\u5757\u5b9e\u4f8b task_control_block }; // prepare TrapContext in user space let trap_cx = task_control_block.get_trap_cx(); *trap_cx = TrapContext::app_init_context( entry_point, user_sp, KERNEL_SPACE.exclusive_access().token(), kernel_stack_top, trap_handler as usize, ); task_control_block } } #[derive(Copy, Clone, PartialEq)] pub enum TaskStatus { Ready, Running, Exited, } os/src/task/mod.rs mod context; mod switch; mod task; use crate::loader::{get_num_app, get_app_data}; use crate::trap::TrapContext; use crate::sync::UPSafeCell; use lazy_static::*; use switch::__switch; use task::{TaskControlBlock, TaskStatus}; use alloc::vec::Vec; pub use context::TaskContext; pub struct TaskManager { num_app: usize, inner: UPSafeCell<TaskManagerInner>, } struct TaskManagerInner { tasks: Vec<TaskControlBlock>, current_task: usize, } lazy_static! { pub static ref TASK_MANAGER: TaskManager = { println!(\"init TASK_MANAGER\"); let num_app = get_num_app(); println!(\"num_app = {}\", num_app); let mut tasks: Vec<TaskControlBlock> = Vec::new(); for i in 0..num_app { tasks.push(TaskControlBlock::new( get_app_data(i), i, )); } TaskManager { num_app, inner: unsafe { UPSafeCell::new(TaskManagerInner { tasks, current_task: 0, })}, } }; } impl TaskManager { fn run_first_task(&self) -> ! { let mut inner = self.inner.exclusive_access(); let next_task = &mut inner.tasks[0]; next_task.task_status = TaskStatus::Running; let next_task_cx_ptr = &next_task.task_cx as *const TaskContext; drop(inner); let mut _unused = TaskContext::zero_init(); // before this, we should drop local variables that must be dropped manually unsafe { __switch( &mut _unused as *mut _, next_task_cx_ptr, ); } panic!(\"unreachable in run_first_task!\"); } fn mark_current_suspended(&self) { let mut inner = self.inner.exclusive_access(); let cur = inner.current_task; inner.tasks[cur].task_status = TaskStatus::Ready; } fn mark_current_exited(&self) { let mut inner = self.inner.exclusive_access(); let cur = inner.current_task; inner.tasks[cur].task_status = TaskStatus::Exited; } fn find_next_task(&self) -> Option<usize> { let inner = self.inner.exclusive_access(); let current = inner.current_task; (current + 1..current + self.num_app + 1) .map(|id| id % self.num_app) .find(|id| { inner.tasks[*id].task_status == TaskStatus::Ready }) } fn get_current_token(&self) -> usize { let inner = self.inner.exclusive_access(); inner.tasks[inner.current_task].get_user_token() } fn get_current_trap_cx(&self) -> &mut TrapContext { let inner = self.inner.exclusive_access(); inner.tasks[inner.current_task].get_trap_cx() } fn run_next_task(&self) { if let Some(next) = self.find_next_task() { let mut inner = self.inner.exclusive_access(); let current = inner.current_task; inner.tasks[next].task_status = TaskStatus::Running; inner.current_task = next; let current_task_cx_ptr = &mut inner.tasks[current].task_cx as *mut TaskContext; let next_task_cx_ptr = &inner.tasks[next].task_cx as *const TaskContext; drop(inner); // before this, we should drop local variables that must be dropped manually unsafe { __switch( current_task_cx_ptr, next_task_cx_ptr, ); } // go back to user mode } else { panic!(\"All applications completed!\"); } } } pub fn run_first_task() { TASK_MANAGER.run_first_task(); } fn run_next_task() { TASK_MANAGER.run_next_task(); } fn mark_current_suspended() { TASK_MANAGER.mark_current_suspended(); } fn mark_current_exited() { TASK_MANAGER.mark_current_exited(); } pub fn suspend_current_and_run_next() { mark_current_suspended(); run_next_task(); } pub fn exit_current_and_run_next() { mark_current_exited(); run_next_task(); } pub fn current_user_token() -> usize { TASK_MANAGER.get_current_token() } pub fn current_trap_cx() -> &'static mut TrapContext { TASK_MANAGER.get_current_trap_cx() } os/src/trap/context.rs use riscv::register::sstatus::{Sstatus, self, SPP}; #[repr(C)] pub struct TrapContext { pub x: [usize; 32], pub sstatus: Sstatus, pub sepc: usize, pub kernel_satp: usize, // \u8868\u793a\u5185\u6838\u5730\u5740\u7a7a\u95f4\u7684 token \uff0c\u5373\u5185\u6838\u9875\u8868\u7684\u8d77\u59cb\u7269\u7406\u5730\u5740 pub kernel_sp: usize, // \u8868\u793a\u5f53\u524d\u5e94\u7528\u5728\u5185\u6838\u5730\u5740\u7a7a\u95f4\u4e2d\u7684\u5185\u6838\u6808\u6808\u9876\u7684\u865a\u62df\u5730\u5740 pub trap_handler: usize, // \u8868\u793a\u5185\u6838\u4e2d trap handler \u5165\u53e3\u70b9\u7684\u865a\u62df\u5730\u5740 } impl TrapContext { pub fn set_sp(&mut self, sp: usize) { self.x[2] = sp; } pub fn app_init_context( entry: usize, sp: usize, kernel_satp: usize, kernel_sp: usize, trap_handler: usize, ) -> Self { let mut sstatus = sstatus::read(); sstatus.set_spp(SPP::User); let mut cx = Self { x: [0; 32], sstatus, sepc: entry, kernel_satp, kernel_sp, trap_handler, }; cx.set_sp(sp); cx } } os/src/trap/mod.rs // \u8fd8\u6709\u5c31\u662f\u9700\u8981\u5bf9\u6765\u81ea\u7528\u6237\u6001\u548c\u5185\u6838\u6001\u7684\u5f02\u5e38/\u4e2d\u65ad\u5206\u522b\u8fdb\u884c\u5904\u7406 mod context; use riscv::register::{ mtvec::TrapMode, stvec, scause::{ self, Trap, Exception, Interrupt, }, stval, sie, }; use crate::syscall::syscall; use crate::task::{ exit_current_and_run_next, suspend_current_and_run_next, current_user_token, current_trap_cx, }; use crate::timer::set_next_trigger; use crate::config::{TRAP_CONTEXT, TRAMPOLINE}; use core::arch::{global_asm, asm}; global_asm!(include_str!(\"trap.S\")); pub fn init() { set_kernel_trap_entry(); } fn set_kernel_trap_entry() { unsafe { stvec::write(trap_from_kernel as usize, TrapMode::Direct); } } fn set_user_trap_entry() { unsafe { stvec::write(TRAMPOLINE as usize, TrapMode::Direct); } } pub fn enable_timer_interrupt() { unsafe { sie::set_stimer(); } } #[no_mangle] pub fn trap_handler() -> ! { set_kernel_trap_entry(); let cx = current_trap_cx(); let scause = scause::read(); let stval = stval::read(); match scause.cause() { Trap::Exception(Exception::UserEnvCall) => { cx.sepc += 4; cx.x[10] = syscall(cx.x[17], [cx.x[10], cx.x[11], cx.x[12]]) as usize; } Trap::Exception(Exception::StoreFault) | Trap::Exception(Exception::StorePageFault) => { println!(\"[kernel] PageFault in application, bad addr = {:#x}, bad instruction = {:#x}, kernel killed it.\", stval, cx.sepc); exit_current_and_run_next(); } Trap::Exception(Exception::IllegalInstruction) => { println!(\"[kernel] IllegalInstruction in application, kernel killed it.\"); exit_current_and_run_next(); } Trap::Interrupt(Interrupt::SupervisorTimer) => { set_next_trigger(); suspend_current_and_run_next(); } _ => { panic!(\"Unsupported trap {:?}, stval = {:#x}!\", scause.cause(), stval); } } trap_return(); } #[no_mangle] pub fn trap_return() -> ! { set_user_trap_entry(); let trap_cx_ptr = TRAP_CONTEXT; let user_satp = current_user_token(); extern \"C\" { fn __alltraps(); fn __restore(); } let restore_va = __restore as usize - __alltraps as usize + TRAMPOLINE; unsafe { asm!( \"fence.i\", \"jr {restore_va}\", restore_va = in(reg) restore_va, in(\"a0\") trap_cx_ptr, in(\"a1\") user_satp, options(noreturn) ); } } #[no_mangle] pub fn trap_from_kernel() -> ! { panic!(\"a trap from kernel!\"); } pub use context::{TrapContext}; os/src/trap/trap.S # \u7531\u4e8e\u4ee3\u8868\u5e94\u7528\u7a0b\u5e8f\u8fd0\u884c\u7684\u4efb\u52a1\u548c\u7ba1\u7406\u5e94\u7528\u7684\u64cd\u4f5c\u7cfb\u7edf\u5404\u81ea\u6709\u72ec\u7acb\u7684\u9875\u8868\u548c\u865a\u62df\u5730\u5740\u7a7a\u95f4\uff0c # \u6240\u4ee5\u5728\u64cd\u4f5c\u7cfb\u7edf\u7684\u8bbe\u8ba1\u5b9e\u73b0\u4e0a\u9700\u8981\u8003\u8651\u4e24\u4e2a\u6311\u6218\u3002\u7b2c\u4e00\u4e2a\u6311\u6218\u662f \u9875\u8868\u5207\u6362 \u3002 # \u4e8e\u7cfb\u7edf\u8c03\u7528\u3001\u4e2d\u65ad\u6216\u5f02\u5e38\u5bfc\u81f4\u7684\u5e94\u7528\u7a0b\u5e8f\u548c\u64cd\u4f5c\u7cfb\u7edf\u4e4b\u95f4\u7684\u4e0a\u4e0b\u6587\u5207\u6362\u4e0d\u50cf\u4ee5\u524d\u90a3\u4e48\u7b80\u5355\u4e86\uff0c # \u56e0\u4e3a\u5728\u8fd9\u4e9b\u5904\u7406\u8fc7\u7a0b\u4e2d\u9700\u8981\u5207\u6362\u9875\u8868\uff0c .altmacro .macro SAVE_GP n sd x\\n, \\n*8(sp) .endm .macro LOAD_GP n ld x\\n, \\n*8(sp) .endm .section .text.trampoline .globl __alltraps .globl __restore .align 2 __alltraps: csrrw sp, sscratch, sp # now sp->*TrapContext in user space, sscratch->user stack # save other general purpose registers sd x1, 1*8(sp) # skip sp(x2), we will save it later sd x3, 3*8(sp) # skip tp(x4), application does not use it # save x5~x31 .set n, 5 .rept 27 SAVE_GP %n .set n, n+1 .endr # we can use t0/t1/t2 freely, because they have been saved in TrapContext csrr t0, sstatus csrr t1, sepc sd t0, 32*8(sp) sd t1, 33*8(sp) # read user stack from sscratch and save it in TrapContext csrr t2, sscratch sd t2, 2*8(sp) # \u5e94\u7528\u5730\u5740\u7a7a\u95f4\u4e2d\u5b8c\u6210\u4e86\u4fdd\u5b58 Trap \u4e0a\u4e0b\u6587\u7684\u5de5\u4f5c # load kernel_satp into t0 ld t0, 34*8(sp) # \u5c06\u5185\u6838\u5730\u5740\u7a7a\u95f4\u7684 token \u8f7d\u5165\u5230 t0 \u5bc4\u5b58\u5668\u4e2d # load trap_handler into t1 ld t1, 36*8(sp) # \u5c06 trap handler \u5165\u53e3\u70b9\u7684\u865a\u62df\u5730\u5740\u8f7d\u5165\u5230 t1 \u5bc4\u5b58\u5668\u4e2d # move to kernel_sp ld sp, 35*8(sp) # \u76f4\u63a5\u5c06 sp \u4fee\u6539\u4e3a\u5e94\u7528\u5185\u6838\u6808\u9876\u7684\u5730\u5740 # switch to kernel space csrw satp, t0 sfence.vma # \u5c06 satp \u4fee\u6539\u4e3a\u5185\u6838\u5730\u5740\u7a7a\u95f4\u7684 token \u5e76\u4f7f\u7528 sfence.vma \u5237\u65b0\u5feb\u8868\uff0c # \u8fd9\u5c31\u5207\u6362\u5230\u4e86\u5185\u6838\u5730\u5740\u7a7a\u95f4 # jump to trap_handler jr t1 # \u901a\u8fc7 jr \u6307\u4ee4\u8df3\u8f6c\u5230 t1 \u5bc4\u5b58\u5668\u6240\u4fdd\u5b58\u7684trap handler \u5165\u53e3\u70b9\u7684\u5730\u5740 __restore: # a0: *TrapContext in user space(Constant); a1: user space token # switch to user space csrw satp, a1 sfence.vma # \u5207\u6362\u56de\u5e94\u7528\u5730\u5740\u7a7a\u95f4 csrw sscratch, a0 # \u5c06\u4f20\u5165\u7684 Trap \u4e0a\u4e0b\u6587\u4f4d\u7f6e\u4fdd\u5b58\u5728 sscratch \u5bc4\u5b58\u5668\u4e2d\uff0c # \u8fd9\u6837 __alltraps \u4e2d\u624d\u80fd\u57fa\u4e8e\u5b83\u5c06 Trap \u4e0a\u4e0b\u6587\u4fdd\u5b58\u5230\u6b63\u786e\u7684\u4f4d\u7f6e mv sp, a0 # \u5c06 sp \u4fee\u6539\u4e3a Trap \u4e0a\u4e0b\u6587\u7684\u4f4d\u7f6e\uff0c\u540e\u9762\u57fa\u4e8e\u5b83\u6062\u590d\u5404\u901a\u7528\u5bc4\u5b58\u5668\u548c CSR # now sp points to TrapContext in user space, start restoring based on it # restore sstatus/sepc ld t0, 32*8(sp) ld t1, 33*8(sp) csrw sstatus, t0 csrw sepc, t1 # restore general purpose registers except x0/sp/tp ld x1, 1*8(sp) ld x3, 3*8(sp) .set n, 5 .rept 27 LOAD_GP %n .set n, n+1 .endr # back to user stack ld sp, 2*8(sp) sret # \u901a\u8fc7 sret \u6307\u4ee4\u8fd4\u56de\u7528\u6237\u6001 os/src/loader.rs // \u5728 os/src/build.rs \u4e2d\uff0c\u6211\u4eec\u4e0d\u518d\u5c06\u4e22\u5f03\u4e86\u6240\u6709\u7b26\u53f7\u7684\u5e94\u7528\u4e8c\u8fdb\u5236\u955c\u50cf\u94fe\u63a5\u8fdb\u5185\u6838\uff0c // \u56e0\u4e3a\u5728\u5e94\u7528\u4e8c\u8fdb\u5236\u955c\u50cf\u4e2d\uff0c\u5185\u5b58\u5e03\u5c40\u4e2d\u5404\u4e2a\u903b\u8f91\u6bb5\u7684\u7f6e\u548c\u8bbf\u95ee\u9650\u5236\u7b49\u4fe1\u606f\u90fd\u88ab\u88c1\u526a\u6389\u4e86\u3002 // \u6211\u4eec\u76f4\u63a5\u4f7f\u7528\u4fdd\u5b58\u4e86\u903b\u8f91\u6bb5\u4fe1\u606f\u7684 ELF \u683c\u5f0f\u7684\u5e94\u7528\u53ef\u6267\u884c\u6587\u4ef6\u3002\u8fd9\u6837 loader \u5b50\u6a21\u5757\u7684\u8bbe\u8ba1\u5b9e\u73b0\u4e5f\u53d8\u5f97\u7cbe\u7b80 // \u83b7\u53d6\u94fe\u63a5\u5230\u5185\u6838\u5185\u7684\u5e94\u7528\u7684\u6570\u76ee pub fn get_num_app() -> usize { extern \"C\" { fn _num_app(); } unsafe { (_num_app as usize as *const usize).read_volatile() } } // get_app_data \u5219\u6839\u636e\u4f20\u5165\u7684\u5e94\u7528\u7f16\u53f7\u53d6\u51fa\u5bf9\u5e94\u5e94\u7528\u7684 ELF \u683c\u5f0f\u53ef\u6267\u884c\u6587\u4ef6\u6570\u636e\u3002 // \u5b83\u4eec\u548c\u4e4b\u524d\u4e00\u6837\u4ecd\u662f\u57fa\u4e8e build.rs \u751f\u6210\u7684 link_app.S \u7ed9\u51fa\u7684\u7b26\u53f7\u6765\u786e\u5b9a\u5176\u4f4d\u7f6e\uff0c // \u5e76\u5b9e\u9645\u653e\u5728\u5185\u6838\u7684\u6570\u636e\u6bb5\u4e2d\u3002 loader \u6a21\u5757\u4e2d\u539f\u6709\u7684\u5185\u6838\u548c\u7528\u6237\u6808\u5219\u5206\u522b\u4f5c\u4e3a\u903b\u8f91\u6bb5\u653e\u5728\u5185\u6838\u548c\u7528\u6237\u5730\u5740\u7a7a\u95f4\u4e2d\uff0c // \u6211\u4eec\u65e0\u9700\u518d\u53bb\u4e13\u95e8\u4e3a\u5176\u5b9a\u4e49\u4e00\u79cd\u7c7b\u578b pub fn get_app_data(app_id: usize) -> &'static [u8] { extern \"C\" { fn _num_app(); } let num_app_ptr = _num_app as usize as *const usize; let num_app = get_num_app(); let app_start = unsafe { core::slice::from_raw_parts(num_app_ptr.add(1), num_app + 1) }; assert!(app_id < num_app); unsafe { core::slice::from_raw_parts( app_start[app_id] as *const u8, app_start[app_id + 1] - app_start[app_id] ) } } os/src/main.rs #![no_std] #![no_main] #![feature(panic_info_message)] #![feature(alloc_error_handler)] extern crate alloc; // alloc \u5e93\u9700\u8981\u6211\u4eec\u63d0\u4f9b\u7ed9\u5b83\u4e00\u4e2a \u5168\u5c40\u7684\u52a8\u6001\u5185\u5b58\u5206\u914d\u5668 \uff0c\u5b83\u4f1a\u5229\u7528\u8be5\u5206\u914d\u5668\u6765\u7ba1\u7406\u5806\u7a7a\u95f4\uff0c // \u4ece\u800c\u4f7f\u5f97\u4e0e\u5806\u76f8\u5173\u7684\u667a\u80fd\u6307\u9488\u6216\u5bb9\u5668\u6570\u636e\u7ed3\u6784\u53ef\u4ee5\u6b63\u5e38\u5de5\u4f5c // \u9700\u8981\u5f15\u5165 alloc \u5e93\u7684\u4f9d\u8d56\uff0c\u7531\u4e8e\u5b83\u7b97\u662f Rust \u5185\u7f6e\u7684 crate \uff0c\u6211\u4eec\u5e76\u4e0d\u662f\u5728 Cargo.toml \u4e2d\u8fdb\u884c\u5f15\u5165\uff0c // \u800c\u662f\u5728 main.rs \u4e2d\u58f0\u660e\u5373\u53ef #[macro_use] extern crate bitflags; #[macro_use] mod console; mod lang_items; mod sbi; mod syscall; mod trap; mod loader; mod config; mod task; mod timer; mod sync; mod mm; use core::arch::global_asm; global_asm!(include_str!(\"entry.asm\")); global_asm!(include_str!(\"link_app.S\")); fn clear_bss() { extern \"C\" { fn sbss(); fn ebss(); } unsafe { core::slice::from_raw_parts_mut( sbss as usize as *mut u8, ebss as usize - sbss as usize, ).fill(0); } } #[no_mangle] pub fn rust_main() -> ! { clear_bss(); println!(\"[kernel] Hello, world!\"); mm::init(); println!(\"[kernel] back to world!\"); mm::remap_test(); trap::init(); //trap::enable_interrupt(); trap::enable_timer_interrupt(); timer::set_next_trigger(); task::run_first_task(); panic!(\"Unreachable in rust_main!\"); } os/Makefile # Building TARGET := riscv64gc-unknown-none-elf MODE := release KERNEL_ELF := target/$(TARGET)/$(MODE)/os KERNEL_BIN := $(KERNEL_ELF).bin DISASM_TMP := target/$(TARGET)/$(MODE)/asm # BOARD BOARD ?= qemu SBI ?= rustsbi BOOTLOADER := ../bootloader/$(SBI)-$(BOARD).bin K210_BOOTLOADER_SIZE := 131072 # KERNEL ENTRY ifeq ($(BOARD), qemu) KERNEL_ENTRY_PA := 0x80200000 else ifeq ($(BOARD), k210) KERNEL_ENTRY_PA := 0x80020000 endif # Run K210 K210-SERIALPORT = /dev/ttyUSB0 K210-BURNER = ../tools/kflash.py # Binutils OBJDUMP := rust-objdump --arch-name=riscv64 OBJCOPY := rust-objcopy --binary-architecture=riscv64 # Disassembly DISASM ?= -x build: env switch-check $(KERNEL_BIN) switch-check: ifeq ($(BOARD), qemu) (which last-qemu) || (rm -f last-k210 && touch last-qemu && make clean) else ifeq ($(BOARD), k210) (which last-k210) || (rm -f last-qemu && touch last-k210 && make clean) endif env: (rustup target list | grep \"riscv64gc-unknown-none-elf (installed)\") || rustup target add $(TARGET) cargo install cargo-binutils --vers =0.3.3 rustup component add rust-src rustup component add llvm-tools-preview $(KERNEL_BIN): kernel @$(OBJCOPY) $(KERNEL_ELF) --strip-all -O binary $@ kernel: @cd ../user && make build @echo Platform: $(BOARD) @cp src/linker-$(BOARD).ld src/linker.ld @cargo build --release --features \"board_$(BOARD)\" @rm src/linker.ld clean: @cargo clean disasm: kernel @$(OBJDUMP) $(DISASM) $(KERNEL_ELF) | less disasm-vim: kernel @$(OBJDUMP) $(DISASM) $(KERNEL_ELF) > $(DISASM_TMP) @vim $(DISASM_TMP) @rm $(DISASM_TMP) run: run-inner run-inner: build ifeq ($(BOARD),qemu) @qemu-system-riscv64 \\ -machine virt \\ -nographic \\ -bios $(BOOTLOADER) \\ -device loader,file=$(KERNEL_BIN),addr=$(KERNEL_ENTRY_PA) else (which $(K210-BURNER)) || (cd .. && git clone https://github.com/sipeed/kflash.py.git && mv kflash.py tools) @cp $(BOOTLOADER) $(BOOTLOADER).copy @dd if=$(KERNEL_BIN) of=$(BOOTLOADER).copy bs=$(K210_BOOTLOADER_SIZE) seek=1 @mv $(BOOTLOADER).copy $(KERNEL_BIN) @sudo chmod 777 $(K210-SERIALPORT) python3 $(K210-BURNER) -p $(K210-SERIALPORT) -b 1500000 $(KERNEL_BIN) python3 -m serial.tools.miniterm --eol LF --dtr 0 --rts 0 --filter direct $(K210-SERIALPORT) 115200 endif debug: build @tmux new-session -d \\ \"qemu-system-riscv64 -machine virt -nographic -bios $(BOOTLOADER) -device loader,file=$(KERNEL_BIN),addr=$(KERNEL_ENTRY_PA) -s -S\" && \\ tmux split-window -h \"riscv64-unknown-elf-gdb -ex 'file $(KERNEL_ELF)' -ex 'set arch riscv:rv64' -ex 'target remote localhost:1234'\" && \\ tmux -2 attach-session -d .PHONY: build env kernel clean disasm disasm-vim run-inner switch-check \u5728 user \u6587\u4ef6\u5939\u4e0b user/.cargo/config [build] target = \"riscv64gc-unknown-none-elf\" [target.riscv64gc-unknown-none-elf] rustflags = [ \"-Clink-args=-Tsrc/linker.ld\", ] user/Cargo.toml [package] name = \"user_lib\" version = \"0.1.0\" authors = [\"Yifan Wu <shinbokuow@163.com>\"] edition = \"2018\" # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html [dependencies] user/src/console.rs use core::fmt::{self, Write}; use super::write; struct Stdout; const STDOUT: usize = 1; impl Write for Stdout { fn write_str(&mut self, s: &str) -> fmt::Result { write(STDOUT, s.as_bytes()); Ok(()) } } pub fn print(args: fmt::Arguments) { Stdout.write_fmt(args).unwrap(); } #[macro_export] macro_rules! print { ($fmt: literal $(, $($arg: tt)+)?) => { $crate::console::print(format_args!($fmt $(, $($arg)+)?)); } } #[macro_export] macro_rules! println { ($fmt: literal $(, $($arg: tt)+)?) => { $crate::console::print(format_args!(concat!($fmt, \"\\n\") $(, $($arg)+)?)); } } user/src/lang_items.rs #[panic_handler] fn panic_handler(panic_info: &core::panic::PanicInfo) -> ! { let err = panic_info.message().unwrap(); if let Some(location) = panic_info.location() { println!(\"Panicked at {}:{}, {}\", location.file(), location.line(), err); } else { println!(\"Panicked: {}\", err); } loop {} } user/src/lib.rs #![no_std] #![feature(linkage)] #![feature(panic_info_message)] #[macro_use] pub mod console; mod syscall; mod lang_items; #[no_mangle] #[link_section = \".text.entry\"] pub extern \"C\" fn _start() -> ! { exit(main()); panic!(\"unreachable after sys_exit!\"); } #[linkage = \"weak\"] #[no_mangle] fn main() -> i32 { panic!(\"Cannot find main!\"); } use syscall::*; pub fn write(fd: usize, buf: &[u8]) -> isize { sys_write(fd, buf) } pub fn exit(exit_code: i32) -> isize { sys_exit(exit_code) } pub fn yield_() -> isize { sys_yield() } pub fn get_time() -> isize { sys_get_time() } user/src/linker.ld OUTPUT_ARCH(riscv) ENTRY(_start) BASE_ADDRESS = 0x10000; # \u5047\u5b9a\u64cd\u4f5c\u7cfb\u7edf\u80fd\u591f\u901a\u8fc7\u5206\u9875\u673a\u5236\u628a\u4e0d\u540c\u5e94\u7528\u7684\u76f8\u540c\u865a\u5730\u5740\u6620\u5c04\u5230\u4e0d\u540c\u7684\u7269\u7406\u5730\u5740\u4e0a # \u8fd9\u6837\u6211\u4eec\u5199\u5e94\u7528\u5c31\u4e0d\u7528\u8003\u8651\u5e94\u7528\u7684\u7269\u7406\u5730\u5740\u5e03\u5c40\u7684\u95ee\u9898\uff0c\u80fd\u591f\u4ee5\u4e00\u79cd\u66f4\u52a0\u7edf\u4e00\u7684\u65b9\u5f0f\u7f16\u5199\u5e94\u7528\u7a0b\u5e8f\uff0c # \u53ef\u4ee5\u5ffd\u7565\u6389\u4e00\u4e9b\u4e0d\u5fc5\u8981\u7684\u7ec6\u8282 SECTIONS { . = BASE_ADDRESS; .text : { *(.text.entry) *(.text .text.*) } . = ALIGN(4K); .rodata : { *(.rodata .rodata.*) *(.srodata .srodata.*) } . = ALIGN(4K); .data : { *(.data .data.*) *(.sdata .sdata.*) } .bss : { *(.bss .bss.*) *(.sbss .sbss.*) } /DISCARD/ : { *(.eh_frame) *(.debug*) } } user/src/syscall.rs use core::arch::asm; const SYSCALL_WRITE: usize = 64; const SYSCALL_EXIT: usize = 93; const SYSCALL_YIELD: usize = 124; const SYSCALL_GET_TIME: usize = 169; fn syscall(id: usize, args: [usize; 3]) -> isize{ let mut ret: isize; unsafe{ asm!( \"ecall\", inlateout(\"x10\") args[0] => ret, in(\"x11\") args[1], in(\"x12\") args[2], in(\"x17\") id ); } ret } pub fn sys_write(fd: usize, buffer: &[u8]) -> isize{ syscall(SYSCALL_WRITE, [fd, buffer.as_ptr() as usize, buffer.len()]) } pub fn sys_exit(exit_code: i32) -> isize { syscall(SYSCALL_EXIT, [exit_code as usize, 0, 0]) } pub fn sys_yield() -> isize { syscall(SYSCALL_YIELD, [0, 0, 0]) } pub fn sys_get_time() -> isize { syscall(SYSCALL_GET_TIME, [0, 0, 0]) } user/src/bin/00power_3.rs #![no_std] #![no_main] #[macro_use] extern crate user_lib; const LEN: usize = 100; static mut S: [u64; LEN] = [0u64; LEN]; #[no_mangle] unsafe fn main() -> i32 { let p = 3u64; let m = 998244353u64; let iter: usize = 300000; let mut cur = 0usize; S[cur] = 1; for i in 1..=iter { let next = if cur + 1 == LEN { 0 } else { cur + 1 }; S[next] = S[cur] * p % m; cur = next; if i % 10000 == 0 { println!(\"power_3 [{}/{}]\", i, iter); } } println!(\"{}^{} = {}(MOD {})\", p, iter, S[cur], m); println!(\"Test power_3 OK!\"); 0 } user/src/bin/01power_5.rs #![no_std] #![no_main] #[macro_use] extern crate user_lib; const LEN: usize = 100; static mut S: [u64; LEN] = [0u64; LEN]; #[no_mangle] unsafe fn main() -> i32 { let p = 5u64; let m = 998244353u64; let iter: usize = 210000; let mut cur = 0usize; S[cur] = 1; for i in 1..=iter { let next = if cur + 1 == LEN { 0 } else { cur + 1 }; S[next] = S[cur] * p % m; cur = next; if i % 10000 == 0 { println!(\"power_5 [{}/{}]\", i, iter); } } println!(\"{}^{} = {}(MOD {})\", p, iter, S[cur], m); println!(\"Test power_5 OK!\"); 0 } user/src/bin/02power_7.rs #![no_std] #![no_main] #[macro_use] extern crate user_lib; const LEN: usize = 100; static mut S: [u64; LEN] = [0u64; LEN]; #[no_mangle] unsafe fn main() -> i32 { let p = 7u64; let m = 998244353u64; let iter: usize = 240000; let mut cur = 0usize; S[cur] = 1; for i in 1..=iter { let next = if cur + 1 == LEN { 0 } else { cur + 1 }; S[next] = S[cur] * p % m; cur = next; if i % 10000 == 0 { println!(\"power_7 [{}/{}]\", i, iter); } } println!(\"{}^{} = {}(MOD {})\", p, iter, S[cur], m); println!(\"Test power_7 OK!\"); 0 } user/src/bin/03sleep.rs #![no_std] #![no_main] #[macro_use] extern crate user_lib; use user_lib::{get_time, yield_}; #[no_mangle] fn main() -> i32 { let current_timer = get_time(); let wait_for = current_timer + 3000; while get_time() < wait_for { yield_(); } println!(\"Test sleep OK!\"); 0 } user/Makefile TARGET := riscv64gc-unknown-none-elf MODE := release APP_DIR := src/bin TARGET_DIR := target/$(TARGET)/$(MODE) APPS := $(wildcard $(APP_DIR)/*.rs) ELFS := $(patsubst $(APP_DIR)/%.rs, $(TARGET_DIR)/%, $(APPS)) BINS := $(patsubst $(APP_DIR)/%.rs, $(TARGET_DIR)/%.bin, $(APPS)) OBJDUMP := rust-objdump --arch-name=riscv64 OBJCOPY := rust-objcopy --binary-architecture=riscv64 elf: $(APPS) @cargo build --release binary: elf $(foreach elf, $(ELFS), $(OBJCOPY) $(elf) --strip-all -O binary $(patsubst $(TARGET_DIR)/%, $(TARGET_DIR)/%.bin, $(elf));) build: binary clean: @cargo clean .PHONY: elf binary build clean \u6267\u884c\u6d41\u7a0b os/src/main.rs - \u5bfc\u5165 entry.asm \u8bbe\u7f6e\u51fd\u6570\u6808\uff0c \u8df3\u8f6c\u5230rust_main \u5bfc\u5165 link_app.S \u8fd9\u91cc\u5168\u662f\u6570\u636e\u6bb5\uff0c \u53ef\u6267\u884c\u6587\u4ef6\u5728\u90e8\u5206\u6570\u636e\u6bb5\u4e2d \u8c03\u7528 clear_bss \u51fd\u6570\uff0c \u6e05\u9664 \u9664 .bss.stack \u4ee5\u5916\u7684 .bss \u6bb5 \u8c03\u7528 println! \u6253\u5370 [kernel] Hello, world! , \u6b64\u65f6\u5904\u4e8e\u5185\u6838\u6001 \u8c03\u7528 mm::init os/src/mm/mod.rs \u8c03\u7528 init_heap os/src/mm/heap_allocator.rs \u5c06\u4e00\u6bb5\u6570\u7ec4\u7684\u957f\u5ea6\u548c\u5927\u5c0f\u4f5c\u4e3a\u53c2\u6570 \u7528\u4e8e HEAP_ALLOCATOR \u7ba1\u7406 \u5806\u7ba1\u7406\u7684\u5177\u4f53\u5b9e\u73b0\u662f\u7531Rust\u7684\u5e93\u5b9e\u73b0 \u8c03\u7528 init_frame_allocator os/src/mm/frame_allocator \u83b7\u53d6 ekernel \u7684\u5730\u5740 \u5c06 ekernel \u548c MEMORY_END \u7684\u5730\u5740\u53d6\u6574\u8f6c\u6210\u7269\u7406\u5730\u5740\u540e\u4f20\u5165 FRAME_ALLOCATOR \u8df3\u8f6cStackFrameAllocator\u7684 init\u51fd\u6570\uff0c\u5373\u8d4b\u503c\u7ed9\u7ed3\u6784\u4f53StackFrameAllocator\u7684current\u548cend \u8c03\u7528KERNEL_SPACE \u7684 activate os/src/mm/memory_set.rs \u9759\u6001\u751f\u6210KERNEL_SPACE\uff0c\u5b83\u662fMemorySet\u7c7b\u578b\u901a\u8fc7\u5176new_kernel\u51fd\u6570\u6784\u9020\u800c\u6210 new_kernel\u5148\u8c03\u7528 new_bare \u51fd\u6570\u83b7\u5f97\u4e00\u4e2aMemorySet new_bare\u51fd\u6570\u8c03\u7528PageTable \u7684new\u51fd\u6570\u83b7\u5f97\u4e00\u4e2aPageTable PageTable \u7684new\u51fd\u6570\u8c03\u7528frame_alloc\u51fd\u6570 frame_alloc \u51fd\u6570\u5148\u8c03\u7528FRAME_ALLOCATOR\u51fd\u6570\u7684 alloc\u51fd\u6570\u83b7\u5f97\u7269\u7406\u9875 alloc \u51fd\u6570\u5148\u67e5\u770bStackFrameAllocator\u7684recycled\u8fd9\u4e2aVec\u4e2d\u6709\u6ca1\u6709\u7269\u7406\u9875\u53ef\u4ee5\u8fd4\u56de \u5982\u679c\u6709\u5c31\u76f4\u63a5\u8fd4\u56de\uff0c\u6ca1\u6709\u5c31\u5206\u914d\u65b0\u7684\u9875\uff0c\u5982\u679c\u6574\u4e2a\u6570\u7ec4\u88ab\u5206\u914d\u5b8c\u4e86\uff0c\u5c31\u8fd4\u56deNone frame_alloc \u51fd\u6570\u8c03\u7528FrameTracker\u7ed3\u6784\u7684new\u51fd\u6570\u5c06\u521a\u624d\u5f97\u5230\u7684\u7269\u7406\u9875\u8868\u6240\u5bf9\u5e94\u7684\u9875\u6e05\u96f6 \u518d\u5c06\u5f97\u5230\u7684\u7269\u7406\u9875\u4f20\u5230FRAME_ALLOCATOR\u7684map\u51fd\u6570\uff0c\u5c06Option \u7c7b\u578b\u7684 ppn \u8f6c\u6210FrameTracker\u7c7b\u578b \u5c06\u83b7\u5f97\u7684FrameTracker\u7684ppn\u4f5c\u4e3aPageTable \u7684 root_ppn,\u5e76\u5c06\u8fd9\u4e2aFrameTracker\u5b58\u5728\u5728PageTable\u7684frames\u8fd9\u4e2aVec\u5bb9\u5668\u4e2d \u8fd4\u56de\u8fd9\u4e2aPageTable \u751f\u6210\u4e00\u4e2a\u7a7a\u7684areas\u7684Vec\u5bb9\u5668 \u8fd4\u56de\u8fd9\u4e2aMemorySet\u8fd9\u4e2a\u7ed3\u6784\u4f53 \u8c03\u7528\u83b7\u5f97\u7684 MemorySet \u7684 map_trampoline \u51fd\u6570\uff0c map_trampoline \u8c03\u7528 MemorySet\u7684page_table\u7684map\u51fd\u6570 \u5148\u8c03\u7528VirtAddr\u7684from\u65b9\u6cd5\u5c06usize\u7684TRAMPOLIMNE\u8f6c\u6210VirtAddr \u518d\u5c06VirtAddr\u7c7b\u578b\u8f6c\u6210VirtPageNum\u7c7b\u578b \u540c\u7406\uff0c\u5c06\u4ecelinker.ld\u4e2d\u83b7\u5f97\u7684strampoline\u5730\u5740\u5148\u8f6c\u6210\u7269\u7406\u5730\u5740\uff0c\u518d\u8f6c\u6210\u7269\u7406\u9875\u53f7 \u6700\u540e\u7ed9\u4ed6\u4eec\u8bfb\u5199\u6743\u9650 \u5c06\u83b7\u5f97\u7684\u865a\u62df\u9875\u53f7\u548c\u7269\u7406\u9875\u53f7\u4ee5\u53ca\u6807\u5fd7\u4f4d\u4f20\u5165\u5230map\u51fd\u6570 map\u51fd\u6570\u5148\u8c03\u7528PageTable\u7684find_pte_create\u65b9\u6cd5 find_pte_create\u65b9\u6cd5\u4e2d\uff0c\u5148\u8c03\u7528VirtPageNum \u7684indexes\u65b9\u6cd5 indexes\u65b9\u6cd5\u4e2d\uff0c\u5148\u53d6\u51fa\u865a\u62df\u9875\u53f7\uff0c\u5206\u522b\u53d6\u51fa\u4e09\u7ea7\u9875\u7684\u7d22\u5f15\uff0c\u4ee5\u6570\u7ec4\u7684\u5f62\u5f0f\u8fd4\u56de \u83b7\u53d6PageTable\u7684root_ppn \u5206\u522b\u53d6\u51fa\u4e09\u7ea7\u7d22\u5f15\uff0c\u5982\u679c\u627e\u5230\u4e86\u7b2c\u4e00\u7ea7\u7d22\u5f15\uff08\u5373\u7269\u7406\u9875\u53f7\uff09\uff0c\u5c31\u5c06\u5176\u5bf9\u5e94\u7684\u9875\u8868\u9879\u76f4\u63a5\u8fd4\u56de \u5982\u679c\u67d0\u4e2a\u7d22\u5f15\u8d70\u4e0d\u901a\uff0c\u5c31\u662f\u4e0d\u5b58\u5728\u6216\u4e0d\u548c\u6cd5\uff0c\u5c31\u8c03\u7528frame_alloc\u7533\u8bf7\u4e00\u4e2a\u7269\u7406\u9875\uff0c\u83b7\u53d6\u4ed6\u7684\u7269\u7406\u9875\u53f7\uff0c\u518d\u5c06\u8fd9\u4e2a\u7269\u7406\u9875\u53f7\u4f20\u5165\u5230PageTableEntry\u7684new\u51fd\u6570\u4e2d\uff0c\u751f\u6210\u4e00\u4e2a\u7269\u7406\u9875\u5e27\uff0c\u518d\u5c06\u7269\u7406\u9875\u53f7\u5b58\u653e\u5230PageTable\u5168\u5c40\u9875\u7ba1\u7406\u5668\u4e2d \u5c06\u751f\u6210\u7684\u65b0\u7684\u7269\u7406\u9875\u5e27\u8fd4\u56de \u518d\u8c03\u7528PageTableEntry\u7684new\u65b9\u6cd5\uff0c\u901a\u8fc7\u5f97\u5230\u7684\u7269\u7406\u9875\u53f7\u751f\u6210\u5bf9\u5e94\u7684\u7269\u7406\u9875\u5e27 \u6700\u540e\u5c06\u901a\u8fc7\u865a\u62df\u9875\u53f7\u5f97\u5230\u7684\u7269\u7406\u9875\u5e27\u6307\u5411\u4f20\u5165\u5230map\u51fd\u6570\u7684\u7269\u7406\u9875\u5e27 \u6253\u5370\u51fa\u5404\u4e2a\u6bb5\u7684\u5730\u5740 \u8c03\u7528memory_set\u7684push\u65b9\u6cd5 \u8c03\u7528MapArea\u7684new\u65b9\u6cd5 \u5148\u5c06\u5404\u4e2a\u6bb5\u7684\u8d77\u59cb\u5730\u5740\u548c\u7ed3\u675f\u5730\u5740\u8f6c\u6210usize\u7c7b\u578b\uff0c\u518d\u8f6c\u6210\u865a\u62df\u5730\u5740 \u5c06\u5404\u4e2a\u6bb5\u7684\u865a\u62df\u5730\u5740\u8303\u56f4\u548c\u6620\u5c04\u7c7b\u578b\u4ee5\u53ca\u6620\u5c04\u7684\u6743\u9650\u4f5c\u4e3a\u53c2\u6570\u4f20\u5165\u5230new\u65b9\u6cd5\u4e2d MapArea\u4e2d\u7684new\u65b9\u6cd5\u5c06\u4e24\u4e2a\u5730\u5740\u8f6c\u6210\u865a\u62df\u9875\u53f7 \u5c06\u4e24\u4e2a\u865a\u62df\u9875\u53f7\u4f5c\u4e3a\u533a\u95f4\u4f20\u5165\u5230VPNRange\u7684new\u65b9\u6cd5\u4e2d\uff0c\u800cVPNRange\u7684\u672c\u8d28\u662fSimpleRange\u7c7b\u7684\u522b\u79f0\uff0cSimpleRange\u662f\u4e00\u4e2a\u6cdb\u578b\uff0c\u53ea\u5305\u542b\u4e00\u4e2a\u6cdb\u578b\u7684\u5de6\u503c\u548c\u53f3\u503c\uff0c\u5b83\u7684new\u65b9\u6cd5\u5c31\u662f\u5c06\u4e24\u4e2a\u53c2\u6570\u8d4b\u503c\u7ed9\u7ed3\u6784\u4f53\u7684\u5de6\u53f3\u503c \u751f\u6210\u4e00\u4e2a\u7a7a\u7684\u952e\u503c\u5bf9\u8868BTreeMap(\u6ce8\u610f\uff1a\u5b83\u662f\u6709\u5e8f\u7684) \u5c06map_type \u548c map_perm\u8d4b\u503c \u8fd4\u56de\u751f\u6210\u7684MapArea \u5c06\u751f\u6210\u7684MapAreapush\u5230\u5f00\u5934\u751f\u6210\u7684MemorySet\u7684\u5b9e\u4f8b\u7684 areas\u8fd9Vec\u5bb9\u5668\u4e2d \u8fd4\u56de\u751f\u6210\u7684MemorySet \u5b9e\u4f8b memory_set \u8c03\u7528KERNEL_SPACE \u7684 activate \u8c03\u7528MemorySet\u7ed3\u6784\u4f53\u7684\u6210\u5458PageTable\u7684token\u65b9\u6cd5 PageTable\u7684Token\u65b9\u6cd5\uff0c\u5c06root_ppn\u8fdb\u884c\u5904\u7406\uff0c\u8fd4\u56de\u4e00\u4e2ausize \u5c06\u5f97\u5230\u7684Token\u5199\u5165\u5230satp\u5bc4\u5b58\u5668\u4e2d\uff0c\u63a7\u5236\u5206\u9875\u7cfb\u7edf \u5230\u8fd9\u5b8c\u6210\u5206\u9875 main\u51fd\u6570\u4e2d\u8c03\u7528 mm::remap_test\u51fd\u6570 main\u51fd\u6570\u4e2d\u8c03\u7528 trap::init\u51fd\u6570 os/src/trap/mod.rs \u8c03\u7528 set_kernel_trap_entry set_kernel_trap_entry \u4e2d \u5c06 \u51fd\u6570 trap_from_kernel \u7684\u5730\u5740\u548c trap\u7684\u6a21\u5f0f\u4f5c\u4e3a\u53c2\u6570\u4f20\u5165\u5230stvec::write\u65b9\u6cd5\u4e2d\uff0c\u5373\u8bbe\u7f6e trap \u7684\u5904\u7406\u6a21\u5f0f \u548c \u5bf9\u5e94\u5904\u7406\u51fd\u6570\u7684\u5730\u5740 \u8fd9\u91cc\u7684 trap_from_kernel \u51fd\u6570\u53ea\u662f\u4ec5\u4ec5\u8c03\u7528\u4e00\u4e2a panic main\u51fd\u6570\u4e2d\u8c03\u7528 trap::enable_interrupt os/src/mod.rs enable_timer_interrupt \u4e2d os/src/loader.rs \u8c03\u7528 get_num_app \u83b7\u53d6\u5e94\u7528\u4e2a\u6570 \u83b7\u53d6\u7b2c\u4e00\u4e2a\u7a0b\u5e8f\u7684\u5165\u53e3\u5730\u5740 \u5237\u65b0\u6307\u4ee4\u7f13\u51b2\u533a \u8c03\u7528 get_base_i \u83b7\u53d6 \u6bcf\u4e2a\u5e94\u7528\u7a0b\u5e8f\u7684\u8d77\u59cb\u5730\u5740 \u5c06\u6bcf\u4e2a\u5e94\u7528\u8d77\u59cb\u5730\u5740\u5230 \u5e94\u7528\u7a7a\u95f4\u9650\u5236\u8303\u56f4\u7684\u5730\u5740\u533a\u95f4 \u7528 0 \u586b\u5145 \u83b7\u53d6\u6bcf\u4e2a\u5e94\u7528\u5728 .data \u6bb5\u7684\u8d77\u59cb\u5730\u5740\u548c\u5927\u5c0f \u548c \u5728\u5c06\u4f1a\u653e\u7f6e\u8be5\u7a0b\u5e8f\u7684\u8d77\u59cb\u5730\u5740\u548c\u7a0b\u5e8f\u5927\u5c0f \u8c03\u7528 copy_from_slice \u5c06\u7a0b\u5e8f\u4ece .data \u6bb5\u590d\u5236\u5230 \u76f8\u5e94\u7684\u5730\u5740\u533a\u95f4 \u81f3\u6b64\uff0c\u7a0b\u5e8f\u52a0\u8f7d\u5b8c\u6bd5 os/src/main.rs \u8c03\u7528 trap::enable_timer_interrupt \u8c03\u7528 sie::set_stimer \u4f7f\u5f97 S \u7279\u6743\u7ea7\u65f6\u949f\u4e2d\u65ad\u4e0d\u4f1a\u88ab\u5c4f\u853d os/src/main.rs \u8c03\u7528 timer::set_next_trigger \u8bbe\u7f6e\u65f6\u95f4\u7247 \u8c03\u7528 get_time \u83b7\u5f97\u5f53\u524d\u65f6\u95f4\uff0c \u5373 mtime \u7684\u503c \u4f30\u7b97\u51fa 10 ms \u540e mtime \u7684\u503c \u518d\u5c06\u4f30\u7b97\u7684\u503c\u8d4b\u503c\u7ed9 mtimecmp os/src/main.rs \u8c03\u7528 task \u6a21\u5757\u7684 run_first_task os/src/task/mod.rs \u9996\u5148\uff0c\u9759\u6001\u52a0\u8f7d\u4e00\u4e2a\u5168\u5c40\u7684\u4efb\u52a1\u7ba1\u7406\u5668 TaskManager \u7ed3\u6784 \u7684\u5b9e\u4f8b TASK_MANAGER,\u5305\u542b num_app \u548c inner inner \u5305\u62ec \u6570\u7ec4 tasks \u548c current_task \u6570\u7ec4 tasks \u662f TaskControlBlock \u7ed3\u6784\u7684\u6570\u7ec4 TaskControlBlock \u7ed3\u6784\u4f53 \u5305\u62ec \u4efb\u52a1\u72b6\u6001 task_status\u3001 \u4efb\u52a1\u4e0a\u4e0b\u6587 TaskContext (TaskContext \u5305\u542b \u90a314\u4e2a\u5bc4\u5b58\u5668)\u3001\u5185\u5b58\u8f6c\u6362\u9875 memory_set\u3001trap\u7684\u7269\u7406\u5730\u5740 trap_cx_ppn\u3001\u548c\u57fa\u5730\u5740base_size \u5bf9\u4efb\u52a1\u6570\u7ec4\u8fdb\u884c\u521d\u59cb\u5316\uff0c\u5bf9\u6bcf\u4e2a\u4efb\u52a1\u90fd\u5f62\u6210\u4e00\u4e2a\u4efb\u52a1\u63a7\u5236\u5757 os/src/tasks/tasks.rs \u5c06\u6bcf\u4e2a\u4efb\u52a1\u7684\u5730\u5740\u548c\u5176\u7f16\u53f7\u4f20\u5165\u5230 TaskControlBlock \u7ed3\u6784\u4f53\u7684 new\u65b9\u6cd5\u4e2d\uff0c\u7531\u4e8e\u4efb\u52a1\u6ca1\u6709\u53bb\u9664\u5143\u6570\u636e\uff0c\u76f4\u63a5\u751f\u6210\u7684ELF\u683c\u5f0f\uff0c\u6240\u6709\u8be5\u5730\u5740\u5c31\u76f8\u5f53\u4e8e\u662felf_data\u7684\u5730\u5740\uff0c \u5728new\u4e2d\uff0c\u5148\u540c\u8fc7\u5730\u5740\u83b7\u53d6ELF\u7ed3\u6784\u7684\u5934\u7684\u4fe1\u606f \u5c06TRAP_CONTEXT\u6b64\u65f6\u7684\u865a\u62df\u5730\u5740\u8f6c\u6210\u7269\u7406\u5730\u5740 \u5c06\u4efb\u52a1\u7684\u72b6\u6001\u7f6e\u4e3a Ready \u8c03\u7528config.rs\u4e2d\u7684kernel_stack_position\u901a\u8fc7app_id\u83b7\u53d6\u5185\u6838\u6808\u7684\u4e0a\u754c\u548c\u4e0b\u754c \u8c03\u7528KERNEL_SPACE \u7684 insert_framed_area - \u5728 os/src/mm/memory_set.rs\u4e2d - \u5c06\u865a\u62df\u7684\u8d77\u59cb\u5730\u5740\u548c\u7ed3\u675f\u5730\u5740\u4ee5\u53ca\u6743\u9650\u7b26\u53f7 \u4f20\u5165\u5230MapArea\u7684new\u65b9\u6cd5\u4e2d - new\u65b9\u6cd5\u4e2d\uff0c\u5c06\u865a\u62df\u5730\u5740\u533a\u95f4\u53d6\u6574\u8f6c\u6210\u865a\u62df\u9875\u53f7\uff0c\u518d\u5c06\u8fd9\u4e24\u4e2a\u865a\u62df\u9875\u53f7\u8f6c\u6210VPNRange\u8fd9\u4e2d\u8fed\u4ee3\u7c7b\u578b - \u751f\u6210\u4e00\u4e2a\u7a7a\u7684\u865a\u5b9e\u9875\u8868\u6620\u5c04\u7684\u952e\u503c\u5bf9 - \u6700\u540e\u8fd4\u56de\u8fd9\u4e2a\u6620\u5c04\u8868 \u5c06\u8fd9\u4e2a\u6620\u5c04\u8868\u5b58\u653e\u5230MemorySet\u4e2d\u7684areas\u8fd9\u4e2aVec\u5bb9 \u751f\u6210\u4e00\u4e2a\u4efb\u52a1\u63a7\u5236\u5757 \u8c03\u7528TaskContext\u7684goto_trap_return \u51fd\u6570 - \u5c06kernel_stack_top \u4f20\u5165\u5230\u6b64\u51fd\u6570\u4e2d - \u6839\u636e\u8fd9\u4e2a\u4efb\u52a1\u5728\u5185\u6838\u6808\u4e2d\u7684\u4f4d\u7f6e\uff0c\u83b7\u53d6\u5b83\u7684trap\u4e0a\u4e0b\u6587 \u6839\u636e\u4efb\u52a1\u72b6\u6001\u3001trap\u4e0a\u4e0b\u6587\u3001\u5185\u5b58\u6620\u5c04\u8868\u3001trap\u7684\u7269\u7406\u9875\u53f7\u3001\u7528\u6237\u6808\u7684\u8d77\u59cb\u5730\u5740\u751f\u6210\u4e00\u4e2a\u4efb\u52a1\u63a7\u5236\u5757 \u83b7\u5f97\u8fd9\u4e2a\u4efb\u52a1\u63a7\u5236\u5757\u4e2d trap\u7269\u7406\u9875\u53f7\u7684\u53ef\u53d8\u5f15\u7528 \u5c06\u83b7\u5f97\u7684\u4efb\u52a1\u7684\u5165\u53e3\u5730\u5740\u3001\u7528\u6237\u6808\u3001\u7269\u7406\u9875token\u3001\u5185\u6838\u6808\u9876\u3001trap_handler\u51fd\u6570\u7684\u5730\u5740\u4f20\u5165\u5230TrapContext\u7684app_init_context \u51fd\u6570\u4e2d \u5728app_init_context\u51fd\u6570\u4e2d\uff0c\u751f\u6210\u4e00\u4e2atrap\u4e0a\u4e0b\u6587 \u8fd9\u4e2a\u4e0a\u4e0b\u6587\u5305\u62ec 32\u7684\u901a\u7528\u5bc4\u5b58\u5668\u521d\u59cb\u5316\u4e3a0\uff0csstatus\u8bbe\u4e3a\u7528\u6237\u6001\u3001sepc\u6307\u5411ELF\u6587\u4ef6\u7684\u5165\u53e3\u5730\u5740\u3001kernel_satp\u5bc4\u5b58\u5668\uff0ckernel_sp\u5185\u6838\u6808\u3001trap\u5904\u7406\u51fd\u6570\u7684\u5165\u53e3\uff0csp\u6307\u5411\u4f20\u5165\u7684\u7528\u6237\u7684sp \u5c06\u8fd9\u4e2a\u751f\u6210\u7684\u4e0a\u4e0b\u6587\u4f20\u5165\u5230\u4efb\u52a1\u63a7\u5236\u5757\u4e2d\u7684\u4efb\u52a1\u4e0a\u4e0b\u6587 \u6700\u540e\u8fd4\u56de\u8fd9\u4efb\u52a1\u63a7\u5236\u5757 \u9759\u6001\u7684\u4efb\u52a1\u7ba1\u7406\u5668 TASK_MANAGER \u751f\u6210\uff0c\u5305\u62ec\u4efb\u52a1\u6570\u3001\u4efb\u52a1\u6570\u7ec4 \u5373\u5404\u4e2a\u4efb\u52a1\u7684\u63a7\u5236\u5757 \u548c \u5f53\u524d\u4efb\u52a1\u7684\u7f16\u53f7 \u8c03\u7528 run_first_task \u51fd\u6570\uff0c\u8be5\u51fd\u6570\u8c03\u7528\u4efb\u52a1\u7ba1\u7406\u5668\u7684 run_first_task \u65b9\u6cd5 \u5728run_first_task \u65b9\u6cd5\u4e2d \u5148\u83b7\u53d6\u4efb\u52a1\u7ba1\u7406\u5668\u7684\u9501\uff0c\u5373\u4f7f\u7528\u6743 \u7136\u540e\u5c06next\u4efb\u52a1\u7f6e\u4e3a\u7b2c0\u4e2a\u4efb\u52a1\u7684\u501f\u7528 \u5e76\u5c06next\u4efb\u52a1\u7684\u72b6\u6001 \u7f6e\u4e3a Running \u83b7\u53d6next\u4efb\u52a1\u7684\u4e0a\u4e0b\u6587\u7684\u5e94\u7528\uff0c\u7ed9\u4e00\u4e2a\u6307\u9488 \u521b\u5efa\u4e00\u4e2a\u865a\u7684\u4efb\u52a1\u4e0a\u4e0b\u6587\uff0c\u5c06\u5176\u5168\u521d\u59cb\u5316\u4e3a\u96f6\uff0c\u7531\u4e8e\u5b83\u4e0d\u4f1a\u771f\u6b63\u7528\u5230\uff0c\u6240\u6709\u5982\u4f55\u521d\u59cb\u5316\u90fd\u65e0\u5f71\u54cd \u6211\u4eec\u7684\u76ee\u7684\u5c31\u662f\u83b7\u53d6 \u4efb\u52a1\u4e0a\u4e0b\u6587\uff0c\u6b64\u65f6\u5df2\u7ecf\u83b7\u53d6\uff0c\u4e3a\u4e86\u5b89\u5168\uff0c\u5c06\u4efb\u52a10\u7684\u501f\u7528\u91ca\u653e\u6389 \u5c06\u6784\u9020\u7684\u5e8f\u865a\u4efb\u52a1\u4e0a\u4e0b\u6587\u4f5c\u4e3a\u5f53\u524d\u4e0a\u4e0b\u6587\u7684\u501f\u7528\uff0cnext\u4efb\u52a1\u4e0a\u4e0b\u6587\u7684\u5f15\u7528\u505a\u4e3a\u4e0b\u4e00\u4e2a\u4efb\u52a1\u4e0a\u4e0b\u6587\u4f20\u5165\u5230 __switch \u51fd\u6570\u4e2d\uff0c \u8fdb\u884c\u4e00\u756a\u5bc4\u5b58\u5668\u7684\u64cd\u4f5c\u540e\uff0c\u5207\u6362\u5230\u7b2c\u4e00\u4e2a\u4efb\u52a1\u7684\u7a7a\u95f4\uff0c\u6267\u884c\u7b2c\u4e00\u4e2a\u7528\u6237\u4efb\u52a1 \u5bf9\u6d41\u7a0b\u8fdb\u884c\u6574\u7406\u5206\u6790 \u5148\u770b\u7ed3\u6784\u548c\u5185\u5b58\u7684\u793a\u610f\u56fe \u5806\u7ba1\u7406 \u5730\u5740\u7a7a\u95f4 \u5185\u6838\u5185\u5b58\u7ba1\u7406 1 \u4efb\u52a1\u7ba1\u7406 \u5728\u7269\u7406\u5185\u5b58\u4e0a sp -> boot_stack_top .bss.stack satp: 1000 0 ekernel.ceil \u8fdb\u5165\u5230 \u5185\u6838\u5730\u5740\u7a7a\u95f4 \u4e00\u5207\u7686\u4e3a\u865a\u62df\u5730\u5740 stvec -> trap_from_kernel \u5185\u6838\u5730\u5740 sie::set_stimer \u542f\u52a8\u65f6\u949f\u4e2d\u65ad ra: trap_return \u5185\u6838\u5730\u5740 s: [0; 12] sp -> kernel_stack_top\u4efb\u52a1\u4e00 \u5185\u6838\u5730\u5740 restore_va = TRAMPOLINE + size \u5185\u6838\u5730\u5740 -> .text.trampoline \u7269\u7406\u5730\u5740 jr restore_va stvec: TRAMPOLINE \u865a\u62df\u5730\u5740 trap_cx_ptr = TRAP_CONTEXT \u865a\u62df\u5730\u5740 __restore satp: 1000 0 app0.root_ppn \u8fdb\u5165\u5230\u4efb\u52a1\u4e00\u7684\u5730\u5740\u7a7a\u95f4 sscratch: TRAP_CONTEXT \u4efb\u52a1\u4e00\u7684\u5730\u5740\u7a7a\u95f4 sp -> TRAP_CONTEXT \u4efb\u52a1\u4e00\u5b9a\u7684\u5730\u5740\u7a7a\u95f4 sstatus: SPP:User sepc : \u4efb\u52a1\u4e00\u7684 entrypoint s: [0; 12] sp -> user_sp = user_stack_top \u4efb\u52a1\u4e00\u7684\u5730\u5740\u7a7a\u95f4 pc -> \u4efb\u52a1\u4e00\u7684 entrypoint sret pc -> sepc \u8fdb\u5165\u5230\u4efb\u52a1\u4e00 \u6267\u884c syscall \u8c03\u7528 ecall stvec -> TRAMPOLINE \u4efb\u52a1\u4e00\u7684\u5730\u5740\u7a7a\u95f4 __alltraps sp -> \u4efb\u52a1\u4e00\u7684 TRAP_CONTEXT sscratch -> User_stack_top \u4efb\u52a1\u4e00\u7684\u5730\u5740\u7a7a\u95f4 | sscratch | -> \u4efb\u52a1\u4e00\u7684\u5730\u5740\u7a7a\u95f4\u7684 TRAP_CONTEXT | sepc | -> ecall \u540e\u7684\u4e00\u6761\u6307\u4ee4 | sstatus | | x31 | | . | | x5 | | x3 | | x1 | | _ _ | \u4efb\u52a1\u4e00\u7684 user_stack_top sp -> kernel_sp\u4efb\u52a1\u4e00 \u672c\u8eab\u5c31\u662f\u5185\u6838\u5730\u5740\u7a7a\u95f4\u7684\u5730\u5740 satp : 1000 0 ekernel.ceil \u8fdb\u5165\u5230\u5185\u6838\u5730\u5740\u7a7a\u95f4 jr trap_handler \u672c\u8eab\u5c31\u662f\u5185\u6838\u5730\u5740\u7a7a\u95f4\u7684\u5730\u5740 stvec -> trap_from_kernel \u5185\u6838\u5730\u5740\u7a7a\u95f4\u7684\u5730\u5740 \u610f\u601d\u662f\u4e0d\u63a5\u53d7\u5185\u6838\u7684 Trap stvec -> TRAMPOLINE __restore sapt -> 1000 0 app0.root_ppn \u8fdb\u5165\u5230 \u4efb\u52a1\u4e00\u7684\u5730\u5740\u7a7a\u95f4 sscratch -> TRAP_CONTEXT sp -> TRAM_CONTEXT sstatus: SPP:User sepc -> ecall \u4e0b\u4e00\u6761\u6307\u4ee4 s[0; 12] sp -> User_stack_top pc -> ecall \u7684\u4e0b\u4e00\u6761\u6307\u4ee4 \u8fdb\u5165\u5230 \u4efb\u52a1\u4e00 \u5f53\u4efb\u52a1\u5207\u6362\u65f6 \u8fdb\u5165\u5230\u5185\u6838\u5730\u5740\u7a7a\u95f4 \u5c06\u5f53\u524d\u8f6c\u6001\u5b58\u5230\u4efb\u52a1\u4e00\u7684\u4efb\u52a1\u4e0a\u4e0b\u6587 \u6b64\u65f6\u4e3a\u5185\u6838\u5730\u5740\u7a7a\u95f4\uff0c\u53ef\u4ee5\u76f4\u63a5\u627e\u5230 \u5c06\u4efb\u52a1\u4e8c\u7684 \u4efb\u52a1\u4e0a\u4e0b\u6587\u52a0\u8f7d\u5230\u5bc4\u5b58\u5668\u4e2d ret pc -> trap_return","title":"Ch4\u5730\u5740\u7a7a\u95f4"},{"location":"ch4%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/#_1","text":"\u5206\u65f6\u591a\u4efb\u52a1\u7684\u4e3a\u4f8b 1 ./os/src 2 Rust 25 Files 1415 Lines 3 Assembly 3 Files 88 Lines 4 5 \u251c\u2500\u2500 bootloader 6 \u2502 \u251c\u2500\u2500 rustsbi-k210.bin 7 \u2502 \u2514\u2500\u2500 rustsbi-qemu.bin 8 \u251c\u2500\u2500 LICENSE 9 \u251c\u2500\u2500 os 10 \u2502 \u251c\u2500\u2500 build.rs 11 \u2502 \u251c\u2500\u2500 Cargo.lock 12 \u2502 \u251c\u2500\u2500 Cargo.toml 13 \u2502 \u251c\u2500\u2500 Makefile 14 \u2502 \u2514\u2500\u2500 src 15 \u2502 \u251c\u2500\u2500 config.rs(\u4fee\u6539\uff1a\u65b0\u589e\u4e00\u4e9b\u5185\u5b58\u7ba1\u7406\u7684\u76f8\u5173\u914d\u7f6e) 16 \u2502 \u251c\u2500\u2500 console.rs 17 \u2502 \u251c\u2500\u2500 entry.asm 18 \u2502 \u251c\u2500\u2500 lang_items.rs 19 \u2502 \u251c\u2500\u2500 link_app.S 20 \u2502 \u251c\u2500\u2500 linker-k210.ld(\u4fee\u6539\uff1a\u5c06\u8df3\u677f\u9875\u5f15\u5165\u5185\u5b58\u5e03\u5c40) 21 \u2502 \u251c\u2500\u2500 linker-qemu.ld(\u4fee\u6539\uff1a\u5c06\u8df3\u677f\u9875\u5f15\u5165\u5185\u5b58\u5e03\u5c40) 22 \u2502 \u251c\u2500\u2500 loader.rs(\u4fee\u6539\uff1a\u4ec5\u4fdd\u7559\u83b7\u53d6\u5e94\u7528\u6570\u91cf\u548c\u6570\u636e\u7684\u529f\u80fd) 23 \u2502 \u251c\u2500\u2500 main.rs(\u4fee\u6539) 24 \u2502 \u251c\u2500\u2500 mm(\u65b0\u589e\uff1a\u5185\u5b58\u7ba1\u7406\u7684 mm \u5b50\u6a21\u5757) 25 \u2502 \u2502 \u251c\u2500\u2500 address.rs(\u7269\u7406/\u865a\u62df \u5730\u5740/\u9875\u53f7\u7684 Rust \u62bd\u8c61) 26 \u2502 \u2502 \u251c\u2500\u2500 frame_allocator.rs(\u7269\u7406\u9875\u5e27\u5206\u914d\u5668) 27 \u2502 \u2502 \u251c\u2500\u2500 heap_allocator.rs(\u5185\u6838\u52a8\u6001\u5185\u5b58\u5206\u914d\u5668) 28 \u2502 \u2502 \u251c\u2500\u2500 memory_set.rs(\u5f15\u5165\u5730\u5740\u7a7a\u95f4 MemorySet \u53ca\u903b\u8f91\u6bb5 MemoryArea \u7b49) 29 \u2502 \u2502 \u251c\u2500\u2500 mod.rs(\u5b9a\u4e49\u4e86 mm \u6a21\u5757\u521d\u59cb\u5316\u65b9\u6cd5 init) 30 \u2502 \u2502 \u2514\u2500\u2500 page_table.rs(\u591a\u7ea7\u9875\u8868\u62bd\u8c61 PageTable \u4ee5\u53ca\u5176\u4ed6\u5185\u5bb9) 31 \u2502 \u251c\u2500\u2500 sbi.rs 32 \u2502 \u251c\u2500\u2500 sync 33 \u2502 \u2502 \u251c\u2500\u2500 mod.rs 34 \u2502 \u2502 \u2514\u2500\u2500 up.rs 35 \u2502 \u251c\u2500\u2500 syscall 36 \u2502 \u2502 \u251c\u2500\u2500 fs.rs(\u4fee\u6539\uff1a\u57fa\u4e8e\u5730\u5740\u7a7a\u95f4\u7684 sys_write \u5b9e\u73b0) 37 \u2502 \u2502 \u251c\u2500\u2500 mod.rs 38 \u2502 \u2502 \u2514\u2500\u2500 process.rs 39 \u2502 \u251c\u2500\u2500 task 40 \u2502 \u2502 \u251c\u2500\u2500 context.rs(\u4fee\u6539\uff1a\u6784\u9020\u4e00\u4e2a\u8df3\u8f6c\u5230\u4e0d\u540c\u4f4d\u7f6e\u7684\u521d\u59cb\u4efb\u52a1\u4e0a\u4e0b\u6587) 41 \u2502 \u2502 \u251c\u2500\u2500 mod.rs(\u4fee\u6539\uff0c\u8be6\u89c1\u6587\u6863) 42 \u2502 \u2502 \u251c\u2500\u2500 switch.rs 43 \u2502 \u2502 \u251c\u2500\u2500 switch.S 44 \u2502 \u2502 \u2514\u2500\u2500 task.rs(\u4fee\u6539\uff0c\u8be6\u89c1\u6587\u6863) 45 \u2502 \u251c\u2500\u2500 timer.rs 46 \u2502 \u2514\u2500\u2500 trap 47 \u2502 \u251c\u2500\u2500 context.rs(\u4fee\u6539\uff1a\u5728 Trap \u4e0a\u4e0b\u6587\u4e2d\u52a0\u5165\u4e86\u66f4\u591a\u5185\u5bb9) 48 \u2502 \u251c\u2500\u2500 mod.rs(\u4fee\u6539\uff1a\u57fa\u4e8e\u5730\u5740\u7a7a\u95f4\u4fee\u6539\u4e86 Trap \u673a\u5236\uff0c\u8be6\u89c1\u6587\u6863) 49 \u2502 \u2514\u2500\u2500 trap.S(\u4fee\u6539\uff1a\u57fa\u4e8e\u5730\u5740\u7a7a\u95f4\u4fee\u6539\u4e86 Trap \u4e0a\u4e0b\u6587\u4fdd\u5b58\u4e0e\u6062\u590d\u6c47\u7f16\u4ee3\u7801) 50 \u251c\u2500\u2500 README.md 51 \u251c\u2500\u2500 rust-toolchain 52 \u251c\u2500\u2500 tools 53 \u2502 \u251c\u2500\u2500 kflash.py 54 \u2502 \u251c\u2500\u2500 LICENSE 55 \u2502 \u251c\u2500\u2500 package.json 56 \u2502 \u251c\u2500\u2500 README.rst 57 \u2502 \u2514\u2500\u2500 setup.py 58 \u2514\u2500\u2500 user 59 \u251c\u2500\u2500 build.py(\u79fb\u9664) 60 \u251c\u2500\u2500 Cargo.toml 61 \u251c\u2500\u2500 Makefile 62 \u2514\u2500\u2500 src 63 \u251c\u2500\u2500 bin 64 \u2502 \u251c\u2500\u2500 00power_3.rs 65 \u2502 \u251c\u2500\u2500 01power_5.rs 66 \u2502 \u251c\u2500\u2500 02power_7.rs 67 \u2502 \u2514\u2500\u2500 03sleep.rs 68 \u251c\u2500\u2500 console.rs 69 \u251c\u2500\u2500 lang_items.rs 70 \u251c\u2500\u2500 lib.rs 71 \u251c\u2500\u2500 linker.ld(\u4fee\u6539\uff1a\u5c06\u6240\u6709\u5e94\u7528\u653e\u5728\u5404\u81ea\u5730\u5740\u7a7a\u95f4\u4e2d\u56fa\u5b9a\u7684\u4f4d\u7f6e) 72 \u2514\u2500\u2500 syscall.rs","title":"\u7b2c\u4e09\u7ae0\u4ee3\u7801\u6811"},{"location":"ch4%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/#_2","text":"\u672c\u8282\u5b9e\u73b0\u4e00\u4e2a\u652f\u6301 \u5bf9\u4e2d\u65ad\u7684\u5904\u7406\u548c\u5bf9\u5e94\u7528\u7a0b\u5e8f\u7684\u62a2\u5360\uff0c\u8bbe\u8ba1\u5b9e\u73b0\u66f4\u52a0\u516c\u5e73\u548c\u9ad8\u6548\u4ea4\u4e92\u7684\u62a2\u5360\u5f0f\u64cd\u4f5c\u7cfb\u7edf \u5f53\u5916\u8bbe\u60f3\u8981\u89e6\u53d1\u4e2d\u65ad\u7684\u65f6\u5019\u5219\u8f93\u5165\u4e00\u4e2a\u9ad8\u7535\u5e73\u6216\u6b63\u8fb9\u6cbf\uff0c\u5904\u7406\u5668\u4f1a\u5728\u6bcf\u6267\u884c\u5b8c\u4e00\u6761\u6307\u4ee4\u4e4b\u540e\u68c0\u67e5\u4e00\u4e0b\u8fd9\u6839\u7ebf\uff0c\u770b\u60c5\u51b5\u51b3\u5b9a\u662f\u7ee7\u7eed\u6267\u884c\u63a5\u4e0b\u6765\u7684\u6307\u4ee4\u8fd8\u662f\u8fdb\u5165\u4e2d\u65ad\u5904\u7406\u6d41\u7a0b \u672c\u7ae0\u7684\u64cd\u4f5c\u7cfb\u7edf\u652f\u6301\u628a\u591a\u4e2a\u5e94\u7528\u7684\u4ee3\u7801\u548c\u6570\u636e\u653e\u7f6e\u5230\u5185\u5b58\u4e2d\uff1b\u5e76\u80fd\u591f\u6267\u884c\u6bcf\u4e2a\u5e94\u7528\uff1b\u5728\u5e94\u7528\u7a0b\u5e8f\u53d1\u51fa sys_yeild \u7cfb\u7edf\u8c03\u7528\u65f6\uff0c\u534f\u4f5c\u5f0f\u5730\u5207\u6362\u5e94\u7528\uff1b\u5e76\u80fd\u901a\u8fc7\u65f6\u949f\u4e2d\u65ad\u6765\u5b9e\u73b0\u62a2\u5360\u5f0f\u8c03\u5ea6\u5e76\u5f3a\u884c\u5207\u6362\u5e94\u7528\uff0c\u4ece\u800c\u63d0\u9ad8\u4e86\u5e94\u7528\u6267\u884c\u7684\u7075\u6d3b\u6027\u3001\u516c\u5e73\u6027\u548c\u4ea4\u4e92\u6548\u7387\u3002","title":"\u672c\u8282\u7684\u4efb\u52a1"},{"location":"ch4%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/#_3","text":"","title":"\u672c\u8282\u6587\u4ef6\u89e3\u6790"},{"location":"ch4%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/#bootloader","text":"","title":"\u5728bootloader \u6587\u4ef6\u5939\u4e0b"},{"location":"ch4%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/#rustsbi-qemubin","text":"","title":"rustsbi-qemu.bin"},{"location":"ch4%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/#os","text":"","title":"\u5728 os \u6587\u4ef6\u5939\u4e0b"},{"location":"ch4%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/#oscargoconfig","text":"[build] target = \"riscv64gc-unknown-none-elf\" [target.riscv64gc-unknown-none-elf] rustflags = [ \"-Clink-arg=-Tsrc/linker.ld\", \"-Cforce-frame-pointers=yes\" ]","title":"os/.cargo/config"},{"location":"ch4%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/#osbuildrs","text":"use std::io::{Result, Write}; use std::fs::{File, read_dir}; fn main() { println!(\"cargo:rerun-if-changed=../user/src/\"); println!(\"cargo:rerun-if-changed={}\", TARGET_PATH); insert_app_data().unwrap(); } static TARGET_PATH: &str = \"../user/target/riscv64gc-unknown-none-elf/release/\"; fn insert_app_data() -> Result<()> { let mut f = File::create(\"src/link_app.S\").unwrap(); let mut apps: Vec<_> = read_dir(\"../user/src/bin\") .unwrap() .into_iter() .map(|dir_entry| { let mut name_with_ext = dir_entry.unwrap().file_name().into_string().unwrap(); name_with_ext.drain(name_with_ext.find('.').unwrap()..name_with_ext.len()); name_with_ext }) .collect(); apps.sort(); writeln!(f, r#\" .align 3 .section .data .global _num_app _num_app: .quad {}\"#, apps.len())?; for i in 0..apps.len() { writeln!(f, r#\" .quad app_{}_start\"#, i)?; } writeln!(f, r#\" .quad app_{}_end\"#, apps.len() - 1)?; for (idx, app) in apps.iter().enumerate() { println!(\"app_{}: {}\", idx, app); writeln!(f, r#\" .section .data .global app_{0}_start .global app_{0}_end app_{0}_start: .incbin \"{2}{1}.bin\" app_{0}_end:\"#, idx, app, TARGET_PATH)?; } Ok(()) }","title":"os/build.rs"},{"location":"ch4%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/#oscargotoml","text":"[package] name = \"os\" version = \"0.1.0\" authors = [\"Yifan Wu <shinbokuow@163.com>\"] edition = \"2018\" # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html [dependencies] riscv = { git = \"https://github.com/rcore-os/riscv\", features = [\"inline-asm\"] } lazy_static = { version = \"1.4.0\", features = [\"spin_no_std\"] } buddy_system_allocator = \"0.6\" # \u9700\u5c06\u6211\u4eec\u7684\u52a8\u6001\u5185\u5b58\u5206\u914d\u5668\u7c7b\u578b\u5b9e\u4f8b\u5316\u4e3a\u4e00\u4e2a\u5168\u5c40\u53d8\u91cf\uff0c\u5e76\u4f7f\u7528 #[global_allocator] \u8bed\u4e49\u9879\u6807\u8bb0\u5373\u53ef\u3002 # \u7531\u4e8e\u8be5\u5206\u914d\u5668\u7684\u5b9e\u73b0\u6bd4\u8f83\u590d\u6742\uff0c\u6211\u4eec\u8fd9\u91cc\u76f4\u63a5\u4f7f\u7528\u4e00\u4e2a\u5df2\u6709\u7684\u4f19\u4f34\u5206\u914d\u5668\u5b9e\u73b0 bitflags = \"1.2.1\" xmas-elf = \"0.7.0\" [features] board_qemu = [] board_k210 = []","title":"os/Cargo.toml"},{"location":"ch4%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/#ossrcconfigrs","text":"pub const USER_STACK_SIZE: usize = 4096 * 2; pub const KERNEL_STACK_SIZE: usize = 4096 * 2; pub const KERNEL_HEAP_SIZE: usize = 0x30_0000; pub const MEMORY_END: usize = 0x80800000; // \u6211\u4eec\u786c\u7f16\u7801\u6574\u5757\u7269\u7406\u5185\u5b58\u7684\u7ec8\u6b62\u7269\u7406\u5730\u5740\u4e3a 0x80800000 \u3002 // \u800c \u4e4b\u524d \u63d0\u5230\u8fc7\u7269\u7406\u5185\u5b58\u7684\u8d77\u59cb\u7269\u7406\u5730\u5740\u4e3a 0x80000000 \uff0c\u8fd9\u610f\u5473\u7740\u6211\u4eec\u5c06\u53ef\u7528\u5185\u5b58\u5927\u5c0f\u8bbe\u7f6e\u4e3a 8 MB pub const PAGE_SIZE: usize = 0x1000; pub const PAGE_SIZE_BITS: usize = 0xc; pub const TRAMPOLINE: usize = usize::MAX - PAGE_SIZE + 1; pub const TRAP_CONTEXT: usize = TRAMPOLINE - PAGE_SIZE; /// Return (bottom, top) of a kernel stack in kernel space. pub fn kernel_stack_position(app_id: usize) -> (usize, usize) { let top = TRAMPOLINE - app_id * (KERNEL_STACK_SIZE + PAGE_SIZE); let bottom = top - KERNEL_STACK_SIZE; (bottom, top) } #[cfg(feature = \"board_k210\")] pub const CLOCK_FREQ: usize = 403000000 / 62; #[cfg(feature = \"board_qemu\")] pub const CLOCK_FREQ: usize = 12500000;","title":"os/src/config.rs"},{"location":"ch4%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/#ossrcconsolers","text":"use core::fmt::{self, Write}; use crate::sbi::console_putchar; struct Stdout; impl Write for Stdout { fn write_str(&mut self, s: &str) -> fmt::Result { for c in s.chars() { console_putchar(c as usize); } Ok(()) } } pub fn print(args: fmt::Arguments) { Stdout.write_fmt(args).unwrap(); } #[macro_export] macro_rules! print { ($fmt: literal $(, $($arg: tt)+)?) => { $crate::console::print(format_args!($fmt $(, $($arg)+)?)); } } #[macro_export] macro_rules! println { ($fmt: literal $(, $($arg: tt)+)?) => { $crate::console::print(format_args!(concat!($fmt, \"\\n\") $(, $($arg)+)?)); } }","title":"os/src/console.rs"},{"location":"ch4%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/#ossrcentryasm","text":".section .text.entry .globl _start _start: la sp, boot_stack_top call rust_main .section .bss.stack .globl boot_stack boot_stack: .space 4096 * 16 .globl boot_stack_top boot_stack_top:","title":"os/src/entry.asm"},{"location":"ch4%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/#ossrclang_itemsrs","text":"use core::panic::PanicInfo; use crate::sbi::shutdown; #[panic_handler] fn panic(info: &PanicInfo) -> ! { if let Some(location) = info.location() { println!(\"[kernel] Panicked at {}:{} {}\", location.file(), location.line(), info.message().unwrap()); } else { println!(\"[kernel] Panicked: {}\", info.message().unwrap()); } shutdown() }","title":"os/src/lang_items.rs"},{"location":"ch4%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/#ossrclink_apps","text":".align 3 .section .data .global _num_app _num_app: .quad 3 .quad app_0_start .quad app_1_start .quad app_2_start .quad app_2_end .section .data .global app_0_start .global app_0_end app_0_start: .incbin \"../user/target/riscv64gc-unknown-none-elf/release/00write_a.bin\" app_0_end: .section .data .global app_1_start .global app_1_end app_1_start: .incbin \"../user/target/riscv64gc-unknown-none-elf/release/01write_b.bin\" app_1_end: .section .data .global app_2_start .global app_2_end app_2_start: .incbin \"../user/target/riscv64gc-unknown-none-elf/release/02write_c.bin\" app_2_end:","title":"os/src/link_app.S"},{"location":"ch4%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/#ossrclinker-qemuld","text":"OUTPUT_ARCH(riscv) ENTRY(_start) BASE_ADDRESS = 0x80200000; SECTIONS { . = BASE_ADDRESS; skernel = .; stext = .; .text : { *(.text.entry) . = ALIGN(4K); strampoline = .; *(.text.trampoline); . = ALIGN(4K); *(.text .text.*) } . = ALIGN(4K); etext = .; srodata = .; .rodata : { *(.rodata .rodata.*) *(.srodata .srodata.*) } . = ALIGN(4K); erodata = .; sdata = .; .data : { *(.data .data.*) *(.sdata .sdata.*) } . = ALIGN(4K); edata = .; sbss_with_stack = .; .bss : { *(.bss.stack) sbss = .; *(.bss .bss.*) *(.sbss .sbss.*) } . = ALIGN(4K); ebss = .; ekernel = .; /DISCARD/ : { *(.eh_frame) } }","title":"os/src/linker-qemu.ld"},{"location":"ch4%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/#ossrcsbirs","text":"#![allow(unused)] const SBI_SET_TIMER:usize = 0; const SBI_CONSOLE_PUTCHAR:usize = 1; const SBI_CONSOLE_GETCHAR:usize = 2; const SBI_CLEAR_IPI:usize = 3; const SBI_SEND_IPI:usize = 4; const SBI_REMOTE_FENCE_I:usize = 5; const SBI_REMOTE_SFENCE_VMA:usize = 6; const SBI_REMOTE_SFENCE_VMA_ASID:usize = 7; const SBI_SHUTDOWN:usize = 8; use core::arch::asm; #[inline(always)] fn sbi_call(which:usize, arg0:usize, arg1:usize, arg2: usize) -> usize{ let mut ret; unsafe{ asm!( \"ecall\", inlateout(\"x10\") arg0 => ret, in(\"x11\") arg1, in(\"x12\") arg2, in(\"x17\") which, ); } ret } pub fn console_putchar(c:usize){ sbi_call(SBI_CONSOLE_PUTCHAR, c, 0, 0); } pub fn console_getchar() -> usize { sbi_call(SBI_CONSOLE_GETCHAR, 0, 0, 0) } pub fn shutdown() -> ! { sbi_call(SBI_SHUTDOWN, 0, 0, 0); panic!(\"It should shutdown!\"); } pub fn set_timer(timer: usize) { sbi_call(SBI_SET_TIMER, timer, 0, 0); } // sbi \u5b50\u6a21\u5757\u6709\u4e00\u4e2a set_timer \u8c03\u7528\uff0c\u662f\u4e00\u4e2a\u7531 SEE \u63d0\u4f9b\u7684\u6807\u51c6 SBI \u63a5\u53e3\u51fd\u6570\uff0c\u5b83\u53ef\u4ee5\u7528\u6765\u8bbe\u7f6e mtimecmp \u7684\u503c\u3002","title":"os/src/sbi.rs"},{"location":"ch4%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/#ossrctimerrs","text":"use riscv::register::time; use crate::sbi::set_timer; pub fn get_time() -> usize{ time::read() } // timer \u5b50\u6a21\u5757\u7684 get_time \u51fd\u6570\u53ef\u4ee5\u53d6\u5f97\u5f53\u524d mtime \u8ba1\u6570\u5668\u7684\u503c\uff1b use crate::config::CLOCK_FREQ; const TICKS_PER_SEC: usize = 100; pub fn set_next_trigger() { set_timer(get_time() + CLOCK_FREQ / TICKS_PER_SEC); } // timer \u5b50\u6a21\u5757\u7684 set_next_trigger \u51fd\u6570\u5bf9 set_timer \u8fdb\u884c\u4e86\u5c01\u88c5\uff0c // \u5b83\u9996\u5148\u8bfb\u53d6\u5f53\u524d mtime \u7684\u503c\uff0c\u7136\u540e\u8ba1\u7b97\u51fa 10ms \u4e4b\u5185\u8ba1\u6570\u5668\u7684\u589e\u91cf\uff0c // \u518d\u5c06 mtimecmp \u8bbe\u7f6e\u4e3a\u4e8c\u8005\u7684\u548c\u3002\u8fd9\u6837\uff0c10ms \u4e4b\u540e\u4e00\u4e2a S \u7279\u6743\u7ea7\u65f6\u949f\u4e2d\u65ad\u5c31\u4f1a\u88ab\u89e6\u53d1\u3002 // \u81f3\u4e8e\u589e\u91cf\u7684\u8ba1\u7b97\u65b9\u5f0f\uff0c\u5e38\u6570 CLOCK_FREQ \u662f\u4e00\u4e2a\u9884\u5148\u83b7\u53d6\u5230\u7684\u5404\u5e73\u53f0\u4e0d\u540c\u7684\u65f6\u949f\u9891\u7387\uff0c // \u5355\u4f4d\u4e3a\u8d6b\u5179\uff0c\u4e5f\u5c31\u662f\u4e00\u79d2\u949f\u4e4b\u5185\u8ba1\u6570\u5668\u7684\u589e\u91cf\u3002\u5b83\u53ef\u4ee5\u5728 config \u5b50\u6a21\u5757\u4e2d\u627e\u5230\u3002 // CLOCK_FREQ \u9664\u4ee5\u5e38\u6570 TICKS_PER_SEC \u5373\u662f\u4e0b\u4e00\u6b21\u65f6\u949f\u4e2d\u65ad\u7684\u8ba1\u6570\u5668\u589e\u91cf\u503c\u3002 const MICRO_PRE_SEC: usize = 1_000_000; pub fn get_time_ms() -> usize { time::read() / (CLOCK_FREQ / MICRO_PRE_SEC) } // timer \u5b50\u6a21\u5757\u7684 get_time_us \u4ee5\u5fae\u79d2\u4e3a\u5355\u4f4d\u8fd4\u56de\u5f53\u524d\u8ba1\u6570\u5668\u7684\u503c\uff0c\u8fd9\u8ba9\u6211\u4eec\u7ec8\u4e8e\u80fd\u5bf9\u65f6\u95f4\u6709\u4e00\u4e2a\u5177\u4f53\u6982\u5ff5\u4e86","title":"os/src/timer.rs"},{"location":"ch4%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/#ossrcmmaddressrs","text":"Virtual Address (39bits) 38 12 11 0 Virtual Page Number Page Offset(\u9875\u5185\u504f\u79fb) VPN\uff1a27 Physical Address (56bits) 55 12 11 0 Physical Page Number Page Offsett(\u9875\u5185\u504f\u79fb ) PPN\uff1a44 // \u9875\u8868\u4e2d\u7684\u9875\u8868\u9879\u7684\u7d22\u5f15\u5176\u5b9e\u662f\u865a\u62df\u5730\u5740\u4e2d\u7684\u865a\u62df\u9875\u53f7\uff0c\u9875\u8868\u9879\u7684\u91cd\u8981\u5185\u5bb9\u662f\u7269\u7406\u5730\u5740\u7684\u7269\u7406\u9875\u5e27\u53f7\u3002 // \u4e3a\u4e86\u80fd\u591f\u7075\u6d3b\u5730\u5728\u865a\u62df\u5730\u5740\u3001\u7269\u7406\u5730\u5740\u3001\u865a\u62df\u9875\u53f7\u3001\u7269\u7406\u9875\u53f7\u4e4b\u95f4\u8fdb\u884c\u5404\u79cd\u8f6c\u6362 // \u8fd9\u91cc\u5b9e\u73b0\u4e86\u5404\u79cd\u8f6c\u6362\u51fd\u6570 use crate::config::{PAGE_SIZE, PAGE_SIZE_BITS}; use super::PageTableEntry; use core::fmt::{self, Debug, Formatter}; const PA_WIDTH_SV39: usize = 56; const VA_WIDTH_SV39: usize = 39; const PPN_WIDTH_SV39: usize = PA_WIDTH_SV39 - PAGE_SIZE_BITS; const VPN_WIDTH_SV39: usize = VA_WIDTH_SV39 - PAGE_SIZE_BITS; // \u5728\u5206\u9875\u5185\u5b58\u7ba1\u7406\u4e2d\uff0c\u5730\u5740\u8f6c\u6362\u7684\u6838\u5fc3\u4efb\u52a1\u5728\u4e8e\u5982\u4f55\u7ef4\u62a4\u865a\u62df\u9875\u53f7\u5230\u7269\u7406\u9875\u53f7\u7684\u6620\u5c04\u2014\u2014\u4e5f\u5c31\u662f\u9875\u8868\u3002 // \u4e0d\u8fc7\u5728\u5177\u4f53\u5b9e\u73b0\u5b83\u4e4b\u524d\uff0c\u6211\u4eec\u5148\u5c06\u5730\u5740\u548c\u9875\u53f7\u7684\u6982\u5ff5\u62bd\u8c61\u4e3a Rust \u4e2d\u7684\u7c7b\u578b\uff0c // \u501f\u52a9 Rust \u7684\u7c7b\u578b\u5b89\u5168\u7279\u6027\u6765\u786e\u4fdd\u5b83\u4eec\u88ab\u6b63\u786e\u5b9e\u73b0 /// Definitions #[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq)] pub struct PhysAddr(pub usize); #[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq)] pub struct VirtAddr(pub usize); #[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq)] pub struct PhysPageNum(pub usize); #[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq)] pub struct VirtPageNum(pub usize); // \u4e0a\u9762\u5206\u522b\u7ed9\u51fa\u4e86\u7269\u7406\u5730\u5740\u3001\u865a\u62df\u5730\u5740\u3001\u7269\u7406\u9875\u53f7\u3001\u865a\u62df\u9875\u53f7\u7684 Rust \u7c7b\u578b\u58f0\u660e\uff0c // \u5b83\u4eec\u90fd\u662f Rust \u7684\u5143\u7ec4\u5f0f\u7ed3\u6784\u4f53\uff0c\u53ef\u4ee5\u770b\u6210 usize \u7684\u4e00\u79cd\u7b80\u5355\u5305\u88c5\u3002 // \u6211\u4eec\u523b\u610f\u5c06\u5b83\u4eec\u5404\u81ea\u62bd\u8c61\u51fa\u4e0d\u540c\u7684\u7c7b\u578b\u800c\u4e0d\u662f\u90fd\u4f7f\u7528\u4e0eRISC-V 64\u786c\u4ef6\u76f4\u63a5\u5bf9\u5e94\u7684 usize \u57fa\u672c\u7c7b\u578b\uff0c // \u5c31\u662f\u4e3a\u4e86\u5728 Rust \u7f16\u8bd1\u5668\u7684\u5e2e\u52a9\u4e0b\uff0c\u901a\u8fc7\u591a\u79cd\u65b9\u4fbf\u4e14\u5b89\u5168\u7684 \u7c7b\u578b\u8f6c\u6362 (Type Convertion) \u6765\u6784\u5efa\u9875\u8868 /// Debugging impl Debug for VirtAddr { fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result { f.write_fmt(format_args!(\"VA:{:#x}\", self.0)) } } impl Debug for VirtPageNum { fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result { f.write_fmt(format_args!(\"VPN:{:#x}\", self.0)) } } impl Debug for PhysAddr { fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result { f.write_fmt(format_args!(\"PA:{:#x}\", self.0)) } } impl Debug for PhysPageNum { fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result { f.write_fmt(format_args!(\"PPN:{:#x}\", self.0)) } } /// T: {PhysAddr, VirtAddr, PhysPageNum, VirtPageNum} /// T -> usize: T.0 /// usize -> T: usize.into() // \u4e00\u822c\u800c\u8a00\uff0c\u5f53\u6211\u4eec\u4e3a\u7c7b\u578b U \u5b9e\u73b0\u4e86 From<T> Trait \u4e4b\u540e\uff0c // \u53ef\u4ee5\u4f7f\u7528 U::from(_: T) \u6765\u4ece\u4e00\u4e2a T \u7c7b\u578b\u7684\u5b9e\u4f8b\u6765\u6784\u9020\u4e00\u4e2a U \u7c7b\u578b\u7684\u5b9e\u4f8b\uff1b // \u800c\u5f53\u6211\u4eec\u4e3a\u7c7b\u578b U \u5b9e\u73b0\u4e86 Into<T> Trait \u4e4b\u540e\uff0c\u5bf9\u4e8e\u4e00\u4e2a U \u7c7b\u578b\u7684\u5b9e\u4f8b u \uff0c // \u53ef\u4ee5\u4f7f\u7528 u.into() \u6765\u5c06\u5176\u8f6c\u5316\u4e3a\u4e00\u4e2a\u7c7b\u578b\u4e3a T \u7684\u5b9e\u4f8b\u3002 // \u5f53\u6211\u4eec\u4e3a U \u5b9e\u73b0\u4e86 From<T> \u4e4b\u540e\uff0cRust \u4f1a\u81ea\u52a8\u4e3a T \u5b9e\u73b0 Into<U> Trait\uff0c // \u56e0\u4e3a\u5b83\u4eec\u4e24\u4e2a\u672c\u6765\u5c31\u662f\u5728\u505a\u76f8\u540c\u7684\u4e8b\u60c5\u3002\u56e0\u6b64\u6211\u4eec\u53ea\u9700\u76f8\u4e92\u5b9e\u73b0 From \u5c31\u53ef\u4ee5\u76f8\u4e92 From/Into \u4e86 // \u8fd9\u4e9b\u7c7b\u578b\u672c\u8eab\u53ef\u4ee5\u548c usize \u4e4b\u95f4\u4e92\u76f8\u8f6c\u6362 impl From<usize> for PhysAddr { fn from(v: usize) -> Self { Self(v & ( (1 << PA_WIDTH_SV39) - 1 )) } // \u548c 56 \u4e2a 1 \u76f8\u4e0e } impl From<usize> for PhysPageNum { fn from(v: usize) -> Self { Self(v & ( (1 << PPN_WIDTH_SV39) - 1 )) } } impl From<usize> for VirtAddr { fn from(v: usize) -> Self { Self(v & ( (1 << VA_WIDTH_SV39) - 1 )) } // \u548c 39 \u4e2a 1 \u76f8\u4e0e } impl From<usize> for VirtPageNum { fn from(v: usize) -> Self { Self(v & ( (1 << VPN_WIDTH_SV39) - 1 )) } } impl From<PhysAddr> for usize { fn from(v: PhysAddr) -> Self { v.0 } } impl From<PhysPageNum> for usize { fn from(v: PhysPageNum) -> Self { v.0 } } impl From<VirtAddr> for usize { fn from(v: VirtAddr) -> Self { v.0 } } impl From<VirtPageNum> for usize { fn from(v: VirtPageNum) -> Self { v.0 } } impl VirtAddr { // \u4ece\u7269\u7406\u9875\u53f7\u5230\u7269\u7406\u5730\u5740\u7684\u8f6c\u6362\u53ea\u9700\u5de6\u79fb \u4f4d\u5373\u53ef\uff0c // \u4f46\u662f\u7269\u7406\u5730\u5740\u9700\u8981\u4fdd\u8bc1\u5b83\u4e0e\u9875\u9762\u5927\u5c0f\u5bf9\u9f50\u624d\u80fd\u901a\u8fc7\u53f3\u79fb\u8f6c\u6362\u4e3a\u7269\u7406\u9875\u53f7\u3002 // \u5bf9\u4e8e\u4e0d\u5bf9\u9f50\u7684\u60c5\u51b5\uff0c\u7269\u7406\u5730\u5740\u4e0d\u80fd\u901a\u8fc7 From/Into \u8f6c\u6362\u4e3a\u7269\u7406\u9875\u53f7\uff0c // \u800c\u662f\u9700\u8981\u901a\u8fc7\u5b83\u81ea\u5df1\u7684 floor \u6216 ceil \u65b9\u6cd5\u6765\u8fdb\u884c\u4e0b\u53d6\u6574\u6216\u4e0a\u53d6\u6574\u7684\u8f6c\u6362 pub fn floor(&self) -> VirtPageNum { VirtPageNum(self.0 / PAGE_SIZE) } pub fn ceil(&self) -> VirtPageNum { VirtPageNum((self.0 - 1 + PAGE_SIZE) / PAGE_SIZE) } pub fn page_offset(&self) -> usize { self.0 & (PAGE_SIZE - 1) } pub fn aligned(&self) -> bool { self.page_offset() == 0 } } impl From<VirtAddr> for VirtPageNum { fn from(v: VirtAddr) -> Self { assert_eq!(v.page_offset(), 0); v.floor() } } impl From<VirtPageNum> for VirtAddr { fn from(v: VirtPageNum) -> Self { Self(v.0 << PAGE_SIZE_BITS) } // 12 } impl PhysAddr { pub fn floor(&self) -> PhysPageNum { PhysPageNum(self.0 / PAGE_SIZE) } // \u6574\u9664 pub fn ceil(&self) -> PhysPageNum { PhysPageNum((self.0 - 1 + PAGE_SIZE) / PAGE_SIZE) } // 4096 pub fn page_offset(&self) -> usize { self.0 & (PAGE_SIZE - 1) } // \u4e0e 12 \u4e2a 1 \u76f8\u4e0e pub fn aligned(&self) -> bool { self.page_offset() == 0 } } // \u5730\u5740\u548c\u9875\u53f7\u4e4b\u95f4\u53ef\u4ee5\u76f8\u4e92\u8f6c\u6362 impl From<PhysAddr> for PhysPageNum { fn from(v: PhysAddr) -> Self { assert_eq!(v.page_offset(), 0); // \u4f46\u662f\u7269\u7406\u5730\u5740\u9700\u8981\u4fdd\u8bc1\u5b83\u4e0e\u9875\u9762\u5927\u5c0f\u5bf9\u9f50\u624d\u80fd\u901a\u8fc7\u53f3\u79fb\u8f6c\u6362\u4e3a\u7269\u7406\u9875\u53f7 // \u5373\u9700\u8981\u4fdd\u8bc1\u8fd9\u4e2a\u5730\u5740\u662f\u4e00\u4e2a\u9875\u7684\u5f00\u5934\uff0c\u5373\u672b\u5c3e12\u4f4d\u4e3a 0 v.floor() } } // \u4ece\u7269\u7406\u9875\u53f7\u5230\u7269\u7406\u5730\u5740\u7684\u8f6c\u6362\u53ea\u9700\u5de6\u79fb12\u4f4d\u5373\u53ef\uff0c impl From<PhysPageNum> for PhysAddr { fn from(v: PhysPageNum) -> Self { Self(v.0 << PAGE_SIZE_BITS) } // 12 } impl VirtPageNum { // \u53ef\u4ee5\u53d6\u51fa\u865a\u62df\u9875\u53f7\u7684\u4e09\u7ea7\u9875\u7d22\u5f15\uff0c\u5e76\u6309\u7167\u4ece\u9ad8\u5230\u4f4e\u7684\u987a\u5e8f\u8fd4\u56de\u3002\u6ce8\u610f\u5b83\u91cc\u9762\u5305\u88f9\u7684 usize \u53ef\u80fd\u6709 27 \u4f4d\uff0c // \u4e5f\u6709\u53ef\u80fd\u6709 64 - 12 = 52 \u4f4d\uff0c\u4f46\u8fd9\u91cc\u6211\u4eec\u662f\u7528\u6765\u5728\u591a\u7ea7\u9875\u8868\u4e0a\u8fdb\u884c\u904d\u5386\uff0c\u56e0\u6b64\u53ea\u53d6\u51fa\u4f4e 27 \u4f4d\u3002 pub fn indexes(&self) -> [usize; 3] { let mut vpn = self.0; let mut idx = [0usize; 3]; for i in (0..3).rev() { // \u6ce8\u610f\uff1a\u8fd9\u91cc\u662f\u9006\u5e8f\u5b58\u653e // \u5148\u653e \u7b2c\u4e09\u7ea7\u5730\u5740\uff0c\u5b58\u653e\u7684\u662f\u4e0b\u4e00\u4e2a\u76ee\u5f55\u7684\u5730\u5740 idx[i] = vpn & 511; // 9 \u4e2a 1 vpn >>= 9; } idx } } // \u6211\u4eec\u6784\u9020\u53ef\u53d8\u5f15\u7528\u6765\u76f4\u63a5\u8bbf\u95ee\u4e00\u4e2a\u7269\u7406\u9875\u53f7 PhysPageNum \u5bf9\u5e94\u7684\u7269\u7406\u9875\u5e27\uff0c // \u4e0d\u540c\u7684\u5f15\u7528\u7c7b\u578b\u5bf9\u5e94\u4e8e\u7269\u7406\u9875\u5e27\u4e0a\u7684\u4e00\u79cd\u4e0d\u540c\u7684\u5185\u5b58\u5e03\u5c40 impl PhysPageNum { // get_pte_array \u8fd4\u56de\u7684\u662f\u4e00\u4e2a\u9875\u8868\u9879\u5b9a\u957f\u6570\u7ec4\u7684\u53ef\u53d8\u5f15\u7528\uff0c\u4ee3\u8868\u591a\u7ea7\u9875\u8868\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9 pub fn get_pte_array(&self) -> &'static mut [PageTableEntry] { let pa: PhysAddr = self.clone().into(); // \u90fd\u662f\u5148\u628a\u7269\u7406\u9875\u53f7\u8f6c\u4e3a\u7269\u7406\u5730\u5740 PhysAddr \uff0c\u7136\u540e\u518d\u8f6c\u6210 usize \u5f62\u5f0f\u7684\u7269\u7406\u5730\u5740 unsafe { core::slice::from_raw_parts_mut(pa.0 as *mut PageTableEntry, 512) // \u6211\u4eec\u76f4\u63a5\u5c06\u5b83\u8f6c\u4e3a\u88f8\u6307\u9488\u7528\u6765\u8bbf\u95ee\u7269\u7406\u5730\u5740\u6307\u5411\u7684\u7269\u7406\u5185\u5b58\u3002 // \u5728\u5206\u9875\u673a\u5236\u5f00\u542f\u524d\uff0c\u8fd9\u6837\u505a\u81ea\u7136\u6210\u7acb\uff1b\u800c\u5f00\u542f\u4e4b\u540e\uff0c\u867d\u7136\u88f8\u6307\u9488\u88ab\u89c6\u4e3a\u4e00\u4e2a\u865a\u62df\u5730\u5740\uff0c // \u4f46\u662f\u4e0a\u9762\u5df2\u7ecf\u63d0\u5230\uff0c\u57fa\u4e8e\u6052\u7b49\u6620\u5c04\uff0c\u865a\u62df\u5730\u5740\u4f1a\u6620\u5c04\u5230\u4e00\u4e2a\u76f8\u540c\u7684\u7269\u7406\u5730\u5740\uff0c // \u56e0\u6b64\u5728\u4e5f\u662f\u6210\u7acb\u7684\u3002\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fd4\u56de\u503c\u7c7b\u578b\u4e0a\u9644\u52a0\u4e86\u9759\u6001\u751f\u547d\u5468\u671f\u6cdb\u578b 'static \uff0c // \u8fd9\u662f\u4e3a\u4e86\u7ed5\u8fc7 Rust \u7f16\u8bd1\u5668\u7684\u501f\u7528\u68c0\u67e5\uff0c\u5b9e\u8d28\u4e0a\u53ef\u4ee5\u5c06\u8fd4\u56de\u7684\u7c7b\u578b\u4e5f\u770b\u6210\u4e00\u4e2a\u88f8\u6307\u9488\uff0c // \u56e0\u4e3a\u5b83\u4e5f\u53ea\u662f\u6807\u8bc6\u6570\u636e\u5b58\u653e\u7684\u4f4d\u7f6e\u4ee5\u53ca\u7c7b\u578b\u3002\u4f46\u4e0e\u88f8\u6307\u9488\u4e0d\u540c\u7684\u662f\uff0c // \u65e0\u9700\u901a\u8fc7 unsafe \u7684\u89e3\u5f15\u7528\u8bbf\u95ee\u5b83\u6307\u5411\u7684\u6570\u636e\uff0c\u800c\u662f\u53ef\u4ee5\u50cf\u4e00\u4e2a\u6b63\u5e38\u7684\u53ef\u53d8\u5f15\u7528\u4e00\u6837\u76f4\u63a5\u8bbf\u95ee } } // get_bytes_array \u8fd4\u56de\u7684\u662f\u4e00\u4e2a\u5b57\u8282\u6570\u7ec4\u7684\u53ef\u53d8\u5f15\u7528\uff0c\u53ef\u4ee5\u4ee5\u5b57\u8282\u4e3a\u7c92\u5ea6\u5bf9\u7269\u7406\u9875\u5e27\u4e0a\u7684\u6570\u636e\u8fdb\u884c\u8bbf\u95ee\uff0c // \u524d\u9762\u8fdb\u884c\u6570\u636e\u6e05\u96f6\u5c31\u7528\u5230\u4e86\u8fd9\u4e2a\u65b9\u6cd5 pub fn get_bytes_array(&self) -> &'static mut [u8] { // \u6211\u4eec\u5728\u8fd4\u56de\u503c\u7c7b\u578b\u4e0a\u9644\u52a0\u4e86\u9759\u6001\u751f\u547d\u5468\u671f\u6cdb\u578b 'static \uff0c\u8fd9\u662f\u4e3a\u4e86\u7ed5\u8fc7 Rust \u7f16\u8bd1\u5668\u7684\u501f\u7528\u68c0\u67e5\uff0c // \u5b9e\u8d28\u4e0a\u53ef\u4ee5\u5c06\u8fd4\u56de\u7684\u7c7b\u578b\u4e5f\u770b\u6210\u4e00\u4e2a\u88f8\u6307\u9488\uff0c\u56e0\u4e3a\u5b83\u4e5f\u53ea\u662f\u6807\u8bc6\u6570\u636e\u5b58\u653e\u7684\u4f4d\u7f6e\u4ee5\u53ca\u7c7b\u578b\u3002 // \u4f46\u4e0e\u88f8\u6307\u9488\u4e0d\u540c\u7684\u662f\uff0c\u65e0\u9700\u901a\u8fc7 unsafe \u7684\u89e3\u5f15\u7528\u8bbf\u95ee\u5b83\u6307\u5411\u7684\u6570\u636e\uff0c // \u800c\u662f\u53ef\u4ee5\u50cf\u4e00\u4e2a\u6b63\u5e38\u7684\u53ef\u53d8\u5f15\u7528\u4e00\u6837\u76f4\u63a5\u8bbf\u95ee let pa: PhysAddr = self.clone().into(); // \u5148\u5c06\u7269\u7406\u9875\u53f7 \u8f6c\u6362\u4e3a \u7269\u7406\u5730\u5740 unsafe { core::slice::from_raw_parts_mut(pa.0 as *mut u8, 4096) // \u518d\u8f6c\u6210 usize \u5f62\u5f0f\u7684\u7269\u7406\u5730\u5740\uff0c\u76f4\u63a5\u5c06\u5b83\u8f6c\u4e3a\u88f8\u6307\u9488\u7528\u6765\u8bbf\u95ee\u7269\u7406\u5730\u5740\u6307\u5411\u7684\u7269\u7406\u5185\u5b58 } } // get_mut \u662f\u4e2a\u6cdb\u578b\u51fd\u6570\uff0c\u53ef\u4ee5\u83b7\u53d6\u4e00\u4e2a\u6070\u597d\u653e\u5728\u4e00\u4e2a\u7269\u7406\u9875\u5e27\u5f00\u5934\u7684\u7c7b\u578b\u4e3a T \u7684\u6570\u636e\u7684\u53ef\u53d8\u5f15\u7528 pub fn get_mut<T>(&self) -> &'static mut T { let pa: PhysAddr = self.clone().into(); // \u5148\u5c06\u7269\u7406\u9875\u53f7 \u8f6c\u6362\u4e3a \u7269\u7406\u5730\u5740 unsafe { (pa.0 as *mut T).as_mut().unwrap() } } } pub trait StepByOne { fn step(&mut self); } impl StepByOne for VirtPageNum { fn step(&mut self) { self.0 += 1; } } #[derive(Copy, Clone)] pub struct SimpleRange<T> where T: StepByOne + Copy + PartialEq + PartialOrd + Debug, { l: T, r: T, } impl<T> SimpleRange<T> where T: StepByOne + Copy + PartialEq + PartialOrd + Debug, { pub fn new(start: T, end: T) -> Self { assert!(start <= end, \"start {:?} > end {:?}!\", start, end); Self { l: start, r: end } } pub fn get_start(&self) -> T { self.l } pub fn get_end(&self) -> T { self.r } } impl<T> IntoIterator for SimpleRange<T> where T: StepByOne + Copy + PartialEq + PartialOrd + Debug, { type Item = T; type IntoIter = SimpleRangeIterator<T>; fn into_iter(self) -> Self::IntoIter { SimpleRangeIterator::new(self.l, self.r) } } pub struct SimpleRangeIterator<T> where T: StepByOne + Copy + PartialEq + PartialOrd + Debug, { current: T, end: T, } impl<T> SimpleRangeIterator<T> where T: StepByOne + Copy + PartialEq + PartialOrd + Debug, { pub fn new(l: T, r: T) -> Self { Self { current: l, end: r, } } } impl<T> Iterator for SimpleRangeIterator<T> where T: StepByOne + Copy + PartialEq + PartialOrd + Debug, { type Item = T; fn next(&mut self) -> Option<Self::Item> { if self.current == self.end { None } else { let t = self.current; self.current.step(); Some(t) } } } pub type VPNRange = SimpleRange<VirtPageNum>;","title":"os/src/mm/address.rs"},{"location":"ch4%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/#ossrcmmframe_allocatorrs","text":"// \u64cd\u4f5c\u7cfb\u7edf\u5982\u679c\u8981\u5efa\u7acb\u9875\u8868\uff08\u6784\u5efa\u865a\u5b9e\u5730\u5740\u6620\u5c04\u5173\u7cfb\uff09\uff0c\u9996\u5148\u8981\u80fd\u7ba1\u7406\u6574\u4e2a\u7cfb\u7edf\u7684\u7269\u7406\u5185\u5b58\uff0c // \u8fd9\u5c31\u9700\u8981\u77e5\u9053\u6574\u4e2a\u8ba1\u7b97\u673a\u7cfb\u7edf\u7684\u7269\u7406\u5185\u5b58\u7a7a\u95f4\u7684\u8303\u56f4\uff0c\u7269\u7406\u5185\u5b58\u4e2d\u54ea\u4e9b\u533a\u57df\u662f\u7a7a\u95f2\u53ef\u7528\u7684\uff0c // \u54ea\u4e9b\u533a\u57df\u653e\u7f6e\u5185\u6838/\u5e94\u7528\u7684\u4ee3\u7801\u548c\u6570\u636e\u3002\u64cd\u4f5c\u7cfb\u7edf\u5185\u6838\u80fd\u591f\u4ee5\u7269\u7406\u9875\u5e27\u4e3a\u5355\u4f4d\u5206\u914d\u548c\u56de\u6536\u7269\u7406\u5185\u5b58 use super::{PhysAddr, PhysPageNum}; use alloc::vec::Vec; use crate::sync::UPSafeCell; use crate::config::MEMORY_END; use lazy_static::*; use core::fmt::{self, Debug, Formatter}; // \u6211\u4eec\u58f0\u660e\u4e00\u4e2a FrameAllocator Trait \u6765\u63cf\u8ff0\u4e00\u4e2a\u7269\u7406\u9875\u5e27\u7ba1\u7406\u5668\u9700\u8981\u63d0\u4f9b\u54ea\u4e9b\u529f\u80fd trait FrameAllocator { fn new() -> Self; fn alloc(&mut self) -> Option<PhysPageNum>; fn dealloc(&mut self, ppn: PhysPageNum); } pub struct FrameTracker { pub ppn: PhysPageNum, } impl FrameTracker { pub fn new(ppn: PhysPageNum) -> Self { // page cleaning let bytes_array = ppn.get_bytes_array(); // ppn \u662f\u4e00\u4e2a\u7ed3\u6784\u4f53\uff0c\u5143\u7ec4\u7ed3\u6784\u4f53\uff0c\u91cc\u9762\u662f\u4e2a usize \u7c7b\u578b\u7684\u6574\u6570 // \u5b83\u6709\u4e2a get_bytes_array \u65b9\u6cd5\uff0c\u8fd4\u56de\u4e00\u4e2a\u5b57\u8282\u6570\u7ec4\u7684\u53ef\u53d8\u5f15\u7528\uff0c // \u8fd4\u56de\u4e00\u4e2a\u6307\u9488\uff0c\u6307\u5411\u5b83\u6240\u5bf9\u5e94\u7684\u7269\u7406\u9875\u7684\u5730\u5740 // \u4ee5\u4ee5\u5b57\u8282\u4e3a\u7c92\u5ea6\u5bf9\u7269\u7406\u9875\u5e27\u4e0a\u7684\u6570\u636e\u8fdb\u884c\u8bbf\u95ee for i in bytes_array { *i = 0; } // \u6211\u4eec\u5c06\u5206\u914d\u6765\u7684\u7269\u7406\u9875\u5e27\u7684\u7269\u7406\u9875\u53f7\u4f5c\u4e3a\u53c2\u6570\u4f20\u7ed9 FrameTracker \u7684 new \u65b9\u6cd5\u6765\u521b\u5efa\u4e00\u4e2a FrameTracker \u5b9e\u4f8b\u3002 // \u7531\u4e8e\u8fd9\u4e2a\u7269\u7406\u9875\u5e27\u4e4b\u524d\u53ef\u80fd\u88ab\u5206\u914d\u8fc7\u5e76\u7528\u505a\u5176\u4ed6\u7528\u9014\uff0c\u6211\u4eec\u5728\u8fd9\u91cc\u76f4\u63a5\u5c06\u8fd9\u4e2a\u7269\u7406\u9875\u5e27\u4e0a\u7684\u6240\u6709\u5b57\u8282\u6e05\u96f6 Self { ppn } } } impl Debug for FrameTracker { fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result { f.write_fmt(format_args!(\"FrameTracker:PPN={:#x}\", self.ppn.0)) } } impl Drop for FrameTracker { fn drop(&mut self) { frame_dealloc(self.ppn); } // \u5f53\u4e00\u4e2a FrameTracker \u751f\u547d\u5468\u671f\u7ed3\u675f\u88ab\u7f16\u8bd1\u5668\u56de\u6536\u7684\u65f6\u5019\uff0c\u6211\u4eec\u9700\u8981\u5c06\u5b83\u63a7\u5236\u7684\u7269\u7406\u9875\u5e27\u56de\u6536\u6389 // \u8fd9\u91cc\u6211\u4eec\u53ea\u9700\u4e3a FrameTracker \u5b9e\u73b0 Drop Trait \u5373\u53ef\u3002\u5f53\u4e00\u4e2a FrameTracker \u5b9e\u4f8b\u88ab\u56de\u6536\u7684\u65f6\u5019\uff0c // \u5b83\u7684 drop \u65b9\u6cd5\u4f1a\u81ea\u52a8\u88ab\u7f16\u8bd1\u5668\u8c03\u7528\uff0c // \u901a\u8fc7\u4e4b\u524d\u5b9e\u73b0\u7684 frame_dealloc \u6211\u4eec\u5c31\u5c06\u5b83\u63a7\u5236\u7684\u7269\u7406\u9875\u5e27\u56de\u6536\u4ee5\u4f9b\u540e\u7eed\u4f7f\u7528\u4e86 } // \u5b9e\u73b0\u4e00\u79cd\u6700\u7b80\u5355\u7684\u6808\u5f0f\u7269\u7406\u9875\u5e27\u7ba1\u7406\u7b56\u7565 StackFrameAllocator pub struct StackFrameAllocator { current: usize, end: usize, // \u7269\u7406\u9875\u53f7\u533a\u95f4 [ current , end ) \u6b64\u524d\u5747 \u4ece\u672a \u88ab\u5206\u914d\u51fa\u53bb\u8fc7 recycled: Vec<usize>, // \u5411\u91cf recycled \u4ee5\u540e\u5165\u5148\u51fa\u7684\u65b9\u5f0f\u4fdd\u5b58\u4e86\u88ab\u56de\u6536\u7684\u7269\u7406\u9875\u53f7 } impl StackFrameAllocator { pub fn init(&mut self, l: PhysPageNum, r: PhysPageNum) { self.current = l.0; self.end = r.0; } // \u800c\u5728\u5b83\u771f\u6b63\u88ab\u4f7f\u7528\u8d77\u6765\u4e4b\u524d\uff0c\u9700\u8981\u8c03\u7528 init \u65b9\u6cd5\u5c06\u81ea\u8eab\u7684 [current, end) \u521d\u59cb\u5316\u4e3a\u53ef\u7528\u7269\u7406\u9875\u53f7\u533a\u95f4 } impl FrameAllocator for StackFrameAllocator { fn new() -> Self { Self { current: 0, end: 0, recycled: Vec::new(), } } // \u521d\u59cb\u5316\u975e\u5e38\u7b80\u5355\u3002\u5728\u901a\u8fc7 FrameAllocator \u7684 new \u65b9\u6cd5\u521b\u5efa\u5b9e\u4f8b\u7684\u65f6\u5019\uff0c\u53ea\u9700\u5c06\u533a\u95f4\u4e24\u7aef\u5747\u8bbe\u4e3a \uff0c\u7136\u540e\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u5411\u91cf fn alloc(&mut self) -> Option<PhysPageNum> { if let Some(ppn) = self.recycled.pop() { // \u5728\u5206\u914d alloc \u7684\u65f6\u5019\uff0c\u9996\u5148\u4f1a\u68c0\u67e5\u6808 recycled \u5185\u6709\u6ca1\u6709\u4e4b\u524d\u56de\u6536\u7684\u7269\u7406\u9875\u53f7\uff0c // \u5982\u679c\u6709\u7684\u8bdd\u76f4\u63a5\u5f39\u51fa\u6808\u9876\u5e76\u8fd4\u56de Some(ppn.into()) } else { if self.current == self.end { None // \u6781\u7aef\u60c5\u51b5\u4e0b\u53ef\u80fd\u51fa\u73b0\u5185\u5b58\u8017\u5c3d\u5206\u914d\u5931\u8d25\u7684\u60c5\u51b5\uff1a\u5373 recycled \u4e3a\u7a7a\u4e14 current == end // \u4e3a\u4e86\u6db5\u76d6\u8fd9\u79cd\u60c5\u51b5\uff0c alloc \u7684\u8fd4\u56de\u503c\u88ab Option \u5305\u88f9\uff0c\u6211\u4eec\u8fd4\u56de None \u5373\u53ef } else { self.current += 1; Some((self.current - 1).into()) // \u5426\u5219\u7684\u8bdd\u6211\u4eec\u53ea\u80fd\u4ece\u4e4b\u524d\u4ece\u672a\u5206\u914d\u8fc7\u7684\u7269\u7406\u9875\u53f7\u533a\u95f4 [ current , end ) \u4e0a\u8fdb\u884c\u5206\u914d\uff0c // \u6211\u4eec\u5206\u914d\u5b83\u7684\u5de6\u7aef\u70b9 current \uff0c\u540c\u65f6\u5c06\u7ba1\u7406\u5668\u5185\u90e8\u7ef4\u62a4\u7684 current \u52a0 1 \u4ee3\u8868 current \u5df2\u88ab\u5206\u914d\u4e86\u3002 // \u5728\u5373\u5c06\u8fd4\u56de\u7684\u65f6\u5019\uff0c\u6211\u4eec\u4f7f\u7528 into \u65b9\u6cd5\u5c06 usize \u8f6c\u6362\u6210\u4e86\u7269\u7406\u9875\u53f7 PhysPageNum } } } fn dealloc(&mut self, ppn: PhysPageNum) // \u5143\u7ec4\u7c7b\u578b // \u5728\u56de\u6536 dealloc \u7684\u65f6\u5019\uff0c\u6211\u4eec\u9700\u8981\u68c0\u67e5\u56de\u6536\u9875\u9762\u7684\u5408\u6cd5\u6027\uff0c\u7136\u540e\u5c06\u5176\u538b\u5165 recycled \u6808\u4e2d let ppn = ppn.0; // validity check // \u8be5\u9875\u9762\u4e4b\u524d\u4e00\u5b9a\u88ab\u5206\u914d\u51fa\u53bb\u8fc7\uff0c\u56e0\u6b64\u5b83\u7684\u7269\u7406\u9875\u53f7\u4e00\u5b9a current \uff1b // \u8be5\u9875\u9762\u6ca1\u6709\u6b63\u5904\u5728\u56de\u6536\u72b6\u6001\uff0c\u5373\u5b83\u7684\u7269\u7406\u9875\u53f7\u4e0d\u80fd\u5728\u6808 recycled \u4e2d\u627e\u5230 if ppn >= self.current || self.recycled .iter() .find(|&v| {*v == ppn}) .is_some() { panic!(\"Frame ppn={:#x} has not been allocated!\", ppn); // \u6211\u4eec\u901a\u8fc7 recycled.iter() \u83b7\u53d6\u6808\u4e0a\u5185\u5bb9\u7684\u8fed\u4ee3\u5668\uff0c // \u7136\u540e\u901a\u8fc7\u8fed\u4ee3\u5668\u7684 find \u65b9\u6cd5\u8bd5\u56fe\u5bfb\u627e\u4e00\u4e2a\u4e0e\u8f93\u5165\u7269\u7406\u9875\u53f7\u76f8\u540c\u7684\u5143\u7d20\u3002 // \u5176\u8fd4\u56de\u503c\u662f\u4e00\u4e2a Option \uff0c\u5982\u679c\u627e\u5230\u4e86\u5c31\u4f1a\u662f\u4e00\u4e2a Option::Some \uff0c // \u8fd9\u79cd\u60c5\u51b5\u8bf4\u660e\u6211\u4eec\u5185\u6838\u5176\u4ed6\u90e8\u5206\u5b9e\u73b0\u6709\u8bef\uff0c\u76f4\u63a5\u62a5\u9519\u9000\u51fa } // recycle self.recycled.push(ppn); } } type FrameAllocatorImpl = StackFrameAllocator; lazy_static! { // \u8fd9\u91cc\u6211\u4eec\u4f7f\u7528 UPSafeCell<T> \u6765\u5305\u88f9\u6808\u5f0f\u7269\u7406\u9875\u5e27\u5206\u914d\u5668\u3002\u6bcf\u6b21\u5bf9\u8be5\u5206\u914d\u5668\u8fdb\u884c\u64cd\u4f5c\u4e4b\u524d\uff0c // \u6211\u4eec\u90fd\u9700\u8981\u5148\u901a\u8fc7 FRAME_ALLOCATOR.exclusive_access() \u62ff\u5230\u5206\u914d\u5668\u7684\u53ef\u53d8\u501f\u7528 pub static ref FRAME_ALLOCATOR: UPSafeCell<FrameAllocatorImpl> = unsafe { // \u5b83\u7684\u672c\u8d28\u662f\u4e00\u4e2a\u6307\u9488\uff0c\u4e00\u4e2a\u5f15\u7528\uff0c \u6307\u5411\u7684\u662f FrameAllocatorImpl \u7c7b\u578b // \u5373 StackFrameAllocator \u7c7b\u578b UPSafeCell::new(FrameAllocatorImpl::new()) // \u521b\u5efa StackFrameAllocator \u7684\u5b9e\u4f8b\uff0c\u5e76\u521b\u5efa\u5b83\u7684\u5f15\u7528 \u518d \u8fd4\u56de\u51fa\u53bb }; } pub fn init_frame_allocator() { extern \"C\" { fn ekernel(); } // \u5728\u6b63\u5f0f\u5206\u914d\u7269\u7406\u9875\u5e27\u4e4b\u524d\uff0c\u6211\u4eec\u9700\u8981\u5c06\u7269\u7406\u9875\u5e27\u5168\u5c40\u7ba1\u7406\u5668 FRAME_ALLOCATOR \u521d\u59cb\u5316 FRAME_ALLOCATOR .exclusive_access() // \u62ff\u5230\u5206\u914d\u5668\u7684 \u53ef\u53d8\u501f\u7528 .init(PhysAddr::from(ekernel as usize).ceil(), PhysAddr::from(MEMORY_END).floor()); // \u8fd9\u91cc\u6211\u4eec\u8c03\u7528\u7269\u7406\u5730\u5740 PhysAddr \u7684 floor/ceil \u65b9\u6cd5\u5206\u522b\u4e0b/\u4e0a\u53d6\u6574\u83b7\u5f97\u53ef\u7528\u7684\u7269\u7406\u9875\u53f7\u533a\u95f4 } // \u7136\u540e\u662f\u516c\u5f00\u7ed9\u5176\u4ed6\u5185\u6838\u6a21\u5757\u8c03\u7528\u7684\u5206\u914d/\u56de\u6536\u7269\u7406\u9875\u5e27\u7684\u63a5\u53e3 pub fn frame_alloc() -> Option<FrameTracker> { FRAME_ALLOCATOR .exclusive_access() .alloc() .map(|ppn| FrameTracker::new(ppn)) // \u53ef\u4ee5\u53d1\u73b0\uff0c frame_alloc \u7684\u8fd4\u56de\u503c\u7c7b\u578b\u5e76\u4e0d\u662f FrameAllocator \u8981\u6c42\u7684\u7269\u7406\u9875\u53f7 PhysPageNum \uff0c // \u800c\u662f\u5c06\u5176\u8fdb\u4e00\u6b65\u5305\u88c5\u4e3a\u4e00\u4e2a FrameTracker \u3002\u8fd9\u91cc\u501f\u7528\u4e86 RAII \u7684\u601d\u60f3\uff0c // \u5c06\u4e00\u4e2a\u7269\u7406\u9875\u5e27\u7684\u751f\u547d\u5468\u671f\u7ed1\u5b9a\u5230\u4e00\u4e2a FrameTracker \u53d8\u91cf\u4e0a\uff0c // \u5f53\u4e00\u4e2a FrameTracker \u88ab\u521b\u5efa\u7684\u65f6\u5019\uff0c\u6211\u4eec\u9700\u8981\u4ece FRAME_ALLOCATOR \u4e2d\u5206\u914d\u4e00\u4e2a\u7269\u7406\u9875\u5e27 } fn frame_dealloc(ppn: PhysPageNum) { FRAME_ALLOCATOR .exclusive_access() .dealloc(ppn); } #[allow(unused)] pub fn frame_allocator_test() { let mut v: Vec<FrameTracker> = Vec::new(); for i in 0..5 { let frame = frame_alloc().unwrap(); println!(\"{:?}\", frame); v.push(frame); } v.clear(); for i in 0..5 { let frame = frame_alloc().unwrap(); println!(\"{:?}\", frame); v.push(frame); } drop(v); println!(\"frame_allocator_test passed!\"); }","title":"os/src/mm/frame_allocator.rs"},{"location":"ch4%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/#ossrcmmheap_allocatorrs","text":"use buddy_system_allocator::LockedHeap; use crate::config::KERNEL_HEAP_SIZE; #[global_allocator] static HEAP_ALLOCATOR: LockedHeap = LockedHeap::empty(); // \u6211\u4eec\u76f4\u63a5\u5c06 buddy_system_allocator \u4e2d\u63d0\u4f9b\u7684 LockedHeap \u5b9e\u4f8b\u5316\u6210\u4e00\u4e2a\u5168\u5c40\u53d8\u91cf\uff0c // \u5e76\u4f7f\u7528 alloc \u8981\u6c42\u7684 #[global_allocator] \u8bed\u4e49\u9879\u8fdb\u884c\u6807\u8bb0\u3002 // \u6ce8\u610f LockedHeap \u5df2\u7ecf\u5b9e\u73b0\u4e86 GlobalAlloc \u8981\u6c42\u7684\u62bd\u8c61\u63a5\u53e3\u4e86 // // alloc::alloc::GlobalAlloc // pub unsafe fn alloc(&self, layout: Layout) -> *mut u8; // pub unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout); // \u5b83\u4eec\u7c7b\u4f3c C \u8bed\u8a00\u4e2d\u7684 malloc/free \uff0c\u5206\u522b\u4ee3\u8868\u5806\u7a7a\u95f4\u7684\u5206\u914d\u548c\u56de\u6536\uff0c // \u4e5f\u540c\u6837\u4f7f\u7528\u4e00\u4e2a\u88f8\u6307\u9488\uff08\u4e5f\u5c31\u662f\u5730\u5740\uff09\u4f5c\u4e3a\u5206\u914d\u7684\u8fd4\u56de\u503c\u548c\u56de\u6536\u7684\u53c2\u6570\u3002\u4e24\u4e2a\u63a5\u53e3\u4e2d\u90fd\u6709\u4e00\u4e2aalloc::alloc::Layout \u7c7b\u578b\u7684\u53c2\u6570\uff0c // \u5b83\u6307\u51fa\u4e86\u5206\u914d\u7684\u9700\u6c42\uff0c\u5206\u4e3a\u4e24\u90e8\u5206\uff0c\u5206\u522b\u662f\u6240\u9700\u7a7a\u95f4\u7684\u5927\u5c0f size \uff0c\u4ee5\u53ca\u8fd4\u56de\u5730\u5740\u7684\u5bf9\u9f50\u8981\u6c42 align \u3002 // \u8fd9\u4e2a\u5bf9\u9f50\u8981\u6c42\u5fc5\u987b\u662f\u4e00\u4e2a 2 \u7684\u5e42\u6b21\uff0c\u5355\u4f4d\u4e3a\u5b57\u8282\u6570\uff0c\u9650\u5236\u8fd4\u56de\u7684\u5730\u5740\u5fc5\u987b\u662f align \u7684\u500d\u6570 #[alloc_error_handler] pub fn handle_alloc_error(layout: core::alloc::Layout) -> ! { panic!(\"Heap allocation error, layout = {:?}\", layout); } // \u6211\u4eec\u8fd8\u9700\u8981\u5904\u7406\u52a8\u6001\u5185\u5b58\u5206\u914d\u5931\u8d25\u7684\u60c5\u5f62 static mut HEAP_SPACE: [u8; KERNEL_HEAP_SIZE] = [0; KERNEL_HEAP_SIZE]; // \u8fd9\u5757\u5185\u5b58\u662f\u4e00\u4e2a static mut \u4e14\u88ab\u96f6\u521d\u59cb\u5316\u7684\u5b57\u8282\u6570\u7ec4\uff0c\u4f4d\u4e8e\u5185\u6838\u7684 .bss \u6bb5\u4e2d pub fn init_heap() { // \u5728\u4f7f\u7528\u4efb\u4f55 alloc \u4e2d\u63d0\u4f9b\u7684\u5806\u6570\u636e\u7ed3\u6784\u4e4b\u524d\uff0c\u6211\u4eec\u9700\u8981\u5148\u8c03\u7528 init_heap \u51fd\u6570\u6765\u7ed9\u6211\u4eec\u7684\u5168\u5c40\u5206\u914d\u5668\u4e00\u5757\u5185\u5b58\u7528\u4e8e\u5206\u914d unsafe { HEAP_ALLOCATOR .lock() .init(HEAP_SPACE.as_ptr() as usize, KERNEL_HEAP_SIZE); // LockedHeap \u4e5f\u662f\u4e00\u4e2a\u88ab\u4e92\u65a5\u9501 Mutex<T> \u4fdd\u62a4\u7684\u7c7b\u578b\uff0c // \u5728\u5bf9\u5b83\u4efb\u4f55\u8fdb\u884c\u4efb\u4f55\u64cd\u4f5c\u4e4b\u524d\u90fd\u8981\u5148\u83b7\u53d6\u9501\u4ee5\u907f\u514d\u5176\u4ed6\u7ebf\u7a0b\u540c\u65f6\u5bf9\u5b83\u8fdb\u884c\u64cd\u4f5c\u5bfc\u81f4\u6570\u636e\u7ade\u4e89\u3002 // \u7136\u540e\uff0c\u8c03\u7528 init \u65b9\u6cd5\u544a\u77e5\u5b83\u80fd\u591f\u7528\u6765\u5206\u914d\u7684\u7a7a\u95f4\u7684\u8d77\u59cb\u5730\u5740\u548c\u5927\u5c0f\u5373\u53ef\u3002 } } #[allow(unused)] pub fn heap_test() { use alloc::boxed::Box; use alloc::vec::Vec; extern \"C\" { fn sbss(); fn ebss(); } let bss_range = sbss as usize..ebss as usize; let a = Box::new(5); assert_eq!(*a, 5); assert!(bss_range.contains(&(a.as_ref() as *const _ as usize))); drop(a); let mut v: Vec<usize> = Vec::new(); for i in 0..500 { v.push(i); } for i in 0..500 { assert_eq!(v[i], i); } assert!(bss_range.contains(&(v.as_ptr() as usize))); drop(v); println!(\"heap_test passed!\"); } // \u5176\u4e2d\u5206\u522b\u4f7f\u7528\u667a\u80fd\u6307\u9488 Box<T> \u548c\u5411\u91cf Vec<T> \u5728\u5806\u4e0a\u5206\u914d\u6570\u636e\u5e76\u7ba1\u7406\u5b83\u4eec\uff0c // \u901a\u8fc7 as_ref \u548c as_ptr \u65b9\u6cd5\u53ef\u4ee5\u5206\u522b\u770b\u5230\u5b83\u4eec\u6307\u5411\u7684\u6570\u636e\u7684\u4f4d\u7f6e\uff0c\u80fd\u591f\u786e\u8ba4\u5b83\u4eec\u7684\u786e\u5728\u4f4d\u4e8e .bss \u6bb5\u7684\u5806\u4e0a","title":"os/src/mm/heap_allocator.rs"},{"location":"ch4%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/#ossrcmmmemory_setrs","text":"// \u4e00\u65e6\u4f7f\u80fd\u5206\u9875\u673a\u5236\uff0cCPU \u8bbf\u95ee\u5230\u7684\u5730\u5740\u90fd\u662f\u865a\u62df\u5730\u5740\u4e86\uff0c\u90a3\u4e48\u5185\u6838\u4e2d\u4e5f\u5c06\u57fa\u4e8e\u865a\u5730\u5740\u8fdb\u884c\u865a\u5b58\u8bbf\u95ee\u3002 // \u6240\u4ee5\u5728\u7ed9\u5e94\u7528\u6dfb\u52a0\u865a\u62df\u5730\u5740\u7a7a\u95f4\u524d\uff0c\u5185\u6838\u81ea\u5df1\u4e5f\u4f1a\u5efa\u7acb\u4e00\u4e2a\u9875\u8868\uff0c // \u628a\u6574\u5757\u7269\u7406\u5185\u5b58\u901a\u8fc7\u7b80\u5355\u7684\u6052\u7b49\u6620\u5c04\uff08\u5373\u865a\u62df\u5730\u5740\u6620\u5c04\u5230\u5bf9\u7b49\u7684\u7269\u7406\u5730\u5740\uff09\u6620\u5c04\u5230\u5185\u6838\u865a\u62df\u5730\u5740\u7a7a\u95f4\u4e2d\u3002 // \u540e\u7eed\u7684\u5e94\u7528\u5728\u6267\u884c\u524d\uff0c\u4e5f\u9700\u8981\u64cd\u4f5c\u7cfb\u7edf\u5e2e\u52a9\u5b83\u5efa\u7acb\u4e00\u4e2a\u865a\u62df\u5730\u5740\u7a7a\u95f4 // \u5728\u4e00\u4e2a\u865a\u62df\u5730\u5740\u7a7a\u95f4\u4e2d\uff0c\u6709\u4ee3\u7801\u6bb5\uff0c\u6570\u636e\u6bb5\u7b49\u4e0d\u540c\u5c5e\u6027\u4e14\u4e0d\u4e00\u5b9a\u8fde\u7eed\u7684\u5b50\u7a7a\u95f4\uff0c // \u5b83\u4eec\u901a\u8fc7\u4e00\u4e2a\u91cd\u8981\u7684\u6570\u636e\u7ed3\u6784 MapArea \u6765\u8868\u793a\u548c\u7ba1\u7406 use super::{PageTable, PageTableEntry, PTEFlags}; use super::{VirtPageNum, VirtAddr, PhysPageNum, PhysAddr}; use super::{FrameTracker, frame_alloc}; use super::{VPNRange, StepByOne}; use alloc::collections::BTreeMap; use alloc::vec::Vec; use riscv::register::satp; use alloc::sync::Arc; use lazy_static::*; use crate::sync::UPSafeCell; use crate::config::{ MEMORY_END, PAGE_SIZE, TRAMPOLINE, TRAP_CONTEXT, USER_STACK_SIZE }; use core::arch::asm; extern \"C\" { fn stext(); fn etext(); fn srodata(); fn erodata(); fn sdata(); fn edata(); fn sbss_with_stack(); fn ebss(); fn ekernel(); fn strampoline(); } // \u521b\u5efa\u5185\u6838\u5730\u5740\u7a7a\u95f4\u7684\u5168\u5c40\u5b9e\u4f8b lazy_static! { pub static ref KERNEL_SPACE: Arc<UPSafeCell<MemorySet>> = Arc::new(unsafe { UPSafeCell::new(MemorySet::new_kernel() )}); // \u4ece\u4e4b\u524d\u5bf9\u4e8e lazy_static! \u5b8f\u7684\u4ecb\u7ecd\u53ef\u77e5\uff0c KERNEL_SPACE \u5728\u8fd0\u884c\u671f\u95f4\u5b83\u7b2c\u4e00\u6b21\u88ab\u7528\u5230\u65f6\u624d\u4f1a\u5b9e\u9645\u8fdb\u884c\u521d\u59cb\u5316\uff0c // \u800c\u5b83\u6240 \u5360\u636e\u7684\u7a7a\u95f4\u5219\u662f\u7f16\u8bd1\u671f\u88ab\u653e\u5728\u5168\u5c40\u6570\u636e\u6bb5\u4e2d\u3002\u8fd9\u91cc\u4f7f\u7528 Arc<UPSafeCell<T>> \u7ec4\u5408\u662f\u56e0\u4e3a\u6211\u4eec\u65e2\u9700\u8981 Arc<T> \u63d0\u4f9b\u7684\u5171\u4eab \u5f15\u7528\uff0c // \u4e5f\u9700\u8981 UPSafeCell<T> \u63d0\u4f9b\u7684\u5185\u90e8\u53ef\u53d8\u5f15\u7528\u8bbf\u95ee // \u9996\u5148\uff0c\u6211\u4eec\u5f15\u7528 KERNEL_SPACE \uff0c\u8fd9\u662f\u5b83\u7b2c\u4e00\u6b21\u88ab\u4f7f\u7528\uff0c\u5c31\u5728\u6b64\u65f6\u5b83\u4f1a\u88ab\u521d\u59cb\u5316\uff0c // \u8c03\u7528 MemorySet::new_kernel \u521b\u5efa\u4e00\u4e2a\u5185\u6838\u5730\u5740\u7a7a\u95f4\u5e76\u4f7f\u7528 Arc<Mutex<T>> \u5305\u88f9\u8d77\u6765\uff1b // \u63a5\u7740\u4f7f\u7528 .exclusive_access() \u83b7\u53d6\u4e00\u4e2a\u53ef\u53d8\u5f15\u7528 &mut MemorySet \u3002 // \u9700\u8981\u6ce8\u610f\u7684\u662f\u8fd9\u91cc\u53d1\u751f\u4e86\u4e24\u6b21\u9690\u5f0f\u7c7b\u578b\u8f6c\u6362\uff1a // \u6211\u4eec\u77e5\u9053 exclusive_access \u662f UPSafeCell<T> \u7684\u65b9\u6cd5\u800c\u4e0d\u662f Arc<T> \u7684\u65b9\u6cd5\uff0c // \u7531\u4e8e Arc<T> \u5b9e\u73b0\u4e86 Deref Trait \uff0c\u5f53 exclusive_access \u9700\u8981\u4e00\u4e2a &UPSafeCell<T> \u7c7b\u578b\u7684\u53c2\u6570\u7684\u65f6\u5019\uff0c // \u7f16\u8bd1\u5668\u4f1a\u81ea\u52a8\u5c06\u4f20\u5165\u7684 Arc<UPSafeCell<T>> \u8f6c\u6362\u4e3a &UPSafeCell<T> \u8fd9\u6837\u5c31\u5b9e\u73b0\u4e86\u7c7b\u578b\u5339\u914d\uff1b // \u4e8b\u5b9e\u4e0a UPSafeCell<T>::exclusive_access \u8fd4\u56de\u7684\u662f\u4e00\u4e2a RefMut<'_, T> \uff0c // \u8fd9\u540c\u6837\u662f RAII \u7684\u601d\u60f3\uff0c\u5f53\u8fd9\u4e2a\u7c7b\u578b\u751f\u547d\u5468\u671f\u7ed3\u675f\u540e\u4e92\u65a5\u9501\u5c31\u4f1a\u88ab\u91ca\u653e\u3002 // \u800c\u8be5\u7c7b\u578b\u5b9e\u73b0\u4e86 DerefMut Trait\uff0c\u56e0\u6b64\u5f53\u4e00\u4e2a\u51fd\u6570\u63a5\u53d7\u7c7b\u578b\u4e3a &mut T \u7684\u53c2\u6570\u5374\u88ab\u4f20\u5165\u4e00\u4e2a\u7c7b\u578b\u4e3a &mut RefMut<'_, T> \u7684\u53c2\u6570\u7684\u65f6\u5019\uff0c // \u7f16\u8bd1\u5668\u4f1a\u81ea\u52a8\u8fdb\u884c\u7c7b\u578b\u8f6c\u6362\u4f7f\u53c2\u6570\u5339\u914d\u3002 } // \u5730\u5740\u7a7a\u95f4 \u662f\u4e00\u7cfb\u5217\u6709\u5173\u8054\u7684\u4e0d\u4e00\u5b9a\u8fde\u7eed\u7684\u903b\u8f91\u6bb5\uff0c // \u8fd9\u79cd\u5173\u8054\u4e00\u822c\u662f\u6307\u8fd9\u4e9b\u903b\u8f91\u6bb5\u7ec4\u6210\u7684\u865a\u62df\u5185\u5b58\u7a7a\u95f4\u4e0e\u4e00\u4e2a\u8fd0\u884c\u7684\u7a0b\u5e8f\uff08\u76ee\u524d\u628a\u4e00\u4e2a\u8fd0\u884c\u7684\u7a0b\u5e8f\u79f0\u4e3a\u4efb\u52a1\uff0c // \u540e\u7eed\u4f1a\u79f0\u4e3a\u8fdb\u7a0b\uff09\u7ed1\u5b9a\uff0c\u5373\u8fd9\u4e2a\u8fd0\u884c\u7684\u7a0b\u5e8f\u5bf9\u4ee3\u7801\u548c\u6570\u636e\u7684\u76f4\u63a5\u8bbf\u95ee\u8303\u56f4\u9650\u5236\u5728\u5b83\u5173\u8054\u7684\u865a\u62df\u5730\u5740\u7a7a\u95f4\u4e4b\u5185\u3002 // \u8fd9\u6837\u6211\u4eec\u5c31\u6709\u4efb\u52a1\u7684\u5730\u5740\u7a7a\u95f4\uff0c\u5185\u6838\u7684\u5730\u5740\u7a7a\u95f4\u7b49\u8bf4\u6cd5\u4e86\u3002\u5730\u5740\u7a7a\u95f4\u4f7f\u7528 MemorySet \u7c7b\u578b\u6765\u8868\u793a pub struct MemorySet { page_table: PageTable, // \u8be5\u5730\u5740\u7a7a\u95f4\u7684\u591a\u7ea7\u9875\u8868 page_table // PageTable \u4e0b\u6302\u7740\u6240\u6709\u591a\u7ea7\u9875\u8868\u7684\u8282\u70b9\u6240\u5728\u7684\u7269\u7406\u9875\u5e27 areas: Vec<MapArea>, // \u4e00\u4e2a\u903b\u8f91\u6bb5 MapArea \u7684\u5411\u91cf areas // \u6bcf\u4e2a MapArea \u4e0b\u5219\u6302\u7740\u5bf9\u5e94\u903b\u8f91\u6bb5\u4e2d\u7684\u6570\u636e\u6240\u5728\u7684\u7269\u7406\u9875\u5e27\uff0c\u8fd9\u4e24\u90e8\u5206\u5408\u5728\u4e00\u8d77\u6784\u6210\u4e86\u4e00\u4e2a\u5730\u5740\u7a7a\u95f4\u6240\u9700\u7684\u6240\u6709\u7269\u7406\u9875\u5e27\u3002 // \u8fd9\u540c\u6837\u662f\u4e00\u79cd RAII \u98ce\u683c\uff0c\u5f53\u4e00\u4e2a\u5730\u5740\u7a7a\u95f4 MemorySet \u751f\u547d\u5468\u671f\u7ed3\u675f\u540e\uff0c\u8fd9\u4e9b\u7269\u7406\u9875\u5e27\u90fd\u4f1a\u88ab\u56de\u6536 } impl MemorySet { // \u65b0\u5efa\u4e00\u4e2a\u7a7a\u7684\u5730\u5740\u7a7a\u95f4 pub fn new_bare() -> Self { Self { page_table: PageTable::new(), areas: Vec::new(), } } pub fn token(&self) -> usize { self.page_table.token() } /// Assume that no conflicts. // \u8c03\u7528 push \uff0c\u53ef\u4ee5\u5728\u5f53\u524d\u5730\u5740\u7a7a\u95f4\u63d2\u5165\u4e00\u4e2a Framed \u65b9\u5f0f\u6620\u5c04\u5230\u7269\u7406\u5185\u5b58\u7684\u903b\u8f91\u6bb5\u3002 // \u6ce8\u610f\u8be5\u65b9\u6cd5\u7684\u8c03\u7528\u8005\u8981\u4fdd\u8bc1\u540c\u4e00\u5730\u5740\u7a7a\u95f4\u5185\u7684\u4efb\u610f\u4e24\u4e2a\u903b\u8f91\u6bb5\u4e0d\u80fd\u5b58\u5728\u4ea4\u96c6\uff0c // \u4ece\u540e\u9762\u5373\u5c06\u5206\u522b\u4ecb\u7ecd\u7684\u5185\u6838\u548c\u5e94\u7528\u7684\u5730\u5740\u7a7a\u95f4\u5e03\u5c40\u53ef\u4ee5\u770b\u51fa\u8fd9\u4e00\u8981\u6c42\u5f97\u5230\u4e86\u4fdd\u8bc1 pub fn insert_framed_area(&mut self, start_va: VirtAddr, end_va: VirtAddr, permission: MapPermission) { self.push(MapArea::new( start_va, end_va, MapType::Framed, permission, ), None); } // push \u65b9\u6cd5\u53ef\u4ee5\u5728\u5f53\u524d\u5730\u5740\u7a7a\u95f4\u63d2\u5165\u4e00\u4e2a\u65b0\u7684\u903b\u8f91\u6bb5 map_area \uff0c\u5982\u679c\u5b83\u662f\u4ee5 Framed \u65b9\u5f0f\u6620\u5c04\u5230\u7269\u7406\u5185\u5b58\uff0c // \u8fd8\u53ef\u4ee5\u53ef\u9009\u5730\u5728\u90a3\u4e9b\u88ab\u6620\u5c04\u5230\u7684\u7269\u7406\u9875\u5e27\u4e0a\u5199\u5165\u4e00\u4e9b\u521d\u59cb\u5316\u6570\u636e data fn push(&mut self, mut map_area: MapArea, data: Option<&[u8]>) { map_area.map(&mut self.page_table); if let Some(data) = data { map_area.copy_data(&mut self.page_table, data); } self.areas.push(map_area); } /// Mention that trampoline is not collected by areas. fn map_trampoline(&mut self) { self.page_table.map( VirtAddr::from(TRAMPOLINE).into(), PhysAddr::from(strampoline as usize).into(), PTEFlags::R | PTEFlags::X, ); } /// Without kernel stacks. // \u751f\u6210\u5185\u6838\u7684\u5730\u5740\u7a7a\u95f4 // new_kernel \u5c06\u6620\u5c04\u8df3\u677f\u548c\u5730\u5740\u7a7a\u95f4\u4e2d\u6700\u4f4e \u4e2d\u7684\u5185\u6838\u903b\u8f91\u6bb5\u3002 // \u6211\u4eec\u4ece os/src/linker.ld \u4e2d\u5f15\u7528\u4e86\u5f88\u591a\u8868\u793a\u5404\u4e2a\u6bb5\u4f4d\u7f6e\u7684\u7b26\u53f7\uff0c\u800c\u540e\u5728 new_kernel \u4e2d\uff0c // \u6211\u4eec\u4ece\u4f4e\u5730\u5740\u5230\u9ad8\u5730\u5740\u4f9d\u6b21\u521b\u5efa 5 \u4e2a\u903b\u8f91\u6bb5\u5e76\u901a\u8fc7 push \u65b9\u6cd5\u5c06\u5b83\u4eec\u63d2\u5165\u5230\u5185\u6838\u5730\u5740\u7a7a\u95f4\u4e2d\uff0c // \u4e0a\u9762\u6211\u4eec\u5df2\u7ecf\u8be6\u7ec6\u4ecb\u7ecd\u8fc7\u8fd9 5 \u4e2a\u903b\u8f91\u6bb5\u3002\u8df3\u677f\u662f\u901a\u8fc7 map_trampoline \u65b9\u6cd5\u6765\u6620\u5c04\u7684 pub fn new_kernel() -> Self { let mut memory_set = Self::new_bare(); // map trampoline memory_set.map_trampoline(); // map kernel sections println!(\".text [{:#x}, {:#x})\", stext as usize, etext as usize); println!(\".rodata [{:#x}, {:#x})\", srodata as usize, erodata as usize); println!(\".data [{:#x}, {:#x})\", sdata as usize, edata as usize); println!(\".bss [{:#x}, {:#x})\", sbss_with_stack as usize, ebss as usize); println!(\"mapping .text section\"); memory_set.push(MapArea::new( (stext as usize).into(), (etext as usize).into(), MapType::Identical, MapPermission::R | MapPermission::X, ), None); println!(\"mapping .rodata section\"); memory_set.push(MapArea::new( (srodata as usize).into(), (erodata as usize).into(), MapType::Identical, MapPermission::R, ), None); println!(\"mapping .data section\"); memory_set.push(MapArea::new( (sdata as usize).into(), (edata as usize).into(), MapType::Identical, MapPermission::R | MapPermission::W, ), None); println!(\"mapping .bss section\"); memory_set.push(MapArea::new( (sbss_with_stack as usize).into(), (ebss as usize).into(), MapType::Identical, MapPermission::R | MapPermission::W, ), None); println!(\"mapping physical memory\"); memory_set.push(MapArea::new( (ekernel as usize).into(), MEMORY_END.into(), MapType::Identical, MapPermission::R | MapPermission::W, ), None); memory_set } /// Include sections in elf and trampoline and TrapContext and user stack, /// also returns user_sp and entry point. // \u5e94\u7528\u7684 ELF \u683c\u5f0f\u53ef\u6267\u884c\u6587\u4ef6\u89e3\u6790\u51fa\u5404\u6570\u636e\u6bb5\u5e76\u5bf9\u5e94\u751f\u6210\u5e94\u7528\u7684\u5730\u5740\u7a7a\u95f4 // \u5728\u521b\u5efa\u5e94\u7528\u5730\u5740\u7a7a\u95f4\u7684\u65f6\u5019\uff0c\u6211\u4eec\u9700\u8981\u5bf9 get_app_data \u5f97\u5230\u7684 ELF \u683c\u5f0f\u6570\u636e\u8fdb\u884c\u89e3\u6790\uff0c // \u627e\u5230\u5404\u4e2a\u903b\u8f91\u6bb5\u6240\u5728\u4f4d\u7f6e\u548c\u8bbf\u95ee\u9650\u5236\u5e76\u63d2\u5165\u8fdb\u6765\uff0c\u6700\u7ec8\u5f97\u5230\u4e00\u4e2a\u5b8c\u6574\u7684\u5e94\u7528\u5730\u5740\u7a7a\u95f4 pub fn from_elf(elf_data: &[u8]) -> (Self, usize, usize) { let mut memory_set = Self::new_bare(); // map trampoline memory_set.map_trampoline(); // \u6211\u4eec\u5c06\u8df3\u677f\u63d2\u5165\u5230\u5e94\u7528\u5730\u5740\u7a7a\u95f4 // map program headers of elf, with U flag let elf = xmas_elf::ElfFile::new(elf_data).unwrap(); // \u6211\u4eec\u4f7f\u7528\u5916\u90e8 crate xmas_elf \u6765\u89e3\u6790\u4f20\u5165\u7684\u5e94\u7528 ELF \u6570\u636e\u5e76\u53ef\u4ee5\u8f7b\u677e\u53d6\u51fa\u5404\u4e2a\u90e8\u5206 // \u6211\u4eec\u53d6\u51fa ELF \u7684\u9b54\u6570\u6765\u5224\u65ad\u5b83\u662f\u4e0d\u662f\u4e00\u4e2a\u5408\u6cd5\u7684 ELF let elf_header = elf.header; let magic = elf_header.pt1.magic; assert_eq!(magic, [0x7f, 0x45, 0x4c, 0x46], \"invalid elf!\"); let ph_count = elf_header.pt2.ph_count(); // \u6211\u4eec\u53ef\u4ee5\u76f4\u63a5\u5f97\u5230 program header \u7684\u6570\u76ee\uff0c let mut max_end_vpn = VirtPageNum(0); // \u7136\u540e\u904d\u5386\u6240\u6709\u7684 program header \u5e76\u5c06\u5408\u9002\u7684\u533a\u57df\u52a0\u5165\u5230\u5e94\u7528\u5730\u5740\u7a7a\u95f4\u4e2d for i in 0..ph_count { let ph = elf.program_header(i).unwrap(); if ph.get_type().unwrap() == xmas_elf::program::Type::Load { // program header \u7684\u7c7b\u578b\u662f LOAD \uff0c\u8fd9\u8868\u660e\u5b83\u6709\u88ab\u5185\u6838\u52a0\u8f7d\u7684\u5fc5\u8981\uff0c // \u6b64\u65f6\u4e0d\u5fc5\u7406\u4f1a\u5176\u4ed6\u7c7b\u578b\u7684 program header let start_va: VirtAddr = (ph.virtual_addr() as usize).into(); let end_va: VirtAddr = ((ph.virtual_addr() + ph.mem_size()) as usize).into(); // \u8ba1\u7b97\u8fd9\u4e00\u533a\u57df\u5728\u5e94\u7528\u5730\u5740\u7a7a\u95f4\u4e2d\u7684\u4f4d\u7f6e let mut map_perm = MapPermission::U; let ph_flags = ph.flags(); // \u786e\u8ba4\u8fd9\u4e00\u533a\u57df\u8bbf\u95ee\u65b9\u5f0f\u7684\u9650\u5236\u5e76\u5c06\u5176\u8f6c\u6362\u4e3a MapPermission \u7c7b\u578b if ph_flags.is_read() { map_perm |= MapPermission::R; } if ph_flags.is_write() { map_perm |= MapPermission::W; } if ph_flags.is_execute() { map_perm |= MapPermission::X; } let map_area = MapArea::new( // \u521b\u5efa\u903b\u8f91\u6bb5 map_area start_va, end_va, MapType::Framed, map_perm, ); max_end_vpn = map_area.vpn_range.get_end(); memory_set.push( // push \u5230\u5e94\u7528\u5730\u5740\u7a7a\u95f4 map_area, Some(&elf.input[ph.offset() as usize..(ph.offset() + ph.file_size()) as usize]) ); // \u5728 push \u7684\u65f6\u5019\u6211\u4eec\u9700\u8981\u5b8c\u6210\u6570\u636e\u62f7\u8d1d\uff0c\u5f53\u524d program header \u6570\u636e\u88ab\u5b58\u653e\u7684\u4f4d\u7f6e\u53ef\u4ee5\u901a\u8fc7 ph.offset() \u548c ph.file_size() \u6765\u627e\u5230\u3002 // \u6ce8\u610f\u5f53\u5b58\u5728\u4e00\u90e8\u5206\u96f6\u521d\u59cb\u5316\u7684\u65f6\u5019\uff0c ph.file_size() \u5c06\u4f1a\u5c0f\u4e8e ph.mem_size() \uff0c // \u56e0\u4e3a\u8fd9\u4e9b\u96f6\u51fa\u4e8e\u7f29\u51cf\u53ef\u6267\u884c\u6587\u4ef6\u5927\u5c0f\u7684\u539f\u56e0\u4e0d\u5e94\u8be5\u5b9e\u9645\u51fa\u73b0\u5728 ELF \u6570\u636e\u4e2d } } // map user stack with U flags // \u5904\u7406\u7528\u6237\u6808\u3002\u6ce8\u610f\u5728\u524d\u9762\u52a0\u8f7d\u5404\u4e2a program header \u7684\u65f6\u5019\uff0c // \u6211\u4eec\u5c31\u5df2\u7ecf\u7ef4\u62a4\u4e86 max_end_vpn \u8bb0\u5f55\u76ee\u524d\u6d89\u53ca\u5230\u7684\u6700\u5927\u7684\u865a\u62df\u9875\u53f7\uff0c // \u53ea\u9700\u7d27\u63a5\u7740\u5728\u5b83\u4e0a\u9762\u518d\u653e\u7f6e\u4e00\u4e2a\u4fdd\u62a4\u9875\u9762\u548c\u7528\u6237\u6808\u5373\u53ef let max_end_va: VirtAddr = max_end_vpn.into(); let mut user_stack_bottom: usize = max_end_va.into(); // guard page user_stack_bottom += PAGE_SIZE; let user_stack_top = user_stack_bottom + USER_STACK_SIZE; memory_set.push(MapArea::new( user_stack_bottom.into(), user_stack_top.into(), MapType::Framed, MapPermission::R | MapPermission::W | MapPermission::U, ), None); // map TrapContext // \u5e94\u7528\u5730\u5740\u7a7a\u95f4\u4e2d\u6620\u5c04\u6b21\u9ad8\u9875\u9762\u6765\u5b58\u653e Trap \u4e0a\u4e0b\u6587 memory_set.push(MapArea::new( TRAP_CONTEXT.into(), TRAMPOLINE.into(), MapType::Framed, MapPermission::R | MapPermission::W, ), None); (memory_set, user_stack_top, elf.header.pt2.entry_point() as usize) // \u8fd4\u56de\u5e94\u7528\u5730\u5740\u7a7a\u95f4 memory_set \uff0c // \u4e5f\u540c\u65f6\u8fd4\u56de\u7528\u6237\u6808\u865a\u62df\u5730\u5740 user_stack_top \u4ee5\u53ca\u4ece\u89e3\u6790 ELF \u5f97\u5230\u7684\u8be5\u5e94\u7528\u5165\u53e3\u70b9\u5730\u5740\uff0c // \u5b83\u4eec\u5c06\u88ab\u6211\u4eec\u7528\u6765\u521b\u5efa\u5e94\u7528\u7684\u4efb\u52a1\u63a7\u5236\u5757 } pub fn activate(&self) { let satp = self.page_table.token(); unsafe { satp::write(satp); asm!(\"sfence.vma\"); } // \u6211\u4eec\u5c06\u8fd9\u4e2a\u503c\u5199\u5165\u5f53\u524d CPU \u7684 satp CSR \uff0c\u4ece\u8fd9\u4e00\u523b\u5f00\u59cb SV39 \u5206\u9875\u6a21\u5f0f\u5c31\u88ab\u542f\u7528\u4e86\uff0c // \u800c\u4e14 MMU \u4f1a\u4f7f\u7528\u5185\u6838\u5730\u5740\u7a7a\u95f4\u7684\u591a\u7ea7\u9875\u8868\u8fdb\u884c\u5730\u5740\u8f6c\u6362 } pub fn translate(&self, vpn: VirtPageNum) -> Option<PageTableEntry> { self.page_table.translate(vpn) } } // \u6211\u4eec\u4ee5\u903b\u8f91\u6bb5 MapArea \u4e3a\u5355\u4f4d\u63cf\u8ff0\u4e00\u6bb5\u8fde\u7eed\u5730\u5740\u7684\u865a\u62df\u5185\u5b58\u3002\u6240\u8c13\u903b\u8f91\u6bb5\uff0c // \u5c31\u662f\u6307\u5730\u5740\u533a\u95f4\u4e2d\u7684\u4e00\u6bb5\u5b9e\u9645\u53ef\u7528\uff08\u5373 MMU \u901a\u8fc7\u67e5\u591a\u7ea7\u9875\u8868\u53ef\u4ee5\u6b63\u786e\u5b8c\u6210\u5730\u5740\u8f6c\u6362\uff09\u7684\u5730\u5740\u8fde\u7eed\u7684\u865a\u62df\u5730\u5740\u533a\u95f4\uff0c // \u8be5\u533a\u95f4\u5185\u5305\u542b\u7684\u6240\u6709\u865a\u62df\u9875\u9762\u90fd\u4ee5\u4e00\u79cd\u76f8\u540c\u7684\u65b9\u5f0f\u6620\u5c04\u5230\u7269\u7406\u9875\u5e27\uff0c\u5177\u6709\u53ef\u8bfb/\u53ef\u5199/\u53ef\u6267\u884c\u7b49\u5c5e\u6027 pub struct MapArea { vpn_range: VPNRange, // \u5176\u4e2d VPNRange \u63cf\u8ff0\u4e00\u6bb5\u865a\u62df\u9875\u53f7\u7684\u8fde\u7eed\u533a\u95f4\uff0c\u8868\u793a\u8be5\u903b\u8f91\u6bb5\u5728\u5730\u5740\u533a\u95f4\u4e2d\u7684\u4f4d\u7f6e\u548c\u957f\u5ea6\u3002 // \u5b83\u662f\u4e00\u4e2a\u8fed\u4ee3\u5668\uff0c\u53ef\u4ee5\u4f7f\u7528 Rust \u7684\u8bed\u6cd5\u7cd6 for-loop \u8fdb\u884c\u8fed\u4ee3 data_frames: BTreeMap<VirtPageNum, FrameTracker>, map_type: MapType, map_perm: MapPermission, // MapPermission \u8868\u793a\u63a7\u5236\u8be5\u903b\u8f91\u6bb5\u7684\u8bbf\u95ee\u65b9\u5f0f\uff0c\u5b83\u662f\u9875\u8868\u9879\u6807\u5fd7\u4f4d PTEFlags \u7684\u4e00\u4e2a\u5b50\u96c6\uff0c // \u4ec5\u4fdd\u7559 U/R/W/X \u56db\u4e2a\u6807\u5fd7\u4f4d\uff0c\u56e0\u4e3a\u5176\u4ed6\u7684\u6807\u5fd7\u4f4d\u4ec5\u4e0e\u786c\u4ef6\u7684\u5730\u5740\u8f6c\u6362\u673a\u5236\u7ec6\u8282\u76f8\u5173\uff0c\u8fd9\u6837\u7684\u8bbe\u8ba1\u80fd\u907f\u514d\u5f15\u5165\u9519\u8bef\u7684\u6807\u5fd7\u4f4d } impl MapArea { // \u65b0\u5efa\u4e00\u4e2a\u903b\u8f91\u6bb5\u7ed3\u6784\u4f53\uff0c // \u6ce8\u610f\u4f20\u5165\u7684\u8d77\u59cb/\u7ec8\u6b62\u865a\u62df\u5730\u5740\u4f1a\u5206\u522b\u88ab\u4e0b\u53d6\u6574/\u4e0a\u53d6\u6574\u4e3a\u865a\u62df\u9875\u53f7\u5e76\u4f20\u5165\u8fed\u4ee3\u5668 vpn_range \u4e2d pub fn new( start_va: VirtAddr, end_va: VirtAddr, map_type: MapType, map_perm: MapPermission ) -> Self { let start_vpn: VirtPageNum = start_va.floor(); let end_vpn: VirtPageNum = end_va.ceil(); Self { vpn_range: VPNRange::new(start_vpn, end_vpn), data_frames: BTreeMap::new(), map_type, map_perm, } } // \u5bf9\u903b\u8f91\u6bb5\u4e2d\u7684\u5355\u4e2a\u865a\u62df\u9875\u9762\u8fdb\u884c\u6620\u5c04/\u89e3\u6620\u5c04\u7684\u65b9\u6cd5 // \u5728\u865a\u62df\u9875\u53f7 vpn \u5df2\u7ecf\u786e\u5b9a\u7684\u60c5\u51b5\u4e0b\uff0c\u5b83\u9700\u8981\u77e5\u9053\u8981\u5c06\u4e00\u4e2a\u600e\u4e48\u6837\u7684\u9875\u8868\u9879\u63d2\u5165\u591a\u7ea7\u9875\u8868\u3002 // \u9875\u8868\u9879\u7684\u6807\u5fd7\u4f4d\u6765\u6e90\u4e8e\u5f53\u524d\u903b\u8f91\u6bb5\u7684\u7c7b\u578b\u4e3a MapPermission \u7684\u7edf\u4e00\u914d\u7f6e\uff0c\u53ea\u9700\u5c06\u5176\u8f6c\u6362\u4e3a PTEFlags \uff1b // \u800c\u9875\u8868\u9879\u7684\u7269\u7406\u9875\u53f7\u5219\u53d6\u51b3\u4e8e\u5f53\u524d\u903b\u8f91\u6bb5\u6620\u5c04\u5230\u7269\u7406\u5185\u5b58\u7684\u65b9\u5f0f: // \u5f53\u4ee5\u6052\u7b49\u6620\u5c04 Identical \u65b9\u5f0f\u6620\u5c04\u7684\u65f6\u5019\uff0c\u7269\u7406\u9875\u53f7\u5c31\u7b49\u4e8e\u865a\u62df\u9875\u53f7\uff1b // \u5f53\u4ee5 Framed \u65b9\u5f0f\u6620\u5c04\u65f6\uff0c\u9700\u8981\u5206\u914d\u4e00\u4e2a\u7269\u7406\u9875\u5e27\u8ba9\u5f53\u524d\u7684\u865a\u62df\u9875\u9762\u53ef\u4ee5\u6620\u5c04\u8fc7\u53bb\uff0c // \u6b64\u65f6\u9875\u8868\u9879\u4e2d\u7684\u7269\u7406\u9875\u53f7\u81ea\u7136\u5c31\u662f \u8fd9\u4e2a\u88ab\u5206\u914d\u7684\u7269\u7406\u9875\u5e27\u7684\u7269\u7406\u9875\u53f7\u3002 // \u6b64\u65f6\u8fd8\u9700\u8981\u5c06\u8fd9\u4e2a\u7269\u7406\u9875\u5e27\u6302\u5728\u903b\u8f91\u6bb5\u7684 data_frames \u5b57\u6bb5\u4e0b\u3002 // \u5f53\u786e\u5b9a\u4e86\u9875\u8868\u9879\u7684\u6807\u5fd7\u4f4d\u548c\u7269\u7406\u9875\u53f7\u4e4b\u540e\uff0c\u5373\u53ef\u8c03\u7528\u591a\u7ea7\u9875\u8868 PageTable \u7684 map \u63a5\u53e3\u6765\u63d2\u5165\u952e\u503c\u5bf9 pub fn map_one(&mut self, page_table: &mut PageTable, vpn: VirtPageNum) { let ppn: PhysPageNum; match self.map_type { MapType::Identical => { ppn = PhysPageNum(vpn.0); } MapType::Framed => { let frame = frame_alloc().unwrap(); ppn = frame.ppn; self.data_frames.insert(vpn, frame); } } let pte_flags = PTEFlags::from_bits(self.map_perm.bits).unwrap(); page_table.map(vpn, ppn, pte_flags); } // \u57fa\u672c\u4e0a\u5c31\u662f\u8c03\u7528 PageTable \u7684 unmap \u63a5\u53e3\u5220\u9664\u4ee5\u4f20\u5165\u7684\u865a\u62df\u9875\u53f7\u4e3a\u952e\u7684\u952e\u503c\u5bf9\u5373\u53ef\u3002 // \u7136\u800c\uff0c\u5f53\u4ee5 Framed \u6620\u5c04\u7684\u65f6\u5019\uff0c\u4e0d\u8981\u5fd8\u8bb0\u540c\u65f6\u5c06\u865a\u62df\u9875\u9762\u88ab\u6620\u5c04\u5230\u7684\u7269\u7406\u9875\u5e27 FrameTracker \u4ece data_frames \u4e2d\u79fb\u9664\uff0c // \u8fd9\u6837\u8fd9\u4e2a\u7269\u7406\u9875\u5e27\u624d\u80fd\u7acb\u5373\u88ab\u56de\u6536\u4ee5\u5907\u540e\u7eed\u5206\u914d #[allow(unused)] pub fn unmap_one(&mut self, page_table: &mut PageTable, vpn: VirtPageNum) { match self.map_type { MapType::Framed => { self.data_frames.remove(&vpn); } _ => {} } page_table.unmap(vpn); } // \u53ef\u4ee5\u5c06\u5f53\u524d\u903b\u8f91\u6bb5\u5230\u7269\u7406\u5185\u5b58\u7684\u6620\u5c04\u4ece\u4f20\u5165\u7684\u8be5\u903b\u8f91\u6bb5\u6240\u5c5e\u7684\u5730\u5740\u7a7a\u95f4\u7684\u591a\u7ea7\u9875\u8868\u4e2d\u52a0\u5165\u6216\u5220\u9664\u3002 // \u53ef\u4ee5\u770b\u5230\u5b83\u4eec\u7684\u5b9e\u73b0\u662f\u904d\u5386\u903b\u8f91\u6bb5\u4e2d\u7684\u6240\u6709\u865a\u62df\u9875\u9762\uff0c // \u5e76\u4ee5\u6bcf\u4e2a\u865a\u62df\u9875\u9762\u4e3a\u5355\u4f4d\u4f9d\u6b21\u5728\u591a\u7ea7\u9875\u8868\u4e2d\u8fdb\u884c\u952e\u503c\u5bf9\u7684\u63d2\u5165\u6216\u5220\u9664\uff0c // \u5206\u522b\u5bf9\u5e94 MapArea \u7684 map_one \u548c unmap_one \u65b9\u6cd5 pub fn map(&mut self, page_table: &mut PageTable) { for vpn in self.vpn_range { self.map_one(page_table, vpn); } } #[allow(unused)] pub fn unmap(&mut self, page_table: &mut PageTable) { for vpn in self.vpn_range { self.unmap_one(page_table, vpn); } } /// data: start-aligned but maybe with shorter length /// assume that all frames were cleared before // \u5c06\u5207\u7247 data \u4e2d\u7684\u6570\u636e\u62f7\u8d1d\u5230\u5f53\u524d\u903b\u8f91\u6bb5\u5b9e\u9645\u88ab\u5185\u6838\u653e\u7f6e\u5728\u7684\u5404\u7269\u7406\u9875\u5e27\u4e0a\uff0c // \u4ece\u800c\u5728\u5730\u5740\u7a7a\u95f4\u4e2d\u901a\u8fc7\u8be5\u903b\u8f91\u6bb5\u5c31\u80fd\u8bbf\u95ee\u8fd9\u4e9b\u6570\u636e\u3002\u8c03\u7528\u5b83\u7684\u65f6\u5019\u9700\u8981\u6ee1\u8db3\uff1a // \u5207\u7247 data \u4e2d\u7684\u6570\u636e\u5927\u5c0f\u4e0d\u8d85\u8fc7\u5f53\u524d\u903b\u8f91\u6bb5\u7684\u603b\u5927\u5c0f\uff0c\u4e14\u5207\u7247\u4e2d\u7684\u6570\u636e\u4f1a\u88ab\u5bf9\u9f50\u5230\u903b\u8f91\u6bb5\u7684\u5f00\u5934\uff0c // \u7136\u540e\u9010\u9875\u62f7\u8d1d\u5230\u5b9e\u9645\u7684\u7269\u7406\u9875\u5e27 pub fn copy_data(&mut self, page_table: &mut PageTable, data: &[u8]) { assert_eq!(self.map_type, MapType::Framed); let mut start: usize = 0; let mut current_vpn = self.vpn_range.get_start(); let len = data.len(); loop { let src = &data[start..len.min(start + PAGE_SIZE)]; let dst = &mut page_table .translate(current_vpn) .unwrap() .ppn() .get_bytes_array()[..src.len()]; dst.copy_from_slice(src); start += PAGE_SIZE; if start >= len { break; } current_vpn.step(); } // \u5faa\u73af\u4f1a\u904d\u5386\u6bcf\u4e00\u4e2a\u9700\u8981\u62f7\u8d1d\u6570\u636e\u7684\u865a\u62df\u9875\u9762\uff0c\u5728\u6570\u636e\u62f7\u8d1d\u5b8c\u6210\u540e\u4f1a\u901a\u8fc7\u8c03\u7528 step \u65b9\u6cd5 } } // MapType \u63cf\u8ff0\u8be5\u903b\u8f91\u6bb5\u5185\u7684\u6240\u6709\u865a\u62df\u9875\u9762\u6620\u5c04\u5230\u7269\u7406\u9875\u5e27\u7684\u540c\u4e00\u79cd\u65b9\u5f0f\uff0c\u5b83\u662f\u4e00\u4e2a\u679a\u4e3e\u7c7b\u578b\uff0c // \u5728\u5185\u6838\u5f53\u524d\u7684\u5b9e\u73b0\u4e2d\u652f\u6301\u4e24\u79cd\u65b9\u5f0f #[derive(Copy, Clone, PartialEq, Debug)] pub enum MapType { Identical, // Identical \u8868\u793a\u6052\u7b49\u6620\u5c04\u65b9\u5f0f // \u6052\u7b49\u6620\u5c04\u65b9\u5f0f\u4e3b\u8981\u662f\u7528\u5728\u542f\u7528\u591a\u7ea7\u9875\u8868\u4e4b\u540e\uff0c // \u5185\u6838\u4ecd\u80fd\u591f\u5728\u865a\u5b58\u5730\u5740\u7a7a\u95f4\u4e2d\u8bbf\u95ee\u4e00\u4e2a\u7279\u5b9a\u7684\u7269\u7406\u5730\u5740\u6307\u5411\u7684\u7269\u7406\u5185\u5b58 Framed, // Framed \u5219\u8868\u793a\u5bf9\u4e8e\u6bcf\u4e2a\u865a\u62df\u9875\u9762\u90fd\u6709\u4e00\u4e2a\u65b0\u5206\u914d\u7684\u7269\u7406\u9875\u5e27\u4e0e\u4e4b\u5bf9\u5e94\uff0c // \u865a\u5730\u5740\u4e0e\u7269\u7406\u5730\u5740\u7684\u6620\u5c04\u5173\u7cfb\u662f\u76f8\u5bf9\u968f\u673a\u7684 // \u5f53\u903b\u8f91\u6bb5\u91c7\u7528 MapType::Framed \u65b9\u5f0f\u6620\u5c04\u5230\u7269\u7406\u5185\u5b58\u7684\u65f6\u5019\uff0c // data_frames \u662f\u4e00\u4e2a\u4fdd\u5b58\u4e86\u8be5\u903b\u8f91\u6bb5\u5185\u7684\u6bcf\u4e2a\u865a\u62df\u9875\u9762\u548c\u5b83\u88ab\u6620\u5c04\u5230\u7684\u7269\u7406\u9875\u5e27 FrameTracker \u7684\u4e00\u4e2a\u952e\u503c\u5bf9\u5bb9\u5668 BTreeMap \u4e2d\uff0c // \u8fd9\u4e9b\u7269\u7406\u9875\u5e27\u88ab\u7528\u6765\u5b58\u653e\u5b9e\u9645\u5185\u5b58\u6570\u636e\u800c\u4e0d\u662f\u4f5c\u4e3a\u591a\u7ea7\u9875\u8868\u4e2d\u7684\u4e2d\u95f4\u8282\u70b9\u3002\u548c\u4e4b\u524d\u7684 PageTable \u4e00\u6837\uff0c // \u8fd9\u4e5f\u7528\u5230\u4e86 RAII \u7684\u601d\u60f3\uff0c\u5c06\u8fd9\u4e9b\u7269\u7406\u9875\u5e27\u7684\u751f\u547d\u5468\u671f\u7ed1\u5b9a\u5230\u5b83\u6240\u5728\u7684\u903b\u8f91\u6bb5 MapArea \u4e0b\uff0c // \u5f53\u903b\u8f91\u6bb5\u88ab\u56de\u6536\u4e4b\u540e\u8fd9\u4e9b\u4e4b\u524d\u5206\u914d\u7684\u7269\u7406\u9875\u5e27\u4e5f\u4f1a\u81ea\u52a8\u5730\u540c\u65f6\u88ab\u56de\u6536 } bitflags! { pub struct MapPermission: u8 { const R = 1 << 1; const W = 1 << 2; const X = 1 << 3; const U = 1 << 4; } // \u4ec5\u4fdd\u7559 U/R/W/X \u56db\u4e2a\u6807\u5fd7\u4f4d\uff0c\u56e0\u4e3a\u5176\u4ed6\u7684\u6807\u5fd7\u4f4d\u4ec5\u4e0e\u786c\u4ef6\u7684\u5730\u5740\u8f6c\u6362\u673a\u5236\u7ec6\u8282\u76f8\u5173\uff0c // \u8fd9\u6837\u7684\u8bbe\u8ba1\u80fd\u907f\u514d\u5f15\u5165\u9519\u8bef\u7684\u6807\u5fd7\u4f4d } // \u68c0\u67e5\u5185\u6838\u5730\u5740\u7a7a\u95f4\u7684\u591a\u7ea7\u9875\u8868\u662f\u5426\u88ab\u6b63\u786e\u8bbe\u7f6e #[allow(unused)] pub fn remap_test() { let mut kernel_space = KERNEL_SPACE.exclusive_access(); let mid_text: VirtAddr = ((stext as usize + etext as usize) / 2).into(); let mid_rodata: VirtAddr = ((srodata as usize + erodata as usize) / 2).into(); let mid_data: VirtAddr = ((sdata as usize + edata as usize) / 2).into(); assert_eq!( kernel_space.page_table.translate(mid_text.floor()).unwrap().writable(), false ); assert_eq!( kernel_space.page_table.translate(mid_rodata.floor()).unwrap().writable(), false, ); assert_eq!( kernel_space.page_table.translate(mid_data.floor()).unwrap().executable(), false, ); println!(\"remap_test passed!\"); }","title":"os/src/mm/memory_set.rs"},{"location":"ch4%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/#ossrcmmmodrs","text":"mod heap_allocator; mod address; mod frame_allocator; mod page_table; mod memory_set; use page_table::{PageTable, PTEFlags}; use address::{VPNRange, StepByOne}; pub use address::{PhysAddr, VirtAddr, PhysPageNum, VirtPageNum}; pub use frame_allocator::{FrameTracker, frame_alloc}; pub use page_table::{PageTableEntry, translated_byte_buffer}; pub use memory_set::{MemorySet, KERNEL_SPACE, MapPermission}; pub use memory_set::remap_test; pub fn init() { heap_allocator::init_heap(); // \u6211\u4eec\u6700\u5148\u8fdb\u884c\u4e86\u5168\u5c40\u52a8\u6001\u5185\u5b58\u5206\u914d\u5668\u7684\u521d\u59cb\u5316 // \u56e0\u4e3a\u63a5\u4e0b\u6765\u9a6c\u4e0a\u5c31\u8981\u7528\u5230 Rust \u7684\u5806\u6570\u636e\u7ed3\u6784 frame_allocator::init_frame_allocator(); // \u63a5\u4e0b\u6765\u6211\u4eec\u521d\u59cb\u5316\u7269\u7406\u9875\u5e27\u7ba1\u7406\u5668\uff08\u5185\u542b\u5806\u6570\u636e\u7ed3\u6784 Vec<T> \uff09\u4f7f\u80fd\u53ef\u7528\u7269\u7406\u9875\u5e27\u7684\u5206\u914d\u548c\u56de\u6536\u80fd\u529b KERNEL_SPACE.exclusive_access().activate(); // \u6700\u540e\u6211\u4eec\u521b\u5efa\u5185\u6838\u5730\u5740\u7a7a\u95f4\u5e76\u8ba9 CPU \u5f00\u542f\u5206\u9875\u6a21\u5f0f\uff0c MMU \u5728\u5730\u5740\u8f6c\u6362\u7684\u65f6\u5019\u4f7f\u7528\u5185\u6838\u7684\u591a\u7ea7\u9875\u8868 }","title":"os/src/mm/mod.rs"},{"location":"ch4%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/#ossrcmmpage_tablers","text":"// \u9875\u8868\u4e2d\u7684\u9875\u8868\u9879\u7684\u7d22\u5f15\u5176\u5b9e\u662f\u865a\u62df\u5730\u5740\u4e2d\u7684\u865a\u62df\u9875\u53f7\uff0c\u9875\u8868\u9879\u7684\u91cd\u8981\u5185\u5bb9\u662f\u7269\u7406\u5730\u5740\u7684\u7269\u7406\u9875\u5e27\u53f7\u3002 // \u4e3a\u4e86\u80fd\u591f\u7075\u6d3b\u5730\u5728\u865a\u62df\u5730\u5740\u3001\u7269\u7406\u5730\u5740\u3001\u865a\u62df\u9875\u53f7\u3001\u7269\u7406\u9875\u53f7\u4e4b\u95f4\u8fdb\u884c\u5404\u79cd\u8f6c\u6362 // \u67e5\u9875\u8868\u4ee5\u8bbf\u95ee\u4e0d\u540c\u5730\u5740\u7a7a\u95f4\u7684\u6570\u636e \u3002\u5728\u5185\u6838\u5730\u5740\u7a7a\u95f4\u4e2d\u6267\u884c\u7684\u5185\u6838\u4ee3\u7801\u5e38\u5e38\u9700\u8981\u8bfb\u5199\u5e94\u7528\u7684\u5730\u5740\u7a7a\u95f4\u4e2d\u7684\u6570\u636e\uff0c // \u8fd9\u65e0\u6cd5\u7b80\u5355\u7684\u901a\u8fc7\u4e00\u6b21\u8bbf\u5b58\u6765\u89e3\u51b3\uff0c\u800c\u662f\u9700\u8981\u624b\u52a8\u67e5\u7528\u6237\u6001\u5e94\u7528\u7684\u5730\u5740\u7a7a\u95f4\u7684\u9875\u8868\uff0c // \u77e5\u9053\u7528\u6237\u6001\u5e94\u7528\u7684\u865a\u5730\u5740\u5bf9\u5e94\u7684\u7269\u7406\u5730\u5740\u540e\uff0c\u8f6c\u6362\u6210\u5bf9\u5e94\u7684\u5185\u6838\u6001\u7684\u865a\u5730\u5740\uff0c\u624d\u80fd\u8bbf\u95ee\u5e94\u7528\u5730\u5740\u7a7a\u95f4\u4e2d\u7684\u6570\u636e\u3002 // \u5982\u679c\u8bbf\u95ee\u5e94\u7528\u5730\u5740\u7a7a\u95f4\u4e2d\u7684\u6570\u636e\u8de8\u4e86\u591a\u4e2a\u9875\uff0c\u8fd8\u9700\u8981\u6ce8\u610f\u5904\u7406\u5730\u5740\u7684\u8fb9\u754c\u6761\u4ef6 use super::{frame_alloc, PhysPageNum, FrameTracker, VirtPageNum, VirtAddr, StepByOne}; use alloc::vec::Vec; use alloc::vec; use bitflags::*; // bitflags \u662f\u4e00\u4e2a Rust \u4e2d\u5e38\u7528\u6765\u6bd4\u7279\u6807\u5fd7\u4f4d\u7684 crate \u3002\u5b83\u63d0\u4f9b\u4e86\u4e00\u4e2a bitflags! \u5b8f\uff0c // \u5982\u4e0a\u9762\u7684\u4ee3\u7801\u6bb5\u6240\u5c55\u793a\u7684\u90a3\u6837\uff0c\u53ef\u4ee5\u5c06\u4e00\u4e2a u8 \u5c01\u88c5\u6210\u4e00\u4e2a\u6807\u5fd7\u4f4d\u7684\u96c6\u5408\u7c7b\u578b\uff0c\u652f\u6301\u4e00\u4e9b\u5e38\u89c1\u7684\u96c6\u5408\u8fd0\u7b97 bitflags! { pub struct PTEFlags: u8 { const V = 1 << 0; const R = 1 << 1; const W = 1 << 2; const X = 1 << 3; const U = 1 << 4; const G = 1 << 5; const A = 1 << 6; const D = 1 << 7; } } // \u5b9e\u73b0\u9875\u8868\u9879 PageTableEntry // 64\u4f4d // |Reserved PPN[2] PPN[1] PPN[0] RSW D A G U X W R V| #[derive(Copy, Clone)] // \u8ba9\u7f16\u8bd1\u5668\u81ea\u52a8\u4e3a PageTableEntry \u5b9e\u73b0 Copy/Clone Trait\uff0c\u6765\u8ba9\u8fd9\u4e2a\u7c7b\u578b\u4ee5\u503c\u8bed\u4e49\u8d4b\u503c/\u4f20\u53c2\u7684\u65f6\u5019\u4e0d\u4f1a\u53d1\u751f\u6240\u6709\u6743\u8f6c\u79fb\uff0c // \u800c\u662f\u62f7\u8d1d\u4e00\u4efd\u65b0\u7684\u526f\u672c\u3002\u4ece\u8fd9\u4e00\u70b9\u6765\u8bf4 PageTableEntry \u5c31\u548c usize \u4e00\u6837\uff0c // \u56e0\u4e3a\u5b83\u4e5f\u53ea\u662f\u540e\u8005\u7684\u4e00\u5c42\u7b80\u5355\u5305\u88c5\uff0c\u5e76\u89e3\u91ca\u4e86 usize \u5404\u4e2a\u6bd4\u7279\u6bb5\u7684\u542b\u4e49 #[repr(C)] // \u9875\u8868\u9879 63-54 (Reserved) 53-10 (44\u4f4d\u7269\u7406\u9875\u53f7) 9-8 (RSW) 7-0 (8\u4f4d\u6807\u5fd7\u4f4d) pub struct PageTableEntry { pub bits: usize, } impl PageTableEntry { pub fn new(ppn: PhysPageNum, flags: PTEFlags) -> Self { PageTableEntry { bits: ppn.0 << 10 | flags.bits as usize, } } // \u6211\u4eec\u53ef\u4ee5\u4ece\u4e00\u4e2a\u7269\u7406\u9875\u53f7 PhysPageNum \u548c\u4e00\u4e2a\u9875\u8868\u9879\u6807\u5fd7\u4f4d PTEFlags \u751f\u6210\u4e00\u4e2a\u9875\u8868\u9879 PageTableEntry \u5b9e\u4f8b pub fn empty() -> Self { PageTableEntry { bits: 0, } } // \u6211\u4eec\u4e5f\u53ef\u4ee5\u901a\u8fc7 empty \u65b9\u6cd5\u751f\u6210\u4e00\u4e2a\u5168\u96f6\u7684\u9875\u8868\u9879\uff0c\u6ce8\u610f\u8fd9\u9690\u542b\u7740\u8be5\u9875\u8868\u9879\u7684 V \u6807\u5fd7\u4f4d\u4e3a 0 \uff0c // \u56e0\u6b64\u5b83\u662f\u4e0d\u5408\u6cd5\u7684 pub fn ppn(&self) -> PhysPageNum { (self.bits >> 10 & ((1usize << 44) - 1)).into() // \u548c 44 \u4e2a 1 \u76f8\u4e0e\uff0c\u76f8\u5f53\u4e8e\u53bb\u6389reserved \u90e8\u5206 } // \u4ece\u4e00\u4e2a\u9875\u8868\u9879\u5c06 ppn \u53d6\u51fa pub fn flags(&self) -> PTEFlags { PTEFlags::from_bits(self.bits as u8).unwrap() } // \u4ece\u4e00\u4e2a\u9875\u8868\u9879\u5c06 flags 8\u4e2a\u6807\u5fd7\u4f4d\u53d6\u51fa pub fn is_valid(&self) -> bool { (self.flags() & PTEFlags::V) != PTEFlags::empty() } pub fn readable(&self) -> bool { (self.flags() & PTEFlags::R) != PTEFlags::empty() } pub fn writable(&self) -> bool { (self.flags() & PTEFlags::W) != PTEFlags::empty() } pub fn executable(&self) -> bool { (self.flags() & PTEFlags::X) != PTEFlags::empty() } // \u4e00\u4e9b\u8f85\u52a9\u51fd\u6570(Helper Function)\uff0c\u53ef\u4ee5\u5feb\u901f\u5224\u65ad\u4e00\u4e2a\u9875\u8868\u9879\u7684 V/R/W/X \u6807\u5fd7\u4f4d\u662f\u5426\u4e3a 1 } // \u9875\u8868 pub struct PageTable { root_ppn: PhysPageNum, frames: Vec<FrameTracker>, // \u6bcf\u4e2a\u5e94\u7528\u7684\u5730\u5740\u7a7a\u95f4\u90fd\u5bf9\u5e94\u4e00\u4e2a\u4e0d\u540c\u7684\u591a\u7ea7\u9875\u8868\uff0c // \u8fd9\u4e5f\u5c31\u610f\u5473\u8fd9\u4e0d\u540c\u9875\u8868\u7684\u8d77\u59cb\u5730\u5740\uff08\u5373\u9875\u8868\u6839\u8282\u70b9\u7684\u5730\u5740\uff09\u662f\u4e0d\u4e00\u6837\u7684\u3002 // \u56e0\u6b64 PageTable``\u8981\u4fdd\u5b58\u5b83\u6839\u8282\u70b9\u7684\u7269\u7406\u9875\u53f7 ``root_ppn \u4f5c\u4e3a\u9875\u8868\u552f\u4e00\u7684\u533a\u5206\u6807\u5fd7\u3002 // \u6b64\u5916\uff0c\u5411\u91cf frames \u4ee5 FrameTracker \u7684\u5f62\u5f0f\u4fdd\u5b58\u4e86\u9875\u8868\u6240\u6709\u7684\u8282\u70b9\uff08\u5305\u62ec\u6839\u8282\u70b9\uff09\u6240\u5728\u7684\u7269\u7406\u9875\u5e27\u3002 // \u8fd9\u4e0e\u7269\u7406\u9875\u5e27\u7ba1\u7406\u6a21\u5757\u7684\u6d4b\u8bd5\u7a0b\u5e8f\u662f\u4e00\u4e2a\u601d\u8def\uff0c\u5373\u5c06\u8fd9\u4e9b FrameTracker \u7684\u751f\u547d\u5468\u671f\u8fdb\u4e00\u6b65\u7ed1\u5b9a\u5230 PageTable \u4e0b\u9762\u3002 // \u5f53 PageTable \u751f\u547d\u5468\u671f\u7ed3\u675f\u540e\uff0c\u5411\u91cf frames \u91cc\u9762\u7684\u90a3\u4e9b FrameTracker \u4e5f\u4f1a\u88ab\u56de\u6536\uff0c // \u4e5f\u5c31\u610f\u5473\u7740\u5b58\u653e\u591a\u7ea7\u9875\u8868\u8282\u70b9\u7684\u90a3\u4e9b\u7269\u7406\u9875\u5e27\u88ab\u56de\u6536\u4e86 } /// Assume that it won't oom when creating/mapping. impl PageTable { // \u5f53\u6211\u4eec\u901a\u8fc7 new \u65b9\u6cd5\u65b0\u5efa\u4e00\u4e2a PageTable \u7684\u65f6\u5019\uff0c\u5b83\u53ea\u9700\u6709\u4e00\u4e2a\u6839\u8282\u70b9\u3002 // \u4e3a\u6b64\u6211\u4eec\u9700\u8981\u5206\u914d\u4e00\u4e2a\u7269\u7406\u9875\u5e27 FrameTracker \u5e76\u6302\u5728\u5411\u91cf frames \u4e0b\uff0c\u7136\u540e\u66f4\u65b0\u6839\u8282\u70b9\u7684\u7269\u7406\u9875\u53f7 root_ppn pub fn new() -> Self { let frame = frame_alloc().unwrap(); PageTable { root_ppn: frame.ppn, frames: vec![frame], } } /// Temporarily used to get arguments from user space. pub fn from_token(satp: usize) -> Self { Self { root_ppn: PhysPageNum::from(satp & ((1usize << 44) - 1)), frames: Vec::new(), } } // // from_token \u53ef\u4ee5\u4e34\u65f6\u521b\u5efa\u4e00\u4e2a\u4e13\u7528\u6765\u624b\u52a8\u67e5\u9875\u8868\u7684 PageTable \uff0c // \u5b83\u4ec5\u6709\u4e00\u4e2a\u4ece\u4f20\u5165\u7684 satp token \u4e2d\u5f97\u5230\u7684\u591a\u7ea7\u9875\u8868\u6839\u8282\u70b9\u7684\u7269\u7406\u9875\u53f7\uff0c\u5b83\u7684 frames \u5b57\u6bb5\u4e3a\u7a7a\uff0c // \u4e5f\u5373\u4e0d\u5b9e\u9645\u63a7\u5236\u4efb\u4f55\u8d44\u6e90 // \u5f53\u9047\u5230\u9700\u8981\u67e5\u4e00\u4e2a\u7279\u5b9a\u9875\u8868\uff08\u975e\u5f53\u524d\u6b63\u5904\u5728\u7684\u5730\u5740\u7a7a\u95f4\u7684\u9875\u8868\u65f6\uff09\uff0c // \u4fbf\u53ef\u5148\u901a\u8fc7 PageTable::from_token \u65b0\u5efa\u4e00\u4e2a\u9875\u8868\uff0c\u518d\u8c03\u7528\u5b83\u7684 translate \u65b9\u6cd5\u67e5\u9875\u8868 // \u5728\u591a\u7ea7\u9875\u8868\u627e\u5230\u4e00\u4e2a\u865a\u62df\u9875\u53f7\u5bf9\u5e94\u7684\u9875\u8868\u9879\u7684\u53ef\u53d8\u5f15\u7528\u3002 // \u5982\u679c\u5728\u904d\u5386\u7684\u8fc7\u7a0b\u4e2d\u53d1\u73b0\u6709\u8282\u70b9\u5c1a\u672a\u521b\u5efa\u5219\u4f1a\u65b0\u5efa\u4e00\u4e2a\u8282\u70b9 fn find_pte_create(&mut self, vpn: VirtPageNum) -> Option<&mut PageTableEntry> { let idxs = vpn.indexes(); // \u53d6\u51fa\u4e09\u7ea7\u7d22\u5f15 let mut ppn = self.root_ppn; let mut result: Option<&mut PageTableEntry> = None; for i in 0..3 { let pte = &mut ppn.get_pte_array()[idxs[i]]; // \u5206\u522b\u53d6\u51fa \u7b2c\u4e09\u7ea7\u7d22\u5f15 \u7b2c\u4e8c\u7ea7\u7d22\u5f15 \u7b2c\u4e00\u7ea7\u7d22\u5f15(\u5373\u7269\u7406\u9875\u53f7) if i == 2 { // \u627e\u5230 \u7269\u7406\u9875\u53f7 result = Some(pte); // \u8fd4\u56de\u7269\u7406\u9875\u53f7 break; } if !pte.is_valid() { let frame = frame_alloc().unwrap(); // create \u521b\u5efa\u4e00\u4e2a\u7269\u7406\u9875\u5e27\uff0c\u8fd4\u56de\u4ed6\u7684\u7269\u7406\u9875\u53f7 *pte = PageTableEntry::new(frame.ppn, PTEFlags::V); // \u751f\u6210\u8fd9\u4e2a\u7269\u7406\u9875\u53f7\u5bf9\u5e94\u7684\u7269\u7406\u9875\u8868\u9879 self.frames.push(frame); // \u5c06\u8fd9\u4e2a\u7269\u7406\u9875\u5e27\u5b58\u653e\u5728 \u5168\u5c40\u7ba1\u7406\u5668\u7684 Vector\u4e2d } ppn = pte.ppn(); } // \u53d8\u91cf ppn \u8868\u793a\u5f53\u524d\u8282\u70b9\u7684\u7269\u7406\u9875\u53f7\uff0c\u6700\u5f00\u59cb\u6307\u5411\u591a\u7ea7\u9875\u8868\u7684\u6839\u8282\u70b9\u3002 // \u968f\u540e\u6bcf\u6b21\u5faa\u73af\u901a\u8fc7 get_pte_array \u5c06\u53d6\u51fa\u5f53\u524d\u8282\u70b9\u7684\u9875\u8868\u9879\u6570\u7ec4\uff0c // \u5e76\u6839\u636e\u5f53\u524d\u7ea7\u9875\u7d22\u5f15\u627e\u5230\u5bf9\u5e94\u7684\u9875\u8868\u9879\u3002\u5982\u679c\u5f53\u524d\u8282\u70b9\u662f\u4e00\u4e2a\u53f6\u8282\u70b9\uff0c // \u90a3\u4e48\u76f4\u63a5\u8fd4\u56de\u8fd9\u4e2a\u9875\u8868\u9879\u7684\u53ef\u53d8\u5f15\u7528\uff1b\u5426\u5219\u5c1d\u8bd5\u5411\u4e0b\u8d70\u3002\u8d70\u4e0d\u4e0b\u53bb\u7684\u8bdd\u5c31\u65b0\u5efa\u4e00\u4e2a\u8282\u70b9\uff0c // \u66f4\u65b0\u4f5c\u4e3a\u4e0b\u7ea7\u8282\u70b9\u6307\u9488\u7684\u9875\u8868\u9879\uff0c\u5e76\u5c06\u65b0\u5206\u914d\u7684\u7269\u7406\u9875\u5e27\u79fb\u52a8\u5230\u5411\u91cf frames \u4e2d\u65b9\u4fbf\u540e\u7eed\u7684\u81ea\u52a8\u56de\u6536\u3002 // \u6ce8\u610f\u5728\u66f4\u65b0\u9875\u8868\u9879\u7684\u65f6\u5019\uff0c\u4e0d\u4ec5\u8981\u66f4\u65b0\u7269\u7406\u9875\u53f7\uff0c\u8fd8\u8981\u5c06\u6807\u5fd7\u4f4d V \u7f6e 1\uff0c // \u4e0d\u7136\u786c\u4ef6\u5728\u67e5\u591a\u7ea7\u9875\u8868\u7684\u65f6\u5019\uff0c\u4f1a\u8ba4\u4e3a\u8fd9\u4e2a\u9875\u8868\u9879\u4e0d\u5408\u6cd5\uff0c\u4ece\u800c\u89e6\u53d1 Page Fault \u800c\u4e0d\u80fd\u5411\u4e0b\u8d70 result } fn find_pte(&self, vpn: VirtPageNum) -> Option<&PageTableEntry> { let idxs = vpn.indexes(); let mut ppn = self.root_ppn; let mut result: Option<&PageTableEntry> = None; for i in 0..3 { let pte = &ppn.get_pte_array()[idxs[i]]; if i == 2 { result = Some(pte); break; } if !pte.is_valid() { return None; } ppn = pte.ppn(); } // PageTable::find_pte \u4e0e find_pte_create \u7684\u4e0d\u540c\u5728\u4e8e\u5f53\u627e\u4e0d\u5230\u5408\u6cd5\u53f6\u5b50\u8282\u70b9\u7684\u65f6\u5019\u4e0d\u4f1a\u65b0\u5efa\u53f6\u5b50\u8282\u70b9\u800c\u662f\u76f4\u63a5\u8fd4\u56de None \u5373\u67e5\u627e\u5931\u8d25\u3002 // \u56e0\u6b64\uff0c\u5b83\u4e0d\u4f1a\u5c1d\u8bd5\u5bf9\u9875\u8868\u672c\u8eab\u8fdb\u884c\u4fee\u6539\uff0c\u4f46\u662f\u6ce8\u610f\u5b83\u8fd4\u56de\u7684\u53c2\u6570\u7c7b\u578b\u662f\u9875\u8868\u9879\u7684\u53ef\u53d8\u5f15\u7528\uff0c // \u4e5f\u5373\u5b83\u5141\u8bb8\u6211\u4eec\u4fee\u6539\u9875\u8868\u9879\u3002\u4ece find_pte \u7684\u5b9e\u73b0\u8fd8\u53ef\u4ee5\u770b\u51fa\uff0c\u5373\u4f7f\u627e\u5230\u7684\u9875\u8868\u9879\u4e0d\u5408\u6cd5\uff0c // \u8fd8\u662f\u4f1a\u5c06\u5176\u8fd4\u56de\u56de\u53bb\u800c\u4e0d\u662f\u8fd4\u56de None \u3002\u8fd9\u8bf4\u660e\u5728\u76ee\u524d\u7684\u5b9e\u73b0\u4e2d\uff0c\u9875\u8868\u548c\u9875\u8868\u9879\u662f\u76f8\u5bf9\u89e3\u8026\u5408\u7684 result } // \u591a\u7ea7\u9875\u8868\u5e76\u4e0d\u662f\u88ab\u521b\u5efa\u51fa\u6765\u4e4b\u540e\u5c31\u4e0d\u518d\u53d8\u5316\u7684\uff0c // \u4e3a\u4e86 MMU \u80fd\u591f\u901a\u8fc7\u5730\u5740\u8f6c\u6362\u6b63\u786e\u627e\u5230\u5e94\u7528\u5730\u5740\u7a7a\u95f4\u4e2d\u7684\u6570\u636e\u5b9e\u9645\u88ab\u5185\u6838\u653e\u5728\u5185\u5b58\u4e2d\u4f4d\u7f6e\uff0c // \u64cd\u4f5c\u7cfb\u7edf\u9700\u8981\u52a8\u6001\u7ef4\u62a4\u4e00\u4e2a\u865a\u62df\u9875\u53f7\u5230\u9875\u8868\u9879\u7684\u6620\u5c04\uff0c\u652f\u6301\u63d2\u5165/\u5220\u9664\u952e\u503c\u5bf9 // \u63a5\u4e0b\u6765\u4ecb\u7ecd\u5efa\u7acb\u548c\u62c6\u9664\u865a\u5b9e\u5730\u5740\u6620\u5c04\u5173\u7cfb\u7684 map \u548c unmap \u65b9\u6cd5\u662f\u5982\u4f55\u5b9e\u73b0\u7684\u3002 // \u5b83\u4eec\u90fd\u4f9d\u8d56\u4e8e\u4e00\u4e2a\u5f88\u91cd\u8981\u7684\u8fc7\u7a0b\uff0c\u5373\u5728\u591a\u7ea7\u9875\u8868\u4e2d\u627e\u5230\u4e00\u4e2a\u865a\u62df\u5730\u5740\u5bf9\u5e94\u7684\u9875\u8868\u9879\u3002\u627e\u5230\u4e4b\u540e\uff0c // \u53ea\u8981\u4fee\u6539\u9875\u8868\u9879\u7684\u5185\u5bb9\u5373\u53ef\u5b8c\u6210\u952e\u503c\u5bf9\u7684\u63d2\u5165\u548c\u5220\u9664\u3002\u5728\u5bfb\u627e\u9875\u8868\u9879\u7684\u65f6\u5019\uff0c // \u53ef\u80fd\u51fa\u73b0\u9875\u8868\u7684\u4e2d\u95f4\u7ea7\u8282\u70b9\u8fd8\u672a\u88ab\u521b\u5efa\u7684\u60c5\u51b5\uff0c\u8fd9\u4e2a\u65f6\u5019\u6211\u4eec\u9700\u8981\u624b\u52a8\u5206\u914d\u4e00\u4e2a\u7269\u7406\u9875\u5e27\u6765\u5b58\u653e\u8fd9\u4e2a\u8282\u70b9\uff0c // \u5e76\u5c06\u8fd9\u4e2a\u8282\u70b9\u63a5\u5165\u5230\u5f53\u524d\u7684\u591a\u7ea7\u9875\u8868\u7684\u67d0\u7ea7\u4e2d // \u53ea\u9700\u6839\u636e\u865a\u62df\u9875\u53f7\u627e\u5230\u9875\u8868\u9879\uff0c\u7136\u540e\u4fee\u6539\u6216\u8005\u76f4\u63a5\u6e05\u7a7a\u5176\u5185\u5bb9\u5373\u53ef #[allow(unused)] pub fn map(&mut self, vpn: VirtPageNum, ppn: PhysPageNum, flags: PTEFlags) { let pte = self.find_pte_create(vpn).unwrap(); // \u67e5\u627e\u4e00\u4e2a\u865a\u62df\u9875\u53f7 assert!(!pte.is_valid(), \"vpn {:?} is mapped before mapping\", vpn); *pte = PageTableEntry::new(ppn, flags | PTEFlags::V); // \u521b\u5efa\u4e00\u4e2a\u9875\u8868\u9879\uff0c \u5b58\u653e\u8fd9\u4e2a\u865a\u62df\u9875\u53f7 \u6240\u6620\u5c04\u7684 \u7269\u7406\u9875\u53f7 } // \u901a\u8fc7 map \u65b9\u6cd5\u6765\u5728\u591a\u7ea7\u9875\u8868\u4e2d\u63d2\u5165\u4e00\u4e2a\u952e\u503c\u5bf9\uff0c // \u6ce8\u610f\u8fd9\u91cc\u5c06\u7269\u7406\u9875\u53f7 ppn \u548c\u9875\u8868\u9879\u6807\u5fd7\u4f4d flags \u4f5c\u4e3a\u4e0d\u540c\u7684\u53c2\u6570\u4f20\u5165 #[allow(unused)] pub fn unmap(&mut self, vpn: VirtPageNum) { let pte = self.find_pte_create(vpn).unwrap(); // \u521b\u5efa\u4e00\u4e2a\u865a\u62df\u9875\u8868\u9879 assert!(pte.is_valid(), \"vpn {:?} is invalid before unmapping\", vpn); *pte = PageTableEntry::empty(); // \u5c06\u9875\u8868\u9879\u7684\u6240\u6709\u4f4d \u7f6e0 } // \u901a\u8fc7 unmap \u65b9\u6cd5\u6765\u5220\u9664\u4e00\u4e2a\u952e\u503c\u5bf9\uff0c\u5728\u8c03\u7528\u65f6\u4ec5\u9700\u7ed9\u51fa\u4f5c\u4e3a\u7d22\u5f15\u7684\u865a\u62df\u9875\u53f7\u5373\u53ef pub fn translate(&self, vpn: VirtPageNum) -> Option<PageTableEntry> { self.find_pte(vpn) .map(|pte| {pte.clone()}) } // \u8c03\u7528 find_pte \u6765\u5b9e\u73b0\uff0c\u5982\u679c\u80fd\u591f\u627e\u5230\u9875\u8868\u9879\uff0c\u90a3\u4e48\u5b83\u4f1a\u5c06\u9875\u8868\u9879\u62f7\u8d1d\u4e00\u4efd\u5e76\u8fd4\u56de\uff0c\u5426\u5219\u5c31\u8fd4\u56de\u4e00\u4e2a None pub fn token(&self) -> usize { 8usize << 60 | self.root_ppn.0 } // PageTable::token \u4f1a\u6309\u7167 satp CSR \u683c\u5f0f\u8981\u6c42 \u6784\u9020\u4e00\u4e2a\u65e0\u7b26\u53f7 64 \u4f4d\u65e0\u7b26\u53f7\u6574\u6570\uff0c // \u4f7f\u5f97\u5176\u5206\u9875\u6a21\u5f0f\u4e3a SV39 \uff0c\u4e14\u5c06\u5f53\u524d\u591a\u7ea7\u9875\u8868\u7684\u6839\u8282\u70b9\u6240\u5728\u7684\u7269\u7406\u9875\u53f7\u586b\u5145\u8fdb\u53bb } pub fn translated_byte_buffer(token: usize, ptr: *const u8, len: usize) -> Vec<&'static mut [u8]> { let page_table = PageTable::from_token(token); let mut start = ptr as usize; let end = start + len; let mut v = Vec::new(); while start < end { let start_va = VirtAddr::from(start); let mut vpn = start_va.floor(); let ppn = page_table .translate(vpn) .unwrap() .ppn(); vpn.step(); let mut end_va: VirtAddr = vpn.into(); end_va = end_va.min(VirtAddr::from(end)); if end_va.page_offset() == 0 { v.push(&mut ppn.get_bytes_array()[start_va.page_offset()..]); } else { v.push(&mut ppn.get_bytes_array()[start_va.page_offset()..end_va.page_offset()]); } start = end_va.into(); } v }","title":"os/src/mm/page_table.rs"},{"location":"ch4%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/#ossrcsyncmodrs","text":"mod up; pub use up::UPSafeCell;","title":"os/src/sync/mod.rs"},{"location":"ch4%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/#ossrcsyncuprs","text":"use core::cell::{RefCell, RefMut}; /// Wrap a static data structure inside it so that we are /// able to access it without any `unsafe`. /// /// We should only use it in uniprocessor. /// /// In order to get mutable reference of inner data, call /// `exclusive_access`. pub struct UPSafeCell<T> { /// inner data inner: RefCell<T>, } unsafe impl<T> Sync for UPSafeCell<T> {} impl<T> UPSafeCell<T> { /// User is responsible to guarantee that inner struct is only used in /// uniprocessor. pub unsafe fn new(value: T) -> Self { Self { inner: RefCell::new(value) } } /// Panic if the data has been borrowed. pub fn exclusive_access(&self) -> RefMut<'_, T> { self.inner.borrow_mut() } }","title":"os/src/sync/up.rs"},{"location":"ch4%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/#ossrcsyscallfsrs","text":"// \u67e5\u9875\u8868\u4ee5\u8bbf\u95ee\u4e0d\u540c\u5730\u5740\u7a7a\u95f4\u7684\u6570\u636e \u3002\u5728\u5185\u6838\u5730\u5740\u7a7a\u95f4\u4e2d\u6267\u884c\u7684\u5185\u6838\u4ee3\u7801\u5e38\u5e38\u9700\u8981\u8bfb\u5199\u5e94\u7528\u7684\u5730\u5740\u7a7a\u95f4\u4e2d\u7684\u6570\u636e\uff0c // \u8fd9\u65e0\u6cd5\u7b80\u5355\u7684\u901a\u8fc7\u4e00\u6b21\u8bbf\u5b58\u6765\u89e3\u51b3\uff0c\u800c\u662f\u9700\u8981\u624b\u52a8\u67e5\u7528\u6237\u6001\u5e94\u7528\u7684\u5730\u5740\u7a7a\u95f4\u7684\u9875\u8868\uff0c // \u77e5\u9053\u7528\u6237\u6001\u5e94\u7528\u7684\u865a\u5730\u5740\u5bf9\u5e94\u7684\u7269\u7406\u5730\u5740\u540e\uff0c\u8f6c\u6362\u6210\u5bf9\u5e94\u7684\u5185\u6838\u6001\u7684\u865a\u5730\u5740\uff0c\u624d\u80fd\u8bbf\u95ee\u5e94\u7528\u5730\u5740\u7a7a\u95f4\u4e2d\u7684\u6570\u636e\u3002 // \u5982\u679c\u8bbf\u95ee\u5e94\u7528\u5730\u5740\u7a7a\u95f4\u4e2d\u7684\u6570\u636e\u8de8\u4e86\u591a\u4e2a\u9875\uff0c\u8fd8\u9700\u8981\u6ce8\u610f\u5904\u7406\u5730\u5740\u7684\u8fb9\u754c\u6761\u4ef6 use crate::mm::translated_byte_buffer; use crate::task::current_user_token; const FD_STDOUT: usize = 1; pub fn sys_write(fd: usize, buf: *const u8, len: usize) -> isize { match fd { FD_STDOUT => { let buffers = translated_byte_buffer(current_user_token(), buf, len); for buffer in buffers { print!(\"{}\", core::str::from_utf8(buffer).unwrap()); } len as isize }, _ => { panic!(\"Unsupported fd in sys_write!\"); } } }","title":"os/src/syscall/fs.rs"},{"location":"ch4%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/#ossrcsyscallmodrs","text":"const SYSCALL_WRITE: usize = 64; const SYSCALL_EXIT: usize = 93; const SYSCALL_YIELD: usize = 124; const SYSCALL_GET_TIME: usize = 169; mod fs; mod process; use fs::*; use process::*; pub fn syscall(syscall_id: usize, args: [usize; 3]) -> isize { match syscall_id { SYSCALL_WRITE => sys_write(args[0], args[1] as *const u8, args[2]), SYSCALL_EXIT => sys_exit(args[0] as i32), SYSCALL_YIELD => sys_yield(), SYSCALL_GET_TIME => sys_get_time(), _ => panic!(\"Unsupported syscall_id: {}\", syscall_id), } }","title":"os/src/syscall/mod.rs"},{"location":"ch4%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/#ossrcsyscallprocessrs","text":"use crate::task::{ suspend_current_and_run_next, exit_current_and_run_next, }; use crate::timer::get_time_ms; pub fn sys_exit(exit_code: i32) -> ! { println!(\"[kernel] Application exited with code {}\", exit_code); exit_current_and_run_next(); panic!(\"Unreachable in sys_exit!\"); } pub fn sys_yield() -> isize { suspend_current_and_run_next(); 0 } pub fn sys_get_time() -> isize { get_time_ms() as isize }","title":"os/src/syscall/process.rs"},{"location":"ch4%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/#ossrctaskcontextrs","text":"use crate::trap::trap_return; #[repr(C)] pub struct TaskContext { ra: usize, sp: usize, s: [usize; 12], } impl TaskContext { pub fn zero_init() -> Self { Self { ra: 0, sp: 0, s: [0; 12], } } pub fn goto_trap_return(kstack_ptr: usize) -> Self { Self { ra: trap_return as usize, sp: kstack_ptr, s: [0; 12], } } }","title":"os/src/task/context.rs"},{"location":"ch4%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/#ossrctaskswitchrs","text":"use super::TaskContext; use core::arch::global_asm; global_asm!(include_str!(\"switch.S\")); extern \"C\" { pub fn __switch( current_task_cx_ptr: *mut TaskContext, next_task_cx_ptr: *const TaskContext ); // \u6211\u4eec\u4f1a\u5c06\u8fd9\u6bb5\u6c47\u7f16\u4ee3\u7801\u4e2d\u7684\u5168\u5c40\u7b26\u53f7 __switch \u89e3\u91ca\u4e3a\u4e00\u4e2a Rust \u51fd\u6570 // \u6211\u4eec\u4f1a\u8c03\u7528\u8be5\u51fd\u6570\u6765\u5b8c\u6210\u5207\u6362\u529f\u80fd\u800c\u4e0d\u662f\u76f4\u63a5\u8df3\u8f6c\u5230\u7b26\u53f7 __switch \u7684\u5730\u5740\u3002 // \u56e0\u6b64\u5728\u8c03\u7528\u524d\u540e Rust \u7f16\u8bd1\u5668\u4f1a\u81ea\u52a8\u5e2e\u52a9\u6211\u4eec\u63d2\u5165\u4fdd\u5b58/\u6062\u590d\u8c03\u7528\u8005\u4fdd\u5b58\u5bc4\u5b58\u5668\u7684\u6c47\u7f16\u4ee3\u7801 }","title":"os/src/task/switch.rs"},{"location":"ch4%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/#ossrctaskswitchs","text":".altmacro .macro SAVE_SN n sd s\\n, (\\n+2)*8(a0) .endm .macro LOAD_SN n ld s\\n, (\\n+2)*8(a1) .endm .section .text .globl __switch __switch: # __switch( # current_task_cx_ptr: *mut TaskContext, # next_task_cx_ptr: *const TaskContext # ) # save kernel stack of current task sd sp, 8(a0) # save ra & s0~s11 of current execution sd ra, 0(a0) .set n, 0 .rept 12 SAVE_SN %n .set n, n + 1 .endr # restore ra & s0~s11 of next execution ld ra, 0(a1) .set n, 0 .rept 12 LOAD_SN %n .set n, n + 1 .endr # restore kernel stack of next task ld sp, 8(a1) ret","title":"os/src/task/switch.S"},{"location":"ch4%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/#ossrctaskrs","text":"// \u64cd\u4f5c\u7cfb\u7edf\u9700\u8981\u6269\u5c55\u4efb\u52a1\u63a7\u5236\u5757 TaskControlBlock \u7684\u7ba1\u7406\u8303\u56f4\uff0c // \u4f7f\u5f97\u64cd\u4f5c\u7cfb\u7edf\u80fd\u7ba1\u7406\u62e5\u6709\u72ec\u7acb\u9875\u8868\u548c\u5355\u4e00\u865a\u62df\u5730\u5740\u7a7a\u95f4\u7684\u5e94\u7528\u7a0b\u5e8f\u7684\u8fd0\u884c use crate::mm::{MemorySet, MapPermission, PhysPageNum, KERNEL_SPACE, VirtAddr}; use crate::trap::{TrapContext, trap_handler}; use crate::config::{TRAP_CONTEXT, kernel_stack_position}; use super::TaskContext; pub struct TaskControlBlock { pub task_status: TaskStatus, pub task_cx: TaskContext, pub memory_set: MemorySet, pub trap_cx_ppn: PhysPageNum, pub base_size: usize, } impl TaskControlBlock { pub fn get_trap_cx(&self) -> &'static mut TrapContext { self.trap_cx_ppn.get_mut() } pub fn get_user_token(&self) -> usize { self.memory_set.token() } pub fn new(elf_data: &[u8], app_id: usize) -> Self { // memory_set with elf program headers/trampoline/trap context/user stack let (memory_set, user_sp, entry_point) = MemorySet::from_elf(elf_data); // \u89e3\u6790\u4f20\u5165\u7684 ELF \u683c\u5f0f\u6570\u636e\u6784\u9020\u5e94\u7528\u7684\u5730\u5740\u7a7a\u95f4 memory_set \u5e76\u83b7\u5f97\u5176\u4ed6\u4fe1\u606f let trap_cx_ppn = memory_set .translate(VirtAddr::from(TRAP_CONTEXT).into()) .unwrap() .ppn(); // \u4ece\u5730\u5740\u7a7a\u95f4 memory_set \u4e2d\u67e5\u591a\u7ea7\u9875\u8868\u627e\u5230\u5e94\u7528\u5730\u5740\u7a7a\u95f4\u4e2d\u7684 Trap \u4e0a\u4e0b\u6587\u5b9e\u9645\u88ab\u653e\u5728\u54ea\u4e2a\u7269\u7406\u9875\u5e27 let task_status = TaskStatus::Ready; // map a kernel-stack in kernel space let (kernel_stack_bottom, kernel_stack_top) = kernel_stack_position(app_id); KERNEL_SPACE .exclusive_access() .insert_framed_area( kernel_stack_bottom.into(), kernel_stack_top.into(), MapPermission::R | MapPermission::W, ); // \u6839\u636e\u4f20\u5165\u7684\u5e94\u7528 ID app_id \u8c03\u7528\u5728 config \u5b50\u6a21\u5757\u4e2d\u5b9a\u4e49\u7684 kernel_stack_position \u627e\u5230 \u5e94\u7528\u7684\u5185\u6838\u6808\u9884\u8ba1\u653e\u5728\u5185\u6838\u5730\u5740\u7a7a\u95f4 KERNEL_SPACE \u4e2d\u7684\u54ea\u4e2a\u4f4d\u7f6e // \u5e76\u901a\u8fc7 insert_framed_area \u5b9e\u9645\u5c06\u8fd9\u4e2a\u903b\u8f91\u6bb5 \u52a0\u5165\u5230\u5185\u6838\u5730\u5740\u7a7a\u95f4\u4e2d let task_control_block = Self { task_status, task_cx: TaskContext::goto_trap_return(kernel_stack_top), // \u5728\u5e94\u7528\u7684\u5185\u6838\u6808\u9876\u538b\u5165\u4e00\u4e2a\u8df3\u8f6c\u5230 trap_return \u800c\u4e0d\u662f __restore \u7684\u4efb\u52a1\u4e0a\u4e0b\u6587\uff0c // \u8fd9\u4e3b\u8981\u662f\u4e3a\u4e86\u80fd\u591f\u652f\u6301\u5bf9\u8be5\u5e94\u7528\u7684\u542f\u52a8\u5e76\u987a\u5229\u5207\u6362\u5230\u7528\u6237\u5730\u5740\u7a7a\u95f4\u6267\u884c\u3002 // \u5728\u6784\u9020\u65b9\u5f0f\u4e0a\uff0c\u53ea\u662f\u5c06 ra \u5bc4\u5b58\u5668\u7684\u503c\u8bbe\u7f6e\u4e3a trap_return \u7684\u5730\u5740\u3002 // trap_return \u662f\u540e\u9762\u8981\u4ecb\u7ecd\u7684\u65b0\u7248\u7684 Trap \u5904\u7406\u7684\u4e00\u90e8\u5206 memory_set, trap_cx_ppn, base_size: user_sp, // \u7528\u4e0a\u9762\u7684\u4fe1\u606f\u6765\u521b\u5efa\u5e76\u8fd4\u56de\u4efb\u52a1\u63a7\u5236\u5757\u5b9e\u4f8b task_control_block }; // prepare TrapContext in user space let trap_cx = task_control_block.get_trap_cx(); *trap_cx = TrapContext::app_init_context( entry_point, user_sp, KERNEL_SPACE.exclusive_access().token(), kernel_stack_top, trap_handler as usize, ); task_control_block } } #[derive(Copy, Clone, PartialEq)] pub enum TaskStatus { Ready, Running, Exited, }","title":"os/src/task.rs"},{"location":"ch4%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/#ossrctaskmodrs","text":"mod context; mod switch; mod task; use crate::loader::{get_num_app, get_app_data}; use crate::trap::TrapContext; use crate::sync::UPSafeCell; use lazy_static::*; use switch::__switch; use task::{TaskControlBlock, TaskStatus}; use alloc::vec::Vec; pub use context::TaskContext; pub struct TaskManager { num_app: usize, inner: UPSafeCell<TaskManagerInner>, } struct TaskManagerInner { tasks: Vec<TaskControlBlock>, current_task: usize, } lazy_static! { pub static ref TASK_MANAGER: TaskManager = { println!(\"init TASK_MANAGER\"); let num_app = get_num_app(); println!(\"num_app = {}\", num_app); let mut tasks: Vec<TaskControlBlock> = Vec::new(); for i in 0..num_app { tasks.push(TaskControlBlock::new( get_app_data(i), i, )); } TaskManager { num_app, inner: unsafe { UPSafeCell::new(TaskManagerInner { tasks, current_task: 0, })}, } }; } impl TaskManager { fn run_first_task(&self) -> ! { let mut inner = self.inner.exclusive_access(); let next_task = &mut inner.tasks[0]; next_task.task_status = TaskStatus::Running; let next_task_cx_ptr = &next_task.task_cx as *const TaskContext; drop(inner); let mut _unused = TaskContext::zero_init(); // before this, we should drop local variables that must be dropped manually unsafe { __switch( &mut _unused as *mut _, next_task_cx_ptr, ); } panic!(\"unreachable in run_first_task!\"); } fn mark_current_suspended(&self) { let mut inner = self.inner.exclusive_access(); let cur = inner.current_task; inner.tasks[cur].task_status = TaskStatus::Ready; } fn mark_current_exited(&self) { let mut inner = self.inner.exclusive_access(); let cur = inner.current_task; inner.tasks[cur].task_status = TaskStatus::Exited; } fn find_next_task(&self) -> Option<usize> { let inner = self.inner.exclusive_access(); let current = inner.current_task; (current + 1..current + self.num_app + 1) .map(|id| id % self.num_app) .find(|id| { inner.tasks[*id].task_status == TaskStatus::Ready }) } fn get_current_token(&self) -> usize { let inner = self.inner.exclusive_access(); inner.tasks[inner.current_task].get_user_token() } fn get_current_trap_cx(&self) -> &mut TrapContext { let inner = self.inner.exclusive_access(); inner.tasks[inner.current_task].get_trap_cx() } fn run_next_task(&self) { if let Some(next) = self.find_next_task() { let mut inner = self.inner.exclusive_access(); let current = inner.current_task; inner.tasks[next].task_status = TaskStatus::Running; inner.current_task = next; let current_task_cx_ptr = &mut inner.tasks[current].task_cx as *mut TaskContext; let next_task_cx_ptr = &inner.tasks[next].task_cx as *const TaskContext; drop(inner); // before this, we should drop local variables that must be dropped manually unsafe { __switch( current_task_cx_ptr, next_task_cx_ptr, ); } // go back to user mode } else { panic!(\"All applications completed!\"); } } } pub fn run_first_task() { TASK_MANAGER.run_first_task(); } fn run_next_task() { TASK_MANAGER.run_next_task(); } fn mark_current_suspended() { TASK_MANAGER.mark_current_suspended(); } fn mark_current_exited() { TASK_MANAGER.mark_current_exited(); } pub fn suspend_current_and_run_next() { mark_current_suspended(); run_next_task(); } pub fn exit_current_and_run_next() { mark_current_exited(); run_next_task(); } pub fn current_user_token() -> usize { TASK_MANAGER.get_current_token() } pub fn current_trap_cx() -> &'static mut TrapContext { TASK_MANAGER.get_current_trap_cx() }","title":"os/src/task/mod.rs"},{"location":"ch4%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/#ossrctrapcontextrs","text":"use riscv::register::sstatus::{Sstatus, self, SPP}; #[repr(C)] pub struct TrapContext { pub x: [usize; 32], pub sstatus: Sstatus, pub sepc: usize, pub kernel_satp: usize, // \u8868\u793a\u5185\u6838\u5730\u5740\u7a7a\u95f4\u7684 token \uff0c\u5373\u5185\u6838\u9875\u8868\u7684\u8d77\u59cb\u7269\u7406\u5730\u5740 pub kernel_sp: usize, // \u8868\u793a\u5f53\u524d\u5e94\u7528\u5728\u5185\u6838\u5730\u5740\u7a7a\u95f4\u4e2d\u7684\u5185\u6838\u6808\u6808\u9876\u7684\u865a\u62df\u5730\u5740 pub trap_handler: usize, // \u8868\u793a\u5185\u6838\u4e2d trap handler \u5165\u53e3\u70b9\u7684\u865a\u62df\u5730\u5740 } impl TrapContext { pub fn set_sp(&mut self, sp: usize) { self.x[2] = sp; } pub fn app_init_context( entry: usize, sp: usize, kernel_satp: usize, kernel_sp: usize, trap_handler: usize, ) -> Self { let mut sstatus = sstatus::read(); sstatus.set_spp(SPP::User); let mut cx = Self { x: [0; 32], sstatus, sepc: entry, kernel_satp, kernel_sp, trap_handler, }; cx.set_sp(sp); cx } }","title":"os/src/trap/context.rs"},{"location":"ch4%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/#ossrctrapmodrs","text":"// \u8fd8\u6709\u5c31\u662f\u9700\u8981\u5bf9\u6765\u81ea\u7528\u6237\u6001\u548c\u5185\u6838\u6001\u7684\u5f02\u5e38/\u4e2d\u65ad\u5206\u522b\u8fdb\u884c\u5904\u7406 mod context; use riscv::register::{ mtvec::TrapMode, stvec, scause::{ self, Trap, Exception, Interrupt, }, stval, sie, }; use crate::syscall::syscall; use crate::task::{ exit_current_and_run_next, suspend_current_and_run_next, current_user_token, current_trap_cx, }; use crate::timer::set_next_trigger; use crate::config::{TRAP_CONTEXT, TRAMPOLINE}; use core::arch::{global_asm, asm}; global_asm!(include_str!(\"trap.S\")); pub fn init() { set_kernel_trap_entry(); } fn set_kernel_trap_entry() { unsafe { stvec::write(trap_from_kernel as usize, TrapMode::Direct); } } fn set_user_trap_entry() { unsafe { stvec::write(TRAMPOLINE as usize, TrapMode::Direct); } } pub fn enable_timer_interrupt() { unsafe { sie::set_stimer(); } } #[no_mangle] pub fn trap_handler() -> ! { set_kernel_trap_entry(); let cx = current_trap_cx(); let scause = scause::read(); let stval = stval::read(); match scause.cause() { Trap::Exception(Exception::UserEnvCall) => { cx.sepc += 4; cx.x[10] = syscall(cx.x[17], [cx.x[10], cx.x[11], cx.x[12]]) as usize; } Trap::Exception(Exception::StoreFault) | Trap::Exception(Exception::StorePageFault) => { println!(\"[kernel] PageFault in application, bad addr = {:#x}, bad instruction = {:#x}, kernel killed it.\", stval, cx.sepc); exit_current_and_run_next(); } Trap::Exception(Exception::IllegalInstruction) => { println!(\"[kernel] IllegalInstruction in application, kernel killed it.\"); exit_current_and_run_next(); } Trap::Interrupt(Interrupt::SupervisorTimer) => { set_next_trigger(); suspend_current_and_run_next(); } _ => { panic!(\"Unsupported trap {:?}, stval = {:#x}!\", scause.cause(), stval); } } trap_return(); } #[no_mangle] pub fn trap_return() -> ! { set_user_trap_entry(); let trap_cx_ptr = TRAP_CONTEXT; let user_satp = current_user_token(); extern \"C\" { fn __alltraps(); fn __restore(); } let restore_va = __restore as usize - __alltraps as usize + TRAMPOLINE; unsafe { asm!( \"fence.i\", \"jr {restore_va}\", restore_va = in(reg) restore_va, in(\"a0\") trap_cx_ptr, in(\"a1\") user_satp, options(noreturn) ); } } #[no_mangle] pub fn trap_from_kernel() -> ! { panic!(\"a trap from kernel!\"); } pub use context::{TrapContext};","title":"os/src/trap/mod.rs"},{"location":"ch4%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/#ossrctraptraps","text":"# \u7531\u4e8e\u4ee3\u8868\u5e94\u7528\u7a0b\u5e8f\u8fd0\u884c\u7684\u4efb\u52a1\u548c\u7ba1\u7406\u5e94\u7528\u7684\u64cd\u4f5c\u7cfb\u7edf\u5404\u81ea\u6709\u72ec\u7acb\u7684\u9875\u8868\u548c\u865a\u62df\u5730\u5740\u7a7a\u95f4\uff0c # \u6240\u4ee5\u5728\u64cd\u4f5c\u7cfb\u7edf\u7684\u8bbe\u8ba1\u5b9e\u73b0\u4e0a\u9700\u8981\u8003\u8651\u4e24\u4e2a\u6311\u6218\u3002\u7b2c\u4e00\u4e2a\u6311\u6218\u662f \u9875\u8868\u5207\u6362 \u3002 # \u4e8e\u7cfb\u7edf\u8c03\u7528\u3001\u4e2d\u65ad\u6216\u5f02\u5e38\u5bfc\u81f4\u7684\u5e94\u7528\u7a0b\u5e8f\u548c\u64cd\u4f5c\u7cfb\u7edf\u4e4b\u95f4\u7684\u4e0a\u4e0b\u6587\u5207\u6362\u4e0d\u50cf\u4ee5\u524d\u90a3\u4e48\u7b80\u5355\u4e86\uff0c # \u56e0\u4e3a\u5728\u8fd9\u4e9b\u5904\u7406\u8fc7\u7a0b\u4e2d\u9700\u8981\u5207\u6362\u9875\u8868\uff0c .altmacro .macro SAVE_GP n sd x\\n, \\n*8(sp) .endm .macro LOAD_GP n ld x\\n, \\n*8(sp) .endm .section .text.trampoline .globl __alltraps .globl __restore .align 2 __alltraps: csrrw sp, sscratch, sp # now sp->*TrapContext in user space, sscratch->user stack # save other general purpose registers sd x1, 1*8(sp) # skip sp(x2), we will save it later sd x3, 3*8(sp) # skip tp(x4), application does not use it # save x5~x31 .set n, 5 .rept 27 SAVE_GP %n .set n, n+1 .endr # we can use t0/t1/t2 freely, because they have been saved in TrapContext csrr t0, sstatus csrr t1, sepc sd t0, 32*8(sp) sd t1, 33*8(sp) # read user stack from sscratch and save it in TrapContext csrr t2, sscratch sd t2, 2*8(sp) # \u5e94\u7528\u5730\u5740\u7a7a\u95f4\u4e2d\u5b8c\u6210\u4e86\u4fdd\u5b58 Trap \u4e0a\u4e0b\u6587\u7684\u5de5\u4f5c # load kernel_satp into t0 ld t0, 34*8(sp) # \u5c06\u5185\u6838\u5730\u5740\u7a7a\u95f4\u7684 token \u8f7d\u5165\u5230 t0 \u5bc4\u5b58\u5668\u4e2d # load trap_handler into t1 ld t1, 36*8(sp) # \u5c06 trap handler \u5165\u53e3\u70b9\u7684\u865a\u62df\u5730\u5740\u8f7d\u5165\u5230 t1 \u5bc4\u5b58\u5668\u4e2d # move to kernel_sp ld sp, 35*8(sp) # \u76f4\u63a5\u5c06 sp \u4fee\u6539\u4e3a\u5e94\u7528\u5185\u6838\u6808\u9876\u7684\u5730\u5740 # switch to kernel space csrw satp, t0 sfence.vma # \u5c06 satp \u4fee\u6539\u4e3a\u5185\u6838\u5730\u5740\u7a7a\u95f4\u7684 token \u5e76\u4f7f\u7528 sfence.vma \u5237\u65b0\u5feb\u8868\uff0c # \u8fd9\u5c31\u5207\u6362\u5230\u4e86\u5185\u6838\u5730\u5740\u7a7a\u95f4 # jump to trap_handler jr t1 # \u901a\u8fc7 jr \u6307\u4ee4\u8df3\u8f6c\u5230 t1 \u5bc4\u5b58\u5668\u6240\u4fdd\u5b58\u7684trap handler \u5165\u53e3\u70b9\u7684\u5730\u5740 __restore: # a0: *TrapContext in user space(Constant); a1: user space token # switch to user space csrw satp, a1 sfence.vma # \u5207\u6362\u56de\u5e94\u7528\u5730\u5740\u7a7a\u95f4 csrw sscratch, a0 # \u5c06\u4f20\u5165\u7684 Trap \u4e0a\u4e0b\u6587\u4f4d\u7f6e\u4fdd\u5b58\u5728 sscratch \u5bc4\u5b58\u5668\u4e2d\uff0c # \u8fd9\u6837 __alltraps \u4e2d\u624d\u80fd\u57fa\u4e8e\u5b83\u5c06 Trap \u4e0a\u4e0b\u6587\u4fdd\u5b58\u5230\u6b63\u786e\u7684\u4f4d\u7f6e mv sp, a0 # \u5c06 sp \u4fee\u6539\u4e3a Trap \u4e0a\u4e0b\u6587\u7684\u4f4d\u7f6e\uff0c\u540e\u9762\u57fa\u4e8e\u5b83\u6062\u590d\u5404\u901a\u7528\u5bc4\u5b58\u5668\u548c CSR # now sp points to TrapContext in user space, start restoring based on it # restore sstatus/sepc ld t0, 32*8(sp) ld t1, 33*8(sp) csrw sstatus, t0 csrw sepc, t1 # restore general purpose registers except x0/sp/tp ld x1, 1*8(sp) ld x3, 3*8(sp) .set n, 5 .rept 27 LOAD_GP %n .set n, n+1 .endr # back to user stack ld sp, 2*8(sp) sret # \u901a\u8fc7 sret \u6307\u4ee4\u8fd4\u56de\u7528\u6237\u6001","title":"os/src/trap/trap.S"},{"location":"ch4%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/#ossrcloaderrs","text":"// \u5728 os/src/build.rs \u4e2d\uff0c\u6211\u4eec\u4e0d\u518d\u5c06\u4e22\u5f03\u4e86\u6240\u6709\u7b26\u53f7\u7684\u5e94\u7528\u4e8c\u8fdb\u5236\u955c\u50cf\u94fe\u63a5\u8fdb\u5185\u6838\uff0c // \u56e0\u4e3a\u5728\u5e94\u7528\u4e8c\u8fdb\u5236\u955c\u50cf\u4e2d\uff0c\u5185\u5b58\u5e03\u5c40\u4e2d\u5404\u4e2a\u903b\u8f91\u6bb5\u7684\u7f6e\u548c\u8bbf\u95ee\u9650\u5236\u7b49\u4fe1\u606f\u90fd\u88ab\u88c1\u526a\u6389\u4e86\u3002 // \u6211\u4eec\u76f4\u63a5\u4f7f\u7528\u4fdd\u5b58\u4e86\u903b\u8f91\u6bb5\u4fe1\u606f\u7684 ELF \u683c\u5f0f\u7684\u5e94\u7528\u53ef\u6267\u884c\u6587\u4ef6\u3002\u8fd9\u6837 loader \u5b50\u6a21\u5757\u7684\u8bbe\u8ba1\u5b9e\u73b0\u4e5f\u53d8\u5f97\u7cbe\u7b80 // \u83b7\u53d6\u94fe\u63a5\u5230\u5185\u6838\u5185\u7684\u5e94\u7528\u7684\u6570\u76ee pub fn get_num_app() -> usize { extern \"C\" { fn _num_app(); } unsafe { (_num_app as usize as *const usize).read_volatile() } } // get_app_data \u5219\u6839\u636e\u4f20\u5165\u7684\u5e94\u7528\u7f16\u53f7\u53d6\u51fa\u5bf9\u5e94\u5e94\u7528\u7684 ELF \u683c\u5f0f\u53ef\u6267\u884c\u6587\u4ef6\u6570\u636e\u3002 // \u5b83\u4eec\u548c\u4e4b\u524d\u4e00\u6837\u4ecd\u662f\u57fa\u4e8e build.rs \u751f\u6210\u7684 link_app.S \u7ed9\u51fa\u7684\u7b26\u53f7\u6765\u786e\u5b9a\u5176\u4f4d\u7f6e\uff0c // \u5e76\u5b9e\u9645\u653e\u5728\u5185\u6838\u7684\u6570\u636e\u6bb5\u4e2d\u3002 loader \u6a21\u5757\u4e2d\u539f\u6709\u7684\u5185\u6838\u548c\u7528\u6237\u6808\u5219\u5206\u522b\u4f5c\u4e3a\u903b\u8f91\u6bb5\u653e\u5728\u5185\u6838\u548c\u7528\u6237\u5730\u5740\u7a7a\u95f4\u4e2d\uff0c // \u6211\u4eec\u65e0\u9700\u518d\u53bb\u4e13\u95e8\u4e3a\u5176\u5b9a\u4e49\u4e00\u79cd\u7c7b\u578b pub fn get_app_data(app_id: usize) -> &'static [u8] { extern \"C\" { fn _num_app(); } let num_app_ptr = _num_app as usize as *const usize; let num_app = get_num_app(); let app_start = unsafe { core::slice::from_raw_parts(num_app_ptr.add(1), num_app + 1) }; assert!(app_id < num_app); unsafe { core::slice::from_raw_parts( app_start[app_id] as *const u8, app_start[app_id + 1] - app_start[app_id] ) } }","title":"os/src/loader.rs"},{"location":"ch4%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/#ossrcmainrs","text":"#![no_std] #![no_main] #![feature(panic_info_message)] #![feature(alloc_error_handler)] extern crate alloc; // alloc \u5e93\u9700\u8981\u6211\u4eec\u63d0\u4f9b\u7ed9\u5b83\u4e00\u4e2a \u5168\u5c40\u7684\u52a8\u6001\u5185\u5b58\u5206\u914d\u5668 \uff0c\u5b83\u4f1a\u5229\u7528\u8be5\u5206\u914d\u5668\u6765\u7ba1\u7406\u5806\u7a7a\u95f4\uff0c // \u4ece\u800c\u4f7f\u5f97\u4e0e\u5806\u76f8\u5173\u7684\u667a\u80fd\u6307\u9488\u6216\u5bb9\u5668\u6570\u636e\u7ed3\u6784\u53ef\u4ee5\u6b63\u5e38\u5de5\u4f5c // \u9700\u8981\u5f15\u5165 alloc \u5e93\u7684\u4f9d\u8d56\uff0c\u7531\u4e8e\u5b83\u7b97\u662f Rust \u5185\u7f6e\u7684 crate \uff0c\u6211\u4eec\u5e76\u4e0d\u662f\u5728 Cargo.toml \u4e2d\u8fdb\u884c\u5f15\u5165\uff0c // \u800c\u662f\u5728 main.rs \u4e2d\u58f0\u660e\u5373\u53ef #[macro_use] extern crate bitflags; #[macro_use] mod console; mod lang_items; mod sbi; mod syscall; mod trap; mod loader; mod config; mod task; mod timer; mod sync; mod mm; use core::arch::global_asm; global_asm!(include_str!(\"entry.asm\")); global_asm!(include_str!(\"link_app.S\")); fn clear_bss() { extern \"C\" { fn sbss(); fn ebss(); } unsafe { core::slice::from_raw_parts_mut( sbss as usize as *mut u8, ebss as usize - sbss as usize, ).fill(0); } } #[no_mangle] pub fn rust_main() -> ! { clear_bss(); println!(\"[kernel] Hello, world!\"); mm::init(); println!(\"[kernel] back to world!\"); mm::remap_test(); trap::init(); //trap::enable_interrupt(); trap::enable_timer_interrupt(); timer::set_next_trigger(); task::run_first_task(); panic!(\"Unreachable in rust_main!\"); }","title":"os/src/main.rs"},{"location":"ch4%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/#osmakefile","text":"# Building TARGET := riscv64gc-unknown-none-elf MODE := release KERNEL_ELF := target/$(TARGET)/$(MODE)/os KERNEL_BIN := $(KERNEL_ELF).bin DISASM_TMP := target/$(TARGET)/$(MODE)/asm # BOARD BOARD ?= qemu SBI ?= rustsbi BOOTLOADER := ../bootloader/$(SBI)-$(BOARD).bin K210_BOOTLOADER_SIZE := 131072 # KERNEL ENTRY ifeq ($(BOARD), qemu) KERNEL_ENTRY_PA := 0x80200000 else ifeq ($(BOARD), k210) KERNEL_ENTRY_PA := 0x80020000 endif # Run K210 K210-SERIALPORT = /dev/ttyUSB0 K210-BURNER = ../tools/kflash.py # Binutils OBJDUMP := rust-objdump --arch-name=riscv64 OBJCOPY := rust-objcopy --binary-architecture=riscv64 # Disassembly DISASM ?= -x build: env switch-check $(KERNEL_BIN) switch-check: ifeq ($(BOARD), qemu) (which last-qemu) || (rm -f last-k210 && touch last-qemu && make clean) else ifeq ($(BOARD), k210) (which last-k210) || (rm -f last-qemu && touch last-k210 && make clean) endif env: (rustup target list | grep \"riscv64gc-unknown-none-elf (installed)\") || rustup target add $(TARGET) cargo install cargo-binutils --vers =0.3.3 rustup component add rust-src rustup component add llvm-tools-preview $(KERNEL_BIN): kernel @$(OBJCOPY) $(KERNEL_ELF) --strip-all -O binary $@ kernel: @cd ../user && make build @echo Platform: $(BOARD) @cp src/linker-$(BOARD).ld src/linker.ld @cargo build --release --features \"board_$(BOARD)\" @rm src/linker.ld clean: @cargo clean disasm: kernel @$(OBJDUMP) $(DISASM) $(KERNEL_ELF) | less disasm-vim: kernel @$(OBJDUMP) $(DISASM) $(KERNEL_ELF) > $(DISASM_TMP) @vim $(DISASM_TMP) @rm $(DISASM_TMP) run: run-inner run-inner: build ifeq ($(BOARD),qemu) @qemu-system-riscv64 \\ -machine virt \\ -nographic \\ -bios $(BOOTLOADER) \\ -device loader,file=$(KERNEL_BIN),addr=$(KERNEL_ENTRY_PA) else (which $(K210-BURNER)) || (cd .. && git clone https://github.com/sipeed/kflash.py.git && mv kflash.py tools) @cp $(BOOTLOADER) $(BOOTLOADER).copy @dd if=$(KERNEL_BIN) of=$(BOOTLOADER).copy bs=$(K210_BOOTLOADER_SIZE) seek=1 @mv $(BOOTLOADER).copy $(KERNEL_BIN) @sudo chmod 777 $(K210-SERIALPORT) python3 $(K210-BURNER) -p $(K210-SERIALPORT) -b 1500000 $(KERNEL_BIN) python3 -m serial.tools.miniterm --eol LF --dtr 0 --rts 0 --filter direct $(K210-SERIALPORT) 115200 endif debug: build @tmux new-session -d \\ \"qemu-system-riscv64 -machine virt -nographic -bios $(BOOTLOADER) -device loader,file=$(KERNEL_BIN),addr=$(KERNEL_ENTRY_PA) -s -S\" && \\ tmux split-window -h \"riscv64-unknown-elf-gdb -ex 'file $(KERNEL_ELF)' -ex 'set arch riscv:rv64' -ex 'target remote localhost:1234'\" && \\ tmux -2 attach-session -d .PHONY: build env kernel clean disasm disasm-vim run-inner switch-check","title":"os/Makefile"},{"location":"ch4%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/#user","text":"","title":"\u5728 user \u6587\u4ef6\u5939\u4e0b"},{"location":"ch4%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/#usercargoconfig","text":"[build] target = \"riscv64gc-unknown-none-elf\" [target.riscv64gc-unknown-none-elf] rustflags = [ \"-Clink-args=-Tsrc/linker.ld\", ]","title":"user/.cargo/config"},{"location":"ch4%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/#usercargotoml","text":"[package] name = \"user_lib\" version = \"0.1.0\" authors = [\"Yifan Wu <shinbokuow@163.com>\"] edition = \"2018\" # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html [dependencies]","title":"user/Cargo.toml"},{"location":"ch4%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/#usersrcconsolers","text":"use core::fmt::{self, Write}; use super::write; struct Stdout; const STDOUT: usize = 1; impl Write for Stdout { fn write_str(&mut self, s: &str) -> fmt::Result { write(STDOUT, s.as_bytes()); Ok(()) } } pub fn print(args: fmt::Arguments) { Stdout.write_fmt(args).unwrap(); } #[macro_export] macro_rules! print { ($fmt: literal $(, $($arg: tt)+)?) => { $crate::console::print(format_args!($fmt $(, $($arg)+)?)); } } #[macro_export] macro_rules! println { ($fmt: literal $(, $($arg: tt)+)?) => { $crate::console::print(format_args!(concat!($fmt, \"\\n\") $(, $($arg)+)?)); } }","title":"user/src/console.rs"},{"location":"ch4%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/#usersrclang_itemsrs","text":"#[panic_handler] fn panic_handler(panic_info: &core::panic::PanicInfo) -> ! { let err = panic_info.message().unwrap(); if let Some(location) = panic_info.location() { println!(\"Panicked at {}:{}, {}\", location.file(), location.line(), err); } else { println!(\"Panicked: {}\", err); } loop {} }","title":"user/src/lang_items.rs"},{"location":"ch4%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/#usersrclibrs","text":"#![no_std] #![feature(linkage)] #![feature(panic_info_message)] #[macro_use] pub mod console; mod syscall; mod lang_items; #[no_mangle] #[link_section = \".text.entry\"] pub extern \"C\" fn _start() -> ! { exit(main()); panic!(\"unreachable after sys_exit!\"); } #[linkage = \"weak\"] #[no_mangle] fn main() -> i32 { panic!(\"Cannot find main!\"); } use syscall::*; pub fn write(fd: usize, buf: &[u8]) -> isize { sys_write(fd, buf) } pub fn exit(exit_code: i32) -> isize { sys_exit(exit_code) } pub fn yield_() -> isize { sys_yield() } pub fn get_time() -> isize { sys_get_time() }","title":"user/src/lib.rs"},{"location":"ch4%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/#usersrclinkerld","text":"OUTPUT_ARCH(riscv) ENTRY(_start) BASE_ADDRESS = 0x10000; # \u5047\u5b9a\u64cd\u4f5c\u7cfb\u7edf\u80fd\u591f\u901a\u8fc7\u5206\u9875\u673a\u5236\u628a\u4e0d\u540c\u5e94\u7528\u7684\u76f8\u540c\u865a\u5730\u5740\u6620\u5c04\u5230\u4e0d\u540c\u7684\u7269\u7406\u5730\u5740\u4e0a # \u8fd9\u6837\u6211\u4eec\u5199\u5e94\u7528\u5c31\u4e0d\u7528\u8003\u8651\u5e94\u7528\u7684\u7269\u7406\u5730\u5740\u5e03\u5c40\u7684\u95ee\u9898\uff0c\u80fd\u591f\u4ee5\u4e00\u79cd\u66f4\u52a0\u7edf\u4e00\u7684\u65b9\u5f0f\u7f16\u5199\u5e94\u7528\u7a0b\u5e8f\uff0c # \u53ef\u4ee5\u5ffd\u7565\u6389\u4e00\u4e9b\u4e0d\u5fc5\u8981\u7684\u7ec6\u8282 SECTIONS { . = BASE_ADDRESS; .text : { *(.text.entry) *(.text .text.*) } . = ALIGN(4K); .rodata : { *(.rodata .rodata.*) *(.srodata .srodata.*) } . = ALIGN(4K); .data : { *(.data .data.*) *(.sdata .sdata.*) } .bss : { *(.bss .bss.*) *(.sbss .sbss.*) } /DISCARD/ : { *(.eh_frame) *(.debug*) } }","title":"user/src/linker.ld"},{"location":"ch4%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/#usersrcsyscallrs","text":"use core::arch::asm; const SYSCALL_WRITE: usize = 64; const SYSCALL_EXIT: usize = 93; const SYSCALL_YIELD: usize = 124; const SYSCALL_GET_TIME: usize = 169; fn syscall(id: usize, args: [usize; 3]) -> isize{ let mut ret: isize; unsafe{ asm!( \"ecall\", inlateout(\"x10\") args[0] => ret, in(\"x11\") args[1], in(\"x12\") args[2], in(\"x17\") id ); } ret } pub fn sys_write(fd: usize, buffer: &[u8]) -> isize{ syscall(SYSCALL_WRITE, [fd, buffer.as_ptr() as usize, buffer.len()]) } pub fn sys_exit(exit_code: i32) -> isize { syscall(SYSCALL_EXIT, [exit_code as usize, 0, 0]) } pub fn sys_yield() -> isize { syscall(SYSCALL_YIELD, [0, 0, 0]) } pub fn sys_get_time() -> isize { syscall(SYSCALL_GET_TIME, [0, 0, 0]) }","title":"user/src/syscall.rs"},{"location":"ch4%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/#usersrcbin00power_3rs","text":"#![no_std] #![no_main] #[macro_use] extern crate user_lib; const LEN: usize = 100; static mut S: [u64; LEN] = [0u64; LEN]; #[no_mangle] unsafe fn main() -> i32 { let p = 3u64; let m = 998244353u64; let iter: usize = 300000; let mut cur = 0usize; S[cur] = 1; for i in 1..=iter { let next = if cur + 1 == LEN { 0 } else { cur + 1 }; S[next] = S[cur] * p % m; cur = next; if i % 10000 == 0 { println!(\"power_3 [{}/{}]\", i, iter); } } println!(\"{}^{} = {}(MOD {})\", p, iter, S[cur], m); println!(\"Test power_3 OK!\"); 0 }","title":"user/src/bin/00power_3.rs"},{"location":"ch4%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/#usersrcbin01power_5rs","text":"#![no_std] #![no_main] #[macro_use] extern crate user_lib; const LEN: usize = 100; static mut S: [u64; LEN] = [0u64; LEN]; #[no_mangle] unsafe fn main() -> i32 { let p = 5u64; let m = 998244353u64; let iter: usize = 210000; let mut cur = 0usize; S[cur] = 1; for i in 1..=iter { let next = if cur + 1 == LEN { 0 } else { cur + 1 }; S[next] = S[cur] * p % m; cur = next; if i % 10000 == 0 { println!(\"power_5 [{}/{}]\", i, iter); } } println!(\"{}^{} = {}(MOD {})\", p, iter, S[cur], m); println!(\"Test power_5 OK!\"); 0 }","title":"user/src/bin/01power_5.rs"},{"location":"ch4%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/#usersrcbin02power_7rs","text":"#![no_std] #![no_main] #[macro_use] extern crate user_lib; const LEN: usize = 100; static mut S: [u64; LEN] = [0u64; LEN]; #[no_mangle] unsafe fn main() -> i32 { let p = 7u64; let m = 998244353u64; let iter: usize = 240000; let mut cur = 0usize; S[cur] = 1; for i in 1..=iter { let next = if cur + 1 == LEN { 0 } else { cur + 1 }; S[next] = S[cur] * p % m; cur = next; if i % 10000 == 0 { println!(\"power_7 [{}/{}]\", i, iter); } } println!(\"{}^{} = {}(MOD {})\", p, iter, S[cur], m); println!(\"Test power_7 OK!\"); 0 }","title":"user/src/bin/02power_7.rs"},{"location":"ch4%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/#usersrcbin03sleeprs","text":"#![no_std] #![no_main] #[macro_use] extern crate user_lib; use user_lib::{get_time, yield_}; #[no_mangle] fn main() -> i32 { let current_timer = get_time(); let wait_for = current_timer + 3000; while get_time() < wait_for { yield_(); } println!(\"Test sleep OK!\"); 0 }","title":"user/src/bin/03sleep.rs"},{"location":"ch4%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/#usermakefile","text":"TARGET := riscv64gc-unknown-none-elf MODE := release APP_DIR := src/bin TARGET_DIR := target/$(TARGET)/$(MODE) APPS := $(wildcard $(APP_DIR)/*.rs) ELFS := $(patsubst $(APP_DIR)/%.rs, $(TARGET_DIR)/%, $(APPS)) BINS := $(patsubst $(APP_DIR)/%.rs, $(TARGET_DIR)/%.bin, $(APPS)) OBJDUMP := rust-objdump --arch-name=riscv64 OBJCOPY := rust-objcopy --binary-architecture=riscv64 elf: $(APPS) @cargo build --release binary: elf $(foreach elf, $(ELFS), $(OBJCOPY) $(elf) --strip-all -O binary $(patsubst $(TARGET_DIR)/%, $(TARGET_DIR)/%.bin, $(elf));) build: binary clean: @cargo clean .PHONY: elf binary build clean","title":"user/Makefile"},{"location":"ch4%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/#_4","text":"os/src/main.rs - \u5bfc\u5165 entry.asm \u8bbe\u7f6e\u51fd\u6570\u6808\uff0c \u8df3\u8f6c\u5230rust_main \u5bfc\u5165 link_app.S \u8fd9\u91cc\u5168\u662f\u6570\u636e\u6bb5\uff0c \u53ef\u6267\u884c\u6587\u4ef6\u5728\u90e8\u5206\u6570\u636e\u6bb5\u4e2d \u8c03\u7528 clear_bss \u51fd\u6570\uff0c \u6e05\u9664 \u9664 .bss.stack \u4ee5\u5916\u7684 .bss \u6bb5 \u8c03\u7528 println! \u6253\u5370 [kernel] Hello, world! , \u6b64\u65f6\u5904\u4e8e\u5185\u6838\u6001 \u8c03\u7528 mm::init os/src/mm/mod.rs \u8c03\u7528 init_heap os/src/mm/heap_allocator.rs \u5c06\u4e00\u6bb5\u6570\u7ec4\u7684\u957f\u5ea6\u548c\u5927\u5c0f\u4f5c\u4e3a\u53c2\u6570 \u7528\u4e8e HEAP_ALLOCATOR \u7ba1\u7406 \u5806\u7ba1\u7406\u7684\u5177\u4f53\u5b9e\u73b0\u662f\u7531Rust\u7684\u5e93\u5b9e\u73b0 \u8c03\u7528 init_frame_allocator os/src/mm/frame_allocator \u83b7\u53d6 ekernel \u7684\u5730\u5740 \u5c06 ekernel \u548c MEMORY_END \u7684\u5730\u5740\u53d6\u6574\u8f6c\u6210\u7269\u7406\u5730\u5740\u540e\u4f20\u5165 FRAME_ALLOCATOR \u8df3\u8f6cStackFrameAllocator\u7684 init\u51fd\u6570\uff0c\u5373\u8d4b\u503c\u7ed9\u7ed3\u6784\u4f53StackFrameAllocator\u7684current\u548cend \u8c03\u7528KERNEL_SPACE \u7684 activate os/src/mm/memory_set.rs \u9759\u6001\u751f\u6210KERNEL_SPACE\uff0c\u5b83\u662fMemorySet\u7c7b\u578b\u901a\u8fc7\u5176new_kernel\u51fd\u6570\u6784\u9020\u800c\u6210 new_kernel\u5148\u8c03\u7528 new_bare \u51fd\u6570\u83b7\u5f97\u4e00\u4e2aMemorySet new_bare\u51fd\u6570\u8c03\u7528PageTable \u7684new\u51fd\u6570\u83b7\u5f97\u4e00\u4e2aPageTable PageTable \u7684new\u51fd\u6570\u8c03\u7528frame_alloc\u51fd\u6570 frame_alloc \u51fd\u6570\u5148\u8c03\u7528FRAME_ALLOCATOR\u51fd\u6570\u7684 alloc\u51fd\u6570\u83b7\u5f97\u7269\u7406\u9875 alloc \u51fd\u6570\u5148\u67e5\u770bStackFrameAllocator\u7684recycled\u8fd9\u4e2aVec\u4e2d\u6709\u6ca1\u6709\u7269\u7406\u9875\u53ef\u4ee5\u8fd4\u56de \u5982\u679c\u6709\u5c31\u76f4\u63a5\u8fd4\u56de\uff0c\u6ca1\u6709\u5c31\u5206\u914d\u65b0\u7684\u9875\uff0c\u5982\u679c\u6574\u4e2a\u6570\u7ec4\u88ab\u5206\u914d\u5b8c\u4e86\uff0c\u5c31\u8fd4\u56deNone frame_alloc \u51fd\u6570\u8c03\u7528FrameTracker\u7ed3\u6784\u7684new\u51fd\u6570\u5c06\u521a\u624d\u5f97\u5230\u7684\u7269\u7406\u9875\u8868\u6240\u5bf9\u5e94\u7684\u9875\u6e05\u96f6 \u518d\u5c06\u5f97\u5230\u7684\u7269\u7406\u9875\u4f20\u5230FRAME_ALLOCATOR\u7684map\u51fd\u6570\uff0c\u5c06Option \u7c7b\u578b\u7684 ppn \u8f6c\u6210FrameTracker\u7c7b\u578b \u5c06\u83b7\u5f97\u7684FrameTracker\u7684ppn\u4f5c\u4e3aPageTable \u7684 root_ppn,\u5e76\u5c06\u8fd9\u4e2aFrameTracker\u5b58\u5728\u5728PageTable\u7684frames\u8fd9\u4e2aVec\u5bb9\u5668\u4e2d \u8fd4\u56de\u8fd9\u4e2aPageTable \u751f\u6210\u4e00\u4e2a\u7a7a\u7684areas\u7684Vec\u5bb9\u5668 \u8fd4\u56de\u8fd9\u4e2aMemorySet\u8fd9\u4e2a\u7ed3\u6784\u4f53 \u8c03\u7528\u83b7\u5f97\u7684 MemorySet \u7684 map_trampoline \u51fd\u6570\uff0c map_trampoline \u8c03\u7528 MemorySet\u7684page_table\u7684map\u51fd\u6570 \u5148\u8c03\u7528VirtAddr\u7684from\u65b9\u6cd5\u5c06usize\u7684TRAMPOLIMNE\u8f6c\u6210VirtAddr \u518d\u5c06VirtAddr\u7c7b\u578b\u8f6c\u6210VirtPageNum\u7c7b\u578b \u540c\u7406\uff0c\u5c06\u4ecelinker.ld\u4e2d\u83b7\u5f97\u7684strampoline\u5730\u5740\u5148\u8f6c\u6210\u7269\u7406\u5730\u5740\uff0c\u518d\u8f6c\u6210\u7269\u7406\u9875\u53f7 \u6700\u540e\u7ed9\u4ed6\u4eec\u8bfb\u5199\u6743\u9650 \u5c06\u83b7\u5f97\u7684\u865a\u62df\u9875\u53f7\u548c\u7269\u7406\u9875\u53f7\u4ee5\u53ca\u6807\u5fd7\u4f4d\u4f20\u5165\u5230map\u51fd\u6570 map\u51fd\u6570\u5148\u8c03\u7528PageTable\u7684find_pte_create\u65b9\u6cd5 find_pte_create\u65b9\u6cd5\u4e2d\uff0c\u5148\u8c03\u7528VirtPageNum \u7684indexes\u65b9\u6cd5 indexes\u65b9\u6cd5\u4e2d\uff0c\u5148\u53d6\u51fa\u865a\u62df\u9875\u53f7\uff0c\u5206\u522b\u53d6\u51fa\u4e09\u7ea7\u9875\u7684\u7d22\u5f15\uff0c\u4ee5\u6570\u7ec4\u7684\u5f62\u5f0f\u8fd4\u56de \u83b7\u53d6PageTable\u7684root_ppn \u5206\u522b\u53d6\u51fa\u4e09\u7ea7\u7d22\u5f15\uff0c\u5982\u679c\u627e\u5230\u4e86\u7b2c\u4e00\u7ea7\u7d22\u5f15\uff08\u5373\u7269\u7406\u9875\u53f7\uff09\uff0c\u5c31\u5c06\u5176\u5bf9\u5e94\u7684\u9875\u8868\u9879\u76f4\u63a5\u8fd4\u56de \u5982\u679c\u67d0\u4e2a\u7d22\u5f15\u8d70\u4e0d\u901a\uff0c\u5c31\u662f\u4e0d\u5b58\u5728\u6216\u4e0d\u548c\u6cd5\uff0c\u5c31\u8c03\u7528frame_alloc\u7533\u8bf7\u4e00\u4e2a\u7269\u7406\u9875\uff0c\u83b7\u53d6\u4ed6\u7684\u7269\u7406\u9875\u53f7\uff0c\u518d\u5c06\u8fd9\u4e2a\u7269\u7406\u9875\u53f7\u4f20\u5165\u5230PageTableEntry\u7684new\u51fd\u6570\u4e2d\uff0c\u751f\u6210\u4e00\u4e2a\u7269\u7406\u9875\u5e27\uff0c\u518d\u5c06\u7269\u7406\u9875\u53f7\u5b58\u653e\u5230PageTable\u5168\u5c40\u9875\u7ba1\u7406\u5668\u4e2d \u5c06\u751f\u6210\u7684\u65b0\u7684\u7269\u7406\u9875\u5e27\u8fd4\u56de \u518d\u8c03\u7528PageTableEntry\u7684new\u65b9\u6cd5\uff0c\u901a\u8fc7\u5f97\u5230\u7684\u7269\u7406\u9875\u53f7\u751f\u6210\u5bf9\u5e94\u7684\u7269\u7406\u9875\u5e27 \u6700\u540e\u5c06\u901a\u8fc7\u865a\u62df\u9875\u53f7\u5f97\u5230\u7684\u7269\u7406\u9875\u5e27\u6307\u5411\u4f20\u5165\u5230map\u51fd\u6570\u7684\u7269\u7406\u9875\u5e27 \u6253\u5370\u51fa\u5404\u4e2a\u6bb5\u7684\u5730\u5740 \u8c03\u7528memory_set\u7684push\u65b9\u6cd5 \u8c03\u7528MapArea\u7684new\u65b9\u6cd5 \u5148\u5c06\u5404\u4e2a\u6bb5\u7684\u8d77\u59cb\u5730\u5740\u548c\u7ed3\u675f\u5730\u5740\u8f6c\u6210usize\u7c7b\u578b\uff0c\u518d\u8f6c\u6210\u865a\u62df\u5730\u5740 \u5c06\u5404\u4e2a\u6bb5\u7684\u865a\u62df\u5730\u5740\u8303\u56f4\u548c\u6620\u5c04\u7c7b\u578b\u4ee5\u53ca\u6620\u5c04\u7684\u6743\u9650\u4f5c\u4e3a\u53c2\u6570\u4f20\u5165\u5230new\u65b9\u6cd5\u4e2d MapArea\u4e2d\u7684new\u65b9\u6cd5\u5c06\u4e24\u4e2a\u5730\u5740\u8f6c\u6210\u865a\u62df\u9875\u53f7 \u5c06\u4e24\u4e2a\u865a\u62df\u9875\u53f7\u4f5c\u4e3a\u533a\u95f4\u4f20\u5165\u5230VPNRange\u7684new\u65b9\u6cd5\u4e2d\uff0c\u800cVPNRange\u7684\u672c\u8d28\u662fSimpleRange\u7c7b\u7684\u522b\u79f0\uff0cSimpleRange\u662f\u4e00\u4e2a\u6cdb\u578b\uff0c\u53ea\u5305\u542b\u4e00\u4e2a\u6cdb\u578b\u7684\u5de6\u503c\u548c\u53f3\u503c\uff0c\u5b83\u7684new\u65b9\u6cd5\u5c31\u662f\u5c06\u4e24\u4e2a\u53c2\u6570\u8d4b\u503c\u7ed9\u7ed3\u6784\u4f53\u7684\u5de6\u53f3\u503c \u751f\u6210\u4e00\u4e2a\u7a7a\u7684\u952e\u503c\u5bf9\u8868BTreeMap(\u6ce8\u610f\uff1a\u5b83\u662f\u6709\u5e8f\u7684) \u5c06map_type \u548c map_perm\u8d4b\u503c \u8fd4\u56de\u751f\u6210\u7684MapArea \u5c06\u751f\u6210\u7684MapAreapush\u5230\u5f00\u5934\u751f\u6210\u7684MemorySet\u7684\u5b9e\u4f8b\u7684 areas\u8fd9Vec\u5bb9\u5668\u4e2d \u8fd4\u56de\u751f\u6210\u7684MemorySet \u5b9e\u4f8b memory_set \u8c03\u7528KERNEL_SPACE \u7684 activate \u8c03\u7528MemorySet\u7ed3\u6784\u4f53\u7684\u6210\u5458PageTable\u7684token\u65b9\u6cd5 PageTable\u7684Token\u65b9\u6cd5\uff0c\u5c06root_ppn\u8fdb\u884c\u5904\u7406\uff0c\u8fd4\u56de\u4e00\u4e2ausize \u5c06\u5f97\u5230\u7684Token\u5199\u5165\u5230satp\u5bc4\u5b58\u5668\u4e2d\uff0c\u63a7\u5236\u5206\u9875\u7cfb\u7edf","title":"\u6267\u884c\u6d41\u7a0b"},{"location":"ch4%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/#_5","text":"main\u51fd\u6570\u4e2d\u8c03\u7528 mm::remap_test\u51fd\u6570 main\u51fd\u6570\u4e2d\u8c03\u7528 trap::init\u51fd\u6570 os/src/trap/mod.rs \u8c03\u7528 set_kernel_trap_entry set_kernel_trap_entry \u4e2d \u5c06 \u51fd\u6570 trap_from_kernel \u7684\u5730\u5740\u548c trap\u7684\u6a21\u5f0f\u4f5c\u4e3a\u53c2\u6570\u4f20\u5165\u5230stvec::write\u65b9\u6cd5\u4e2d\uff0c\u5373\u8bbe\u7f6e trap \u7684\u5904\u7406\u6a21\u5f0f \u548c \u5bf9\u5e94\u5904\u7406\u51fd\u6570\u7684\u5730\u5740 \u8fd9\u91cc\u7684 trap_from_kernel \u51fd\u6570\u53ea\u662f\u4ec5\u4ec5\u8c03\u7528\u4e00\u4e2a panic main\u51fd\u6570\u4e2d\u8c03\u7528 trap::enable_interrupt os/src/mod.rs enable_timer_interrupt \u4e2d os/src/loader.rs \u8c03\u7528 get_num_app \u83b7\u53d6\u5e94\u7528\u4e2a\u6570 \u83b7\u53d6\u7b2c\u4e00\u4e2a\u7a0b\u5e8f\u7684\u5165\u53e3\u5730\u5740 \u5237\u65b0\u6307\u4ee4\u7f13\u51b2\u533a \u8c03\u7528 get_base_i \u83b7\u53d6 \u6bcf\u4e2a\u5e94\u7528\u7a0b\u5e8f\u7684\u8d77\u59cb\u5730\u5740 \u5c06\u6bcf\u4e2a\u5e94\u7528\u8d77\u59cb\u5730\u5740\u5230 \u5e94\u7528\u7a7a\u95f4\u9650\u5236\u8303\u56f4\u7684\u5730\u5740\u533a\u95f4 \u7528 0 \u586b\u5145 \u83b7\u53d6\u6bcf\u4e2a\u5e94\u7528\u5728 .data \u6bb5\u7684\u8d77\u59cb\u5730\u5740\u548c\u5927\u5c0f \u548c \u5728\u5c06\u4f1a\u653e\u7f6e\u8be5\u7a0b\u5e8f\u7684\u8d77\u59cb\u5730\u5740\u548c\u7a0b\u5e8f\u5927\u5c0f \u8c03\u7528 copy_from_slice \u5c06\u7a0b\u5e8f\u4ece .data \u6bb5\u590d\u5236\u5230 \u76f8\u5e94\u7684\u5730\u5740\u533a\u95f4 \u81f3\u6b64\uff0c\u7a0b\u5e8f\u52a0\u8f7d\u5b8c\u6bd5 os/src/main.rs \u8c03\u7528 trap::enable_timer_interrupt \u8c03\u7528 sie::set_stimer \u4f7f\u5f97 S \u7279\u6743\u7ea7\u65f6\u949f\u4e2d\u65ad\u4e0d\u4f1a\u88ab\u5c4f\u853d os/src/main.rs \u8c03\u7528 timer::set_next_trigger \u8bbe\u7f6e\u65f6\u95f4\u7247 \u8c03\u7528 get_time \u83b7\u5f97\u5f53\u524d\u65f6\u95f4\uff0c \u5373 mtime \u7684\u503c \u4f30\u7b97\u51fa 10 ms \u540e mtime \u7684\u503c \u518d\u5c06\u4f30\u7b97\u7684\u503c\u8d4b\u503c\u7ed9 mtimecmp os/src/main.rs \u8c03\u7528 task \u6a21\u5757\u7684 run_first_task os/src/task/mod.rs \u9996\u5148\uff0c\u9759\u6001\u52a0\u8f7d\u4e00\u4e2a\u5168\u5c40\u7684\u4efb\u52a1\u7ba1\u7406\u5668 TaskManager \u7ed3\u6784 \u7684\u5b9e\u4f8b TASK_MANAGER,\u5305\u542b num_app \u548c inner inner \u5305\u62ec \u6570\u7ec4 tasks \u548c current_task \u6570\u7ec4 tasks \u662f TaskControlBlock \u7ed3\u6784\u7684\u6570\u7ec4 TaskControlBlock \u7ed3\u6784\u4f53 \u5305\u62ec \u4efb\u52a1\u72b6\u6001 task_status\u3001 \u4efb\u52a1\u4e0a\u4e0b\u6587 TaskContext (TaskContext \u5305\u542b \u90a314\u4e2a\u5bc4\u5b58\u5668)\u3001\u5185\u5b58\u8f6c\u6362\u9875 memory_set\u3001trap\u7684\u7269\u7406\u5730\u5740 trap_cx_ppn\u3001\u548c\u57fa\u5730\u5740base_size \u5bf9\u4efb\u52a1\u6570\u7ec4\u8fdb\u884c\u521d\u59cb\u5316\uff0c\u5bf9\u6bcf\u4e2a\u4efb\u52a1\u90fd\u5f62\u6210\u4e00\u4e2a\u4efb\u52a1\u63a7\u5236\u5757 os/src/tasks/tasks.rs \u5c06\u6bcf\u4e2a\u4efb\u52a1\u7684\u5730\u5740\u548c\u5176\u7f16\u53f7\u4f20\u5165\u5230 TaskControlBlock \u7ed3\u6784\u4f53\u7684 new\u65b9\u6cd5\u4e2d\uff0c\u7531\u4e8e\u4efb\u52a1\u6ca1\u6709\u53bb\u9664\u5143\u6570\u636e\uff0c\u76f4\u63a5\u751f\u6210\u7684ELF\u683c\u5f0f\uff0c\u6240\u6709\u8be5\u5730\u5740\u5c31\u76f8\u5f53\u4e8e\u662felf_data\u7684\u5730\u5740\uff0c \u5728new\u4e2d\uff0c\u5148\u540c\u8fc7\u5730\u5740\u83b7\u53d6ELF\u7ed3\u6784\u7684\u5934\u7684\u4fe1\u606f \u5c06TRAP_CONTEXT\u6b64\u65f6\u7684\u865a\u62df\u5730\u5740\u8f6c\u6210\u7269\u7406\u5730\u5740 \u5c06\u4efb\u52a1\u7684\u72b6\u6001\u7f6e\u4e3a Ready \u8c03\u7528config.rs\u4e2d\u7684kernel_stack_position\u901a\u8fc7app_id\u83b7\u53d6\u5185\u6838\u6808\u7684\u4e0a\u754c\u548c\u4e0b\u754c \u8c03\u7528KERNEL_SPACE \u7684 insert_framed_area - \u5728 os/src/mm/memory_set.rs\u4e2d - \u5c06\u865a\u62df\u7684\u8d77\u59cb\u5730\u5740\u548c\u7ed3\u675f\u5730\u5740\u4ee5\u53ca\u6743\u9650\u7b26\u53f7 \u4f20\u5165\u5230MapArea\u7684new\u65b9\u6cd5\u4e2d - new\u65b9\u6cd5\u4e2d\uff0c\u5c06\u865a\u62df\u5730\u5740\u533a\u95f4\u53d6\u6574\u8f6c\u6210\u865a\u62df\u9875\u53f7\uff0c\u518d\u5c06\u8fd9\u4e24\u4e2a\u865a\u62df\u9875\u53f7\u8f6c\u6210VPNRange\u8fd9\u4e2d\u8fed\u4ee3\u7c7b\u578b - \u751f\u6210\u4e00\u4e2a\u7a7a\u7684\u865a\u5b9e\u9875\u8868\u6620\u5c04\u7684\u952e\u503c\u5bf9 - \u6700\u540e\u8fd4\u56de\u8fd9\u4e2a\u6620\u5c04\u8868 \u5c06\u8fd9\u4e2a\u6620\u5c04\u8868\u5b58\u653e\u5230MemorySet\u4e2d\u7684areas\u8fd9\u4e2aVec\u5bb9 \u751f\u6210\u4e00\u4e2a\u4efb\u52a1\u63a7\u5236\u5757 \u8c03\u7528TaskContext\u7684goto_trap_return \u51fd\u6570 - \u5c06kernel_stack_top \u4f20\u5165\u5230\u6b64\u51fd\u6570\u4e2d - \u6839\u636e\u8fd9\u4e2a\u4efb\u52a1\u5728\u5185\u6838\u6808\u4e2d\u7684\u4f4d\u7f6e\uff0c\u83b7\u53d6\u5b83\u7684trap\u4e0a\u4e0b\u6587 \u6839\u636e\u4efb\u52a1\u72b6\u6001\u3001trap\u4e0a\u4e0b\u6587\u3001\u5185\u5b58\u6620\u5c04\u8868\u3001trap\u7684\u7269\u7406\u9875\u53f7\u3001\u7528\u6237\u6808\u7684\u8d77\u59cb\u5730\u5740\u751f\u6210\u4e00\u4e2a\u4efb\u52a1\u63a7\u5236\u5757 \u83b7\u5f97\u8fd9\u4e2a\u4efb\u52a1\u63a7\u5236\u5757\u4e2d trap\u7269\u7406\u9875\u53f7\u7684\u53ef\u53d8\u5f15\u7528 \u5c06\u83b7\u5f97\u7684\u4efb\u52a1\u7684\u5165\u53e3\u5730\u5740\u3001\u7528\u6237\u6808\u3001\u7269\u7406\u9875token\u3001\u5185\u6838\u6808\u9876\u3001trap_handler\u51fd\u6570\u7684\u5730\u5740\u4f20\u5165\u5230TrapContext\u7684app_init_context \u51fd\u6570\u4e2d \u5728app_init_context\u51fd\u6570\u4e2d\uff0c\u751f\u6210\u4e00\u4e2atrap\u4e0a\u4e0b\u6587 \u8fd9\u4e2a\u4e0a\u4e0b\u6587\u5305\u62ec 32\u7684\u901a\u7528\u5bc4\u5b58\u5668\u521d\u59cb\u5316\u4e3a0\uff0csstatus\u8bbe\u4e3a\u7528\u6237\u6001\u3001sepc\u6307\u5411ELF\u6587\u4ef6\u7684\u5165\u53e3\u5730\u5740\u3001kernel_satp\u5bc4\u5b58\u5668\uff0ckernel_sp\u5185\u6838\u6808\u3001trap\u5904\u7406\u51fd\u6570\u7684\u5165\u53e3\uff0csp\u6307\u5411\u4f20\u5165\u7684\u7528\u6237\u7684sp \u5c06\u8fd9\u4e2a\u751f\u6210\u7684\u4e0a\u4e0b\u6587\u4f20\u5165\u5230\u4efb\u52a1\u63a7\u5236\u5757\u4e2d\u7684\u4efb\u52a1\u4e0a\u4e0b\u6587 \u6700\u540e\u8fd4\u56de\u8fd9\u4efb\u52a1\u63a7\u5236\u5757 \u9759\u6001\u7684\u4efb\u52a1\u7ba1\u7406\u5668 TASK_MANAGER \u751f\u6210\uff0c\u5305\u62ec\u4efb\u52a1\u6570\u3001\u4efb\u52a1\u6570\u7ec4 \u5373\u5404\u4e2a\u4efb\u52a1\u7684\u63a7\u5236\u5757 \u548c \u5f53\u524d\u4efb\u52a1\u7684\u7f16\u53f7 \u8c03\u7528 run_first_task \u51fd\u6570\uff0c\u8be5\u51fd\u6570\u8c03\u7528\u4efb\u52a1\u7ba1\u7406\u5668\u7684 run_first_task \u65b9\u6cd5 \u5728run_first_task \u65b9\u6cd5\u4e2d \u5148\u83b7\u53d6\u4efb\u52a1\u7ba1\u7406\u5668\u7684\u9501\uff0c\u5373\u4f7f\u7528\u6743 \u7136\u540e\u5c06next\u4efb\u52a1\u7f6e\u4e3a\u7b2c0\u4e2a\u4efb\u52a1\u7684\u501f\u7528 \u5e76\u5c06next\u4efb\u52a1\u7684\u72b6\u6001 \u7f6e\u4e3a Running \u83b7\u53d6next\u4efb\u52a1\u7684\u4e0a\u4e0b\u6587\u7684\u5e94\u7528\uff0c\u7ed9\u4e00\u4e2a\u6307\u9488 \u521b\u5efa\u4e00\u4e2a\u865a\u7684\u4efb\u52a1\u4e0a\u4e0b\u6587\uff0c\u5c06\u5176\u5168\u521d\u59cb\u5316\u4e3a\u96f6\uff0c\u7531\u4e8e\u5b83\u4e0d\u4f1a\u771f\u6b63\u7528\u5230\uff0c\u6240\u6709\u5982\u4f55\u521d\u59cb\u5316\u90fd\u65e0\u5f71\u54cd \u6211\u4eec\u7684\u76ee\u7684\u5c31\u662f\u83b7\u53d6 \u4efb\u52a1\u4e0a\u4e0b\u6587\uff0c\u6b64\u65f6\u5df2\u7ecf\u83b7\u53d6\uff0c\u4e3a\u4e86\u5b89\u5168\uff0c\u5c06\u4efb\u52a10\u7684\u501f\u7528\u91ca\u653e\u6389 \u5c06\u6784\u9020\u7684\u5e8f\u865a\u4efb\u52a1\u4e0a\u4e0b\u6587\u4f5c\u4e3a\u5f53\u524d\u4e0a\u4e0b\u6587\u7684\u501f\u7528\uff0cnext\u4efb\u52a1\u4e0a\u4e0b\u6587\u7684\u5f15\u7528\u505a\u4e3a\u4e0b\u4e00\u4e2a\u4efb\u52a1\u4e0a\u4e0b\u6587\u4f20\u5165\u5230 __switch \u51fd\u6570\u4e2d\uff0c \u8fdb\u884c\u4e00\u756a\u5bc4\u5b58\u5668\u7684\u64cd\u4f5c\u540e\uff0c\u5207\u6362\u5230\u7b2c\u4e00\u4e2a\u4efb\u52a1\u7684\u7a7a\u95f4\uff0c\u6267\u884c\u7b2c\u4e00\u4e2a\u7528\u6237\u4efb\u52a1","title":"\u5230\u8fd9\u5b8c\u6210\u5206\u9875"},{"location":"ch4%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/#_6","text":"","title":"\u5bf9\u6d41\u7a0b\u8fdb\u884c\u6574\u7406\u5206\u6790"},{"location":"ch4%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/#_7","text":"","title":"\u5148\u770b\u7ed3\u6784\u548c\u5185\u5b58\u7684\u793a\u610f\u56fe"},{"location":"ch4%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/#_8","text":"\u5730\u5740\u7a7a\u95f4","title":"\u5806\u7ba1\u7406"},{"location":"ch4%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/#_9","text":"1","title":"\u5185\u6838\u5185\u5b58\u7ba1\u7406"},{"location":"ch4%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/#_10","text":"\u5728\u7269\u7406\u5185\u5b58\u4e0a sp -> boot_stack_top .bss.stack satp: 1000 0 ekernel.ceil \u8fdb\u5165\u5230 \u5185\u6838\u5730\u5740\u7a7a\u95f4 \u4e00\u5207\u7686\u4e3a\u865a\u62df\u5730\u5740 stvec -> trap_from_kernel \u5185\u6838\u5730\u5740 sie::set_stimer \u542f\u52a8\u65f6\u949f\u4e2d\u65ad ra: trap_return \u5185\u6838\u5730\u5740 s: [0; 12] sp -> kernel_stack_top\u4efb\u52a1\u4e00 \u5185\u6838\u5730\u5740 restore_va = TRAMPOLINE + size \u5185\u6838\u5730\u5740 -> .text.trampoline \u7269\u7406\u5730\u5740 jr restore_va stvec: TRAMPOLINE \u865a\u62df\u5730\u5740 trap_cx_ptr = TRAP_CONTEXT \u865a\u62df\u5730\u5740 __restore satp: 1000 0 app0.root_ppn \u8fdb\u5165\u5230\u4efb\u52a1\u4e00\u7684\u5730\u5740\u7a7a\u95f4 sscratch: TRAP_CONTEXT \u4efb\u52a1\u4e00\u7684\u5730\u5740\u7a7a\u95f4 sp -> TRAP_CONTEXT \u4efb\u52a1\u4e00\u5b9a\u7684\u5730\u5740\u7a7a\u95f4 sstatus: SPP:User sepc : \u4efb\u52a1\u4e00\u7684 entrypoint s: [0; 12] sp -> user_sp = user_stack_top \u4efb\u52a1\u4e00\u7684\u5730\u5740\u7a7a\u95f4 pc -> \u4efb\u52a1\u4e00\u7684 entrypoint sret pc -> sepc \u8fdb\u5165\u5230\u4efb\u52a1\u4e00 \u6267\u884c syscall \u8c03\u7528 ecall stvec -> TRAMPOLINE \u4efb\u52a1\u4e00\u7684\u5730\u5740\u7a7a\u95f4 __alltraps sp -> \u4efb\u52a1\u4e00\u7684 TRAP_CONTEXT sscratch -> User_stack_top \u4efb\u52a1\u4e00\u7684\u5730\u5740\u7a7a\u95f4 | sscratch | -> \u4efb\u52a1\u4e00\u7684\u5730\u5740\u7a7a\u95f4\u7684 TRAP_CONTEXT | sepc | -> ecall \u540e\u7684\u4e00\u6761\u6307\u4ee4 | sstatus | | x31 | | . | | x5 | | x3 | | x1 | | _ _ | \u4efb\u52a1\u4e00\u7684 user_stack_top sp -> kernel_sp\u4efb\u52a1\u4e00 \u672c\u8eab\u5c31\u662f\u5185\u6838\u5730\u5740\u7a7a\u95f4\u7684\u5730\u5740 satp : 1000 0 ekernel.ceil \u8fdb\u5165\u5230\u5185\u6838\u5730\u5740\u7a7a\u95f4 jr trap_handler \u672c\u8eab\u5c31\u662f\u5185\u6838\u5730\u5740\u7a7a\u95f4\u7684\u5730\u5740 stvec -> trap_from_kernel \u5185\u6838\u5730\u5740\u7a7a\u95f4\u7684\u5730\u5740 \u610f\u601d\u662f\u4e0d\u63a5\u53d7\u5185\u6838\u7684 Trap stvec -> TRAMPOLINE __restore sapt -> 1000 0 app0.root_ppn \u8fdb\u5165\u5230 \u4efb\u52a1\u4e00\u7684\u5730\u5740\u7a7a\u95f4 sscratch -> TRAP_CONTEXT sp -> TRAM_CONTEXT sstatus: SPP:User sepc -> ecall \u4e0b\u4e00\u6761\u6307\u4ee4 s[0; 12] sp -> User_stack_top pc -> ecall \u7684\u4e0b\u4e00\u6761\u6307\u4ee4 \u8fdb\u5165\u5230 \u4efb\u52a1\u4e00 \u5f53\u4efb\u52a1\u5207\u6362\u65f6 \u8fdb\u5165\u5230\u5185\u6838\u5730\u5740\u7a7a\u95f4 \u5c06\u5f53\u524d\u8f6c\u6001\u5b58\u5230\u4efb\u52a1\u4e00\u7684\u4efb\u52a1\u4e0a\u4e0b\u6587 \u6b64\u65f6\u4e3a\u5185\u6838\u5730\u5740\u7a7a\u95f4\uff0c\u53ef\u4ee5\u76f4\u63a5\u627e\u5230 \u5c06\u4efb\u52a1\u4e8c\u7684 \u4efb\u52a1\u4e0a\u4e0b\u6587\u52a0\u8f7d\u5230\u5bc4\u5b58\u5668\u4e2d ret pc -> trap_return","title":"\u4efb\u52a1\u7ba1\u7406"}]}